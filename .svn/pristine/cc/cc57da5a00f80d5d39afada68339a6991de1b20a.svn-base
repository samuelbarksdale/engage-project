<!DOCTYPE html>
<html lang="en">
  <head>
    <title>API</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.min.css" integrity="sha256-vK3UTo/8wHbaUn+dTQD0X6dzidqc5l7gczvH+Bnowwk=" crossorigin="anonymous" id="bulma-theme-light" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulmaswatch@0.7.5/cyborg/bulmaswatch.min.css" integrity="sha256-NEPZJFJGDcH6K+NW0Ij8VtItmbltoDzXHaZ4oBQzuvU=" crossorigin="anonymous" media="none" id="bulma-theme-dark" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/fontawesome.min.css" integrity="sha256-AaQqnjfGDRZd/lUp0Dvy7URGOyRsh8g9JdWUkyYxNfI=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/solid.min.css" integrity="sha256-3FfMfpeajSEpxWZTFowWZPTv7k3GEu7w4rQv49EWsEY=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.1.0/themes/prism-a11y-dark.css" integrity="sha256-d2qy226pP+oHAtEQPujaiXPslYW1Rmtla3Ivu1fFYxU=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma-switch@2.0.0/dist/css/bulma-switch.min.css" integrity="sha256-jCV/cXwP13w0GNHLgFx6SFgTNAvJPvS5MIhuE30Ng08=" crossorigin="anonymous">
    
    <style>
      @media screen and (min-width: 768px) {
        .navbar-burger {
          display: none;
        }
      }
    </style>
  </head>
  <body class="has-navbar-fixed-top">
    <script>var main = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function not_equal(a, b) {
        return a != a ? b == b : a !== b;
    }
    function validate_store(store, name) {
        if (!store || typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, callback) {
        const unsub = store.subscribe(callback);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
            : ctx.$$scope.ctx;
    }
    function get_slot_changes(definition, ctx, changed, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
            : ctx.$$scope.changed || {};
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function once(fn) {
        let ran = false;
        return function (...args) {
            if (ran)
                return;
            ran = true;
            fn.call(this, ...args);
        };
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;
    // used internally for testing
    function set_now(fn) {
        now = fn;
    }
    function set_raf(fn) {
        raf = fn;
    }

    const tasks = new Set();
    let running = false;
    function run_tasks() {
        tasks.forEach(task => {
            if (!task[0](now())) {
                tasks.delete(task);
                task[1]();
            }
        });
        running = tasks.size > 0;
        if (running)
            raf(run_tasks);
    }
    function clear_loops() {
        // for testing...
        tasks.forEach(task => tasks.delete(task));
        running = false;
    }
    function loop(fn) {
        let task;
        if (!running) {
            running = true;
            raf(run_tasks);
        }
        return {
            promise: new Promise(fulfil => {
                tasks.add(task = [fn, fulfil]);
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function element_is(name, is) {
        return document.createElement(name, { is });
    }
    function object_without_properties(obj, exclude) {
        // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion
        const target = {};
        for (const k in obj) {
            if (has_prop(obj, k)
                // @ts-ignore
                && exclude.indexOf(k) === -1) {
                // @ts-ignore
                target[k] = obj[k];
            }
        }
        return target;
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function self$1(fn) {
        return function (event) {
            // @ts-ignore
            if (event.target === this)
                fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function get_binding_group_value(group) {
        const value = [];
        for (let i = 0; i < group.length; i += 1) {
            if (group[i].checked)
                value.push(group[i].__value);
        }
        return value;
    }
    function to_number(value) {
        return value === '' ? undefined : +value;
    }
    function time_ranges_to_array(ranges) {
        const array = [];
        for (let i = 0; i < ranges.length; i += 1) {
            array.push({ start: ranges.start(i), end: ranges.end(i) });
        }
        return array;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function claim_element(nodes, name, attributes, svg) {
        for (let i = 0; i < nodes.length; i += 1) {
            const node = nodes[i];
            if (node.nodeName === name) {
                for (let j = 0; j < node.attributes.length; j += 1) {
                    const attribute = node.attributes[j];
                    if (!attributes[attribute.name])
                        node.removeAttribute(attribute.name);
                }
                return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes
            }
        }
        return svg ? svg_element(name) : element(name);
    }
    function claim_text(nodes, data) {
        for (let i = 0; i < nodes.length; i += 1) {
            const node = nodes[i];
            if (node.nodeType === 3) {
                node.data = '' + data;
                return nodes.splice(i, 1)[0];
            }
        }
        return text(data);
    }
    function claim_space(nodes) {
        return claim_text(nodes, ' ');
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.data !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        if (value != null || input.value) {
            input.value = value;
        }
    }
    function set_input_type(input, type) {
        try {
            input.type = type;
        }
        catch (e) {
            // do nothing
        }
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_options(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            option.selected = ~value.indexOf(option.__value);
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function select_multiple_value(select) {
        return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
    }
    function add_resize_listener(element, fn) {
        if (getComputedStyle(element).position === 'static') {
            element.style.position = 'relative';
        }
        const object = document.createElement('object');
        object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');
        object.setAttribute('aria-hidden', 'true');
        object.type = 'text/html';
        object.tabIndex = -1;
        let win;
        object.onload = () => {
            win = object.contentDocument.defaultView;
            win.addEventListener('resize', fn);
        };
        if (/Trident/.test(navigator.userAgent)) {
            element.appendChild(object);
            object.data = 'about:blank';
        }
        else {
            object.data = 'about:blank';
            element.appendChild(object);
        }
        return {
            cancel: () => {
                win && win.removeEventListener && win.removeEventListener('resize', fn);
                element.removeChild(object);
            }
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(html, anchor = null) {
            this.e = element('div');
            this.a = anchor;
            this.u(html);
        }
        m(target, anchor = null) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(target, this.n[i], anchor);
            }
            this.t = target;
        }
        u(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        p(html) {
            this.d();
            this.u(html);
            this.m(this.t, this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let stylesheet;
    let active = 0;
    let current_rules = {};
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        if (!current_rules[name]) {
            if (!stylesheet) {
                const style = element('style');
                document.head.appendChild(style);
                stylesheet = style.sheet;
            }
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        node.style.animation = (node.style.animation || '')
            .split(', ')
            .filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        )
            .join(', ');
        if (name && !--active)
            clear_rules();
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            current_rules = {};
        });
    }

    function create_animation(node, from, fn, params) {
        if (!from)
            return noop;
        const to = node.getBoundingClientRect();
        if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
            return noop;
        const { delay = 0, duration = 300, easing = identity, 
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = now() + delay, 
        // @ts-ignore todo:
        end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
        let running = true;
        let started = false;
        let name;
        function start() {
            if (css) {
                name = create_rule(node, 0, 1, duration, delay, easing, css);
            }
            if (!delay) {
                started = true;
            }
        }
        function stop() {
            if (css)
                delete_rule(node, name);
            running = false;
        }
        loop(now => {
            if (!started && now >= start_time) {
                started = true;
            }
            if (started && now >= end) {
                tick(1, 0);
                stop();
            }
            if (!running) {
                return false;
            }
            if (started) {
                const p = now - start_time;
                const t = 0 + 1 * easing(p / duration);
                tick(t, 1 - t);
            }
            return true;
        });
        start();
        tick(0, 1);
        return stop;
    }
    function fix_position(node) {
        const style = getComputedStyle(node);
        if (style.position !== 'absolute' && style.position !== 'fixed') {
            const { width, height } = style;
            const a = node.getBoundingClientRect();
            node.style.position = 'absolute';
            node.style.width = width;
            node.style.height = height;
            add_transform(node, a);
        }
    }
    function add_transform(node, a) {
        const b = node.getBoundingClientRect();
        if (a.left !== b.left || a.top !== b.top) {
            const style = getComputedStyle(node);
            const transform = style.transform === 'none' ? '' : style.transform;
            node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const intros = { enabled: false };
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    function flush() {
        const seen_callbacks = new Set();
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    callback();
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update($$.dirty);
            run_all($$.before_update);
            $$.fragment && $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = key && { [key]: value };
            const child_ctx = assign(assign({}, info.ctx), info.resolved);
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                info.blocks[i] = null;
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = { [info.value]: promise };
        }
    }

    const globals = (typeof window !== 'undefined' ? window : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function fix_and_destroy_block(block, lookup) {
        block.f();
        destroy_block(block, lookup);
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
        block.f();
        outro_and_destroy_block(block, lookup);
    }
    function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(changed, child_ctx);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function measure(blocks) {
        const rects = {};
        let i = blocks.length;
        while (i--)
            rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();
        return rects;
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    // source: https://html.spec.whatwg.org/multipage/indices.html
    const boolean_attributes = new Set([
        'allowfullscreen',
        'allowpaymentrequest',
        'async',
        'autofocus',
        'autoplay',
        'checked',
        'controls',
        'default',
        'defer',
        'disabled',
        'formnovalidate',
        'hidden',
        'ismap',
        'loop',
        'multiple',
        'muted',
        'nomodule',
        'novalidate',
        'open',
        'playsinline',
        'readonly',
        'required',
        'reversed',
        'selected'
    ]);

    const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
    // https://infra.spec.whatwg.org/#noncharacter
    function spread(args, classes_to_add) {
        const attributes = Object.assign({}, ...args);
        if (classes_to_add) {
            if (attributes.class == null) {
                attributes.class = classes_to_add;
            }
            else {
                attributes.class += ' ' + classes_to_add;
            }
        }
        let str = '';
        Object.keys(attributes).forEach(name => {
            if (invalid_attribute_name_character.test(name))
                return;
            const value = attributes[name];
            if (value === true)
                str += " " + name;
            else if (boolean_attributes.has(name.toLowerCase())) {
                if (value)
                    str += " " + name;
            }
            else if (value != null) {
                str += " " + name + "=" + JSON.stringify(String(value)
                    .replace(/"/g, '&#34;')
                    .replace(/'/g, '&#39;'));
            }
        });
        return str;
    }
    const escaped = {
        '"': '&quot;',
        "'": '&#39;',
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };
    function escape$1(html) {
        return String(html).replace(/["'&<>]/g, match => escaped[match]);
    }
    function each(items, fn) {
        let str = '';
        for (let i = 0; i < items.length; i += 1) {
            str += fn(items[i], i);
        }
        return str;
    }
    const missing_component = {
        $$render: () => ''
    };
    function validate_component(component, name) {
        if (!component || !component.$$render) {
            if (name === 'svelte:component')
                name += ' this={...}';
            throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
        }
        return component;
    }
    function debug(file, line, column, values) {
        console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
        console.log(values); // eslint-disable-line no-console
        return '';
    }
    let on_destroy;
    function create_ssr_component(fn) {
        function $$render(result, props, bindings, slots) {
            const parent_component = current_component;
            const $$ = {
                on_destroy,
                context: new Map(parent_component ? parent_component.$$.context : []),
                // these will be immediately discarded
                on_mount: [],
                before_update: [],
                after_update: [],
                callbacks: blank_object()
            };
            set_current_component({ $$ });
            const html = fn(result, props, bindings, slots);
            set_current_component(parent_component);
            return html;
        }
        return {
            render: (props = {}, options = {}) => {
                on_destroy = [];
                const result = { head: '', css: new Set() };
                const html = $$render(result, props, {}, options);
                run_all(on_destroy);
                return {
                    html,
                    css: {
                        code: Array.from(result.css).map(css => css.code).join('\n'),
                        map: null // TODO
                    },
                    head: result.head
                };
            },
            $$render
        };
    }
    function add_attribute(name, value, boolean) {
        if (value == null || (boolean && !value))
            return '';
        return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape$1(value)) : `"${value}"`}`}`;
    }
    function add_classes(classes) {
        return classes ? ` class="${classes}"` : ``;
    }

    function bind(component, name, callback) {
        if (has_prop(component.$$.props, name)) {
            name = component.$$.props[name] || name;
            component.$$.bound[name] = callback;
            callback(component.$$.ctx[name]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function claim_component(block, parent_nodes) {
        block && block.l(parent_nodes);
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = {};
        }
    }
    function make_dirty(component, key) {
        if (!component.$$.dirty) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty = blank_object();
        }
        component.$$.dirty[key] = true;
    }
    function init(component, options, instance, create_fragment, not_equal, props) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty: null
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (key, ret, value = ret) => {
                if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
                    if ($$.bound[key])
                        $$.bound[key](value);
                    if (ready)
                        make_dirty(component, key);
                }
                return ret;
            })
            : prop_values;
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    let SvelteElement;
    if (typeof HTMLElement === 'function') {
        SvelteElement = class extends HTMLElement {
            constructor() {
                super();
                this.attachShadow({ mode: 'open' });
            }
            connectedCallback() {
                // @ts-ignore todo: improve typings
                for (const key in this.$$.slotted) {
                    // @ts-ignore todo: improve typings
                    this.appendChild(this.$$.slotted[key]);
                }
            }
            attributeChangedCallback(attr, _oldValue, newValue) {
                this[attr] = newValue;
            }
            $destroy() {
                destroy_component(this, 1);
                this.$destroy = noop;
            }
            $on(type, callback) {
                // TODO should this delegate to addEventListener?
                const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
                callbacks.push(callback);
                return () => {
                    const index = callbacks.indexOf(callback);
                    if (index !== -1)
                        callbacks.splice(index, 1);
                };
            }
            $set() {
                // overridden by instance, if it has props
            }
        };
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, detail));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function detach_between_dev(before, after) {
        while (before.nextSibling && before.nextSibling !== after) {
            detach_dev(before.nextSibling);
        }
    }
    function detach_before_dev(after) {
        while (after.previousSibling) {
            detach_dev(after.previousSibling);
        }
    }
    function detach_after_dev(before) {
        while (before.nextSibling) {
            detach_dev(before.nextSibling);
        }
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function dataset_dev(node, property, value) {
        node.dataset[property] = value;
        dispatch_dev("SvelteDOMSetDataset", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
    }
    function loop_guard(timeout) {
        const start = Date.now();
        return () => {
            if (Date.now() - start > timeout) {
                throw new Error(`Infinite loop detected`);
            }
        };
    }

    'use strict';

    var has = Object.prototype.hasOwnProperty
      , undef;

    /**
     * Decode a URI encoded string.
     *
     * @param {String} input The URI encoded string.
     * @returns {String|Null} The decoded string.
     * @api private
     */
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, ' '));
      } catch (e) {
        return null;
      }
    }

    /**
     * Attempts to encode a given input.
     *
     * @param {String} input The string that needs to be encoded.
     * @returns {String|Null} The encoded string.
     * @api private
     */
    function encode(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }

    /**
     * Simple query string parser.
     *
     * @param {String} query The query string that needs to be parsed.
     * @returns {Object}
     * @api public
     */
    function querystring(query) {
      var parser = /([^=?&]+)=?([^&]*)/g
        , result = {}
        , part;

      while (part = parser.exec(query)) {
        var key = decode(part[1])
          , value = decode(part[2]);

        //
        // Prevent overriding of existing properties. This ensures that build-in
        // methods like `toString` or __proto__ are not overriden by malicious
        // querystrings.
        //
        // In the case if failed decoding, we want to omit the key/value pairs
        // from the result.
        //
        if (key === null || value === null || key in result) continue;
        result[key] = value;
      }

      return result;
    }

    /**
     * Transform a query string to an object.
     *
     * @param {Object} obj Object that should be transformed.
     * @param {String} prefix Optional prefix.
     * @returns {String}
     * @api public
     */
    function querystringify(obj, prefix) {
      prefix = prefix || '';

      var pairs = []
        , value
        , key;

      //
      // Optionally prefix with a '?' if needed
      //
      if ('string' !== typeof prefix) prefix = '?';

      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];

          //
          // Edge cases where we actually want to encode the value to an empty
          // string instead of the stringified value.
          //
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = '';
          }

          key = encodeURIComponent(key);
          value = encodeURIComponent(value);

          //
          // If we failed to encode the strings, we should bail out as we don't
          // want to add invalid strings to the query.
          //
          if (key === null || value === null) continue;
          pairs.push(key +'='+ value);
        }
      }

      return pairs.length ? prefix + pairs.join('&') : '';
    }

    //
    // Expose the module.
    //
    var stringify = querystringify;
    var parse = querystring;

    var querystringify_1 = {
    	stringify: stringify,
    	parse: parse
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var prism = createCommonjsModule(function (module) {
    /* **********************************************
         Begin prism-core.js
    ********************************************** */

    var _self = (typeof window !== 'undefined')
    	? window   // if in browser
    	: (
    		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
    		? self // if in worker
    		: {}   // if in node js
    	);

    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     * MIT license http://www.opensource.org/licenses/mit-license.php/
     * @author Lea Verou http://lea.verou.me
     */

    var Prism = (function (_self){

    // Private helper vars
    var lang = /\blang(?:uage)?-([\w-]+)\b/i;
    var uniqueId = 0;

    var _ = {
    	manual: _self.Prism && _self.Prism.manual,
    	disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
    	util: {
    		encode: function (tokens) {
    			if (tokens instanceof Token) {
    				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
    			} else if (Array.isArray(tokens)) {
    				return tokens.map(_.util.encode);
    			} else {
    				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
    			}
    		},

    		type: function (o) {
    			return Object.prototype.toString.call(o).slice(8, -1);
    		},

    		objId: function (obj) {
    			if (!obj['__id']) {
    				Object.defineProperty(obj, '__id', { value: ++uniqueId });
    			}
    			return obj['__id'];
    		},

    		// Deep clone a language definition (e.g. to extend it)
    		clone: function deepClone(o, visited) {
    			var clone, id, type = _.util.type(o);
    			visited = visited || {};

    			switch (type) {
    				case 'Object':
    					id = _.util.objId(o);
    					if (visited[id]) {
    						return visited[id];
    					}
    					clone = {};
    					visited[id] = clone;

    					for (var key in o) {
    						if (o.hasOwnProperty(key)) {
    							clone[key] = deepClone(o[key], visited);
    						}
    					}

    					return clone;

    				case 'Array':
    					id = _.util.objId(o);
    					if (visited[id]) {
    						return visited[id];
    					}
    					clone = [];
    					visited[id] = clone;

    					o.forEach(function (v, i) {
    						clone[i] = deepClone(v, visited);
    					});

    					return clone;

    				default:
    					return o;
    			}
    		}
    	},

    	languages: {
    		extend: function (id, redef) {
    			var lang = _.util.clone(_.languages[id]);

    			for (var key in redef) {
    				lang[key] = redef[key];
    			}

    			return lang;
    		},

    		/**
    		 * Insert a token before another token in a language literal
    		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
    		 * we cannot just provide an object, we need an object and a key.
    		 * @param inside The key (or language id) of the parent
    		 * @param before The key to insert before.
    		 * @param insert Object with the key/value pairs to insert
    		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
    		 */
    		insertBefore: function (inside, before, insert, root) {
    			root = root || _.languages;
    			var grammar = root[inside];
    			var ret = {};

    			for (var token in grammar) {
    				if (grammar.hasOwnProperty(token)) {

    					if (token == before) {
    						for (var newToken in insert) {
    							if (insert.hasOwnProperty(newToken)) {
    								ret[newToken] = insert[newToken];
    							}
    						}
    					}

    					// Do not insert token which also occur in insert. See #1525
    					if (!insert.hasOwnProperty(token)) {
    						ret[token] = grammar[token];
    					}
    				}
    			}

    			var old = root[inside];
    			root[inside] = ret;

    			// Update references in other language definitions
    			_.languages.DFS(_.languages, function(key, value) {
    				if (value === old && key != inside) {
    					this[key] = ret;
    				}
    			});

    			return ret;
    		},

    		// Traverse a language definition with Depth First Search
    		DFS: function DFS(o, callback, type, visited) {
    			visited = visited || {};

    			var objId = _.util.objId;

    			for (var i in o) {
    				if (o.hasOwnProperty(i)) {
    					callback.call(o, i, o[i], type || i);

    					var property = o[i],
    					    propertyType = _.util.type(property);

    					if (propertyType === 'Object' && !visited[objId(property)]) {
    						visited[objId(property)] = true;
    						DFS(property, callback, null, visited);
    					}
    					else if (propertyType === 'Array' && !visited[objId(property)]) {
    						visited[objId(property)] = true;
    						DFS(property, callback, i, visited);
    					}
    				}
    			}
    		}
    	},
    	plugins: {},

    	highlightAll: function(async, callback) {
    		_.highlightAllUnder(document, async, callback);
    	},

    	highlightAllUnder: function(container, async, callback) {
    		var env = {
    			callback: callback,
    			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
    		};

    		_.hooks.run('before-highlightall', env);

    		var elements = container.querySelectorAll(env.selector);

    		for (var i=0, element; element = elements[i++];) {
    			_.highlightElement(element, async === true, env.callback);
    		}
    	},

    	highlightElement: function(element, async, callback) {
    		// Find language
    		var language = 'none', grammar, parent = element;

    		while (parent && !lang.test(parent.className)) {
    			parent = parent.parentNode;
    		}

    		if (parent) {
    			language = (parent.className.match(lang) || [,'none'])[1].toLowerCase();
    			grammar = _.languages[language];
    		}

    		// Set language on the element, if not present
    		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

    		if (element.parentNode) {
    			// Set language on the parent, for styling
    			parent = element.parentNode;

    			if (/pre/i.test(parent.nodeName)) {
    				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
    			}
    		}

    		var code = element.textContent;

    		var env = {
    			element: element,
    			language: language,
    			grammar: grammar,
    			code: code
    		};

    		var insertHighlightedCode = function (highlightedCode) {
    			env.highlightedCode = highlightedCode;

    			_.hooks.run('before-insert', env);

    			env.element.innerHTML = env.highlightedCode;

    			_.hooks.run('after-highlight', env);
    			_.hooks.run('complete', env);
    			callback && callback.call(env.element);
    		};

    		_.hooks.run('before-sanity-check', env);

    		if (!env.code) {
    			_.hooks.run('complete', env);
    			return;
    		}

    		_.hooks.run('before-highlight', env);

    		if (!env.grammar) {
    			insertHighlightedCode(_.util.encode(env.code));
    			return;
    		}

    		if (async && _self.Worker) {
    			var worker = new Worker(_.filename);

    			worker.onmessage = function(evt) {
    				insertHighlightedCode(evt.data);
    			};

    			worker.postMessage(JSON.stringify({
    				language: env.language,
    				code: env.code,
    				immediateClose: true
    			}));
    		}
    		else {
    			insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
    		}
    	},

    	highlight: function (text, grammar, language) {
    		var env = {
    			code: text,
    			grammar: grammar,
    			language: language
    		};
    		_.hooks.run('before-tokenize', env);
    		env.tokens = _.tokenize(env.code, env.grammar);
    		_.hooks.run('after-tokenize', env);
    		return Token.stringify(_.util.encode(env.tokens), env.language);
    	},

    	matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {
    		for (var token in grammar) {
    			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
    				continue;
    			}

    			if (token == target) {
    				return;
    			}

    			var patterns = grammar[token];
    			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

    			for (var j = 0; j < patterns.length; ++j) {
    				var pattern = patterns[j],
    					inside = pattern.inside,
    					lookbehind = !!pattern.lookbehind,
    					greedy = !!pattern.greedy,
    					lookbehindLength = 0,
    					alias = pattern.alias;

    				if (greedy && !pattern.pattern.global) {
    					// Without the global flag, lastIndex won't work
    					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
    					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
    				}

    				pattern = pattern.pattern || pattern;

    				// Don’t cache length as it changes during the loop
    				for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {

    					var str = strarr[i];

    					if (strarr.length > text.length) {
    						// Something went terribly wrong, ABORT, ABORT!
    						return;
    					}

    					if (str instanceof Token) {
    						continue;
    					}

    					if (greedy && i != strarr.length - 1) {
    						pattern.lastIndex = pos;
    						var match = pattern.exec(text);
    						if (!match) {
    							break;
    						}

    						var from = match.index + (lookbehind ? match[1].length : 0),
    						    to = match.index + match[0].length,
    						    k = i,
    						    p = pos;

    						for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {
    							p += strarr[k].length;
    							// Move the index i to the element in strarr that is closest to from
    							if (from >= p) {
    								++i;
    								pos = p;
    							}
    						}

    						// If strarr[i] is a Token, then the match starts inside another Token, which is invalid
    						if (strarr[i] instanceof Token) {
    							continue;
    						}

    						// Number of tokens to delete and replace with the new match
    						delNum = k - i;
    						str = text.slice(pos, p);
    						match.index -= pos;
    					} else {
    						pattern.lastIndex = 0;

    						var match = pattern.exec(str),
    							delNum = 1;
    					}

    					if (!match) {
    						if (oneshot) {
    							break;
    						}

    						continue;
    					}

    					if(lookbehind) {
    						lookbehindLength = match[1] ? match[1].length : 0;
    					}

    					var from = match.index + lookbehindLength,
    					    match = match[0].slice(lookbehindLength),
    					    to = from + match.length,
    					    before = str.slice(0, from),
    					    after = str.slice(to);

    					var args = [i, delNum];

    					if (before) {
    						++i;
    						pos += before.length;
    						args.push(before);
    					}

    					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

    					args.push(wrapped);

    					if (after) {
    						args.push(after);
    					}

    					Array.prototype.splice.apply(strarr, args);

    					if (delNum != 1)
    						_.matchGrammar(text, strarr, grammar, i, pos, true, token);

    					if (oneshot)
    						break;
    				}
    			}
    		}
    	},

    	tokenize: function(text, grammar) {
    		var strarr = [text];

    		var rest = grammar.rest;

    		if (rest) {
    			for (var token in rest) {
    				grammar[token] = rest[token];
    			}

    			delete grammar.rest;
    		}

    		_.matchGrammar(text, strarr, grammar, 0, 0, false);

    		return strarr;
    	},

    	hooks: {
    		all: {},

    		add: function (name, callback) {
    			var hooks = _.hooks.all;

    			hooks[name] = hooks[name] || [];

    			hooks[name].push(callback);
    		},

    		run: function (name, env) {
    			var callbacks = _.hooks.all[name];

    			if (!callbacks || !callbacks.length) {
    				return;
    			}

    			for (var i=0, callback; callback = callbacks[i++];) {
    				callback(env);
    			}
    		}
    	},

    	Token: Token
    };

    _self.Prism = _;

    function Token(type, content, alias, matchedStr, greedy) {
    	this.type = type;
    	this.content = content;
    	this.alias = alias;
    	// Copy of the full string this token was created from
    	this.length = (matchedStr || "").length|0;
    	this.greedy = !!greedy;
    }

    Token.stringify = function(o, language) {
    	if (typeof o == 'string') {
    		return o;
    	}

    	if (Array.isArray(o)) {
    		return o.map(function(element) {
    			return Token.stringify(element, language);
    		}).join('');
    	}

    	var env = {
    		type: o.type,
    		content: Token.stringify(o.content, language),
    		tag: 'span',
    		classes: ['token', o.type],
    		attributes: {},
    		language: language
    	};

    	if (o.alias) {
    		var aliases = Array.isArray(o.alias) ? o.alias : [o.alias];
    		Array.prototype.push.apply(env.classes, aliases);
    	}

    	_.hooks.run('wrap', env);

    	var attributes = Object.keys(env.attributes).map(function(name) {
    		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    	}).join(' ');

    	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
    };

    if (!_self.document) {
    	if (!_self.addEventListener) {
    		// in Node.js
    		return _;
    	}

    	if (!_.disableWorkerMessageHandler) {
    		// In worker
    		_self.addEventListener('message', function (evt) {
    			var message = JSON.parse(evt.data),
    				lang = message.language,
    				code = message.code,
    				immediateClose = message.immediateClose;

    			_self.postMessage(_.highlight(code, _.languages[lang], lang));
    			if (immediateClose) {
    				_self.close();
    			}
    		}, false);
    	}

    	return _;
    }

    //Get current script and highlight
    var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

    if (script) {
    	_.filename = script.src;

    	if (!_.manual && !script.hasAttribute('data-manual')) {
    		if(document.readyState !== "loading") {
    			if (window.requestAnimationFrame) {
    				window.requestAnimationFrame(_.highlightAll);
    			} else {
    				window.setTimeout(_.highlightAll, 16);
    			}
    		}
    		else {
    			document.addEventListener('DOMContentLoaded', _.highlightAll);
    		}
    	}
    }

    return _;

    })(_self);

    if ('object' !== 'undefined' && module.exports) {
    	module.exports = Prism;
    }

    // hack for components to work correctly in node.js
    if (typeof commonjsGlobal !== 'undefined') {
    	commonjsGlobal.Prism = Prism;
    }


    /* **********************************************
         Begin prism-markup.js
    ********************************************** */

    Prism.languages.markup = {
    	'comment': /<!--[\s\S]*?-->/,
    	'prolog': /<\?[\s\S]+?\?>/,
    	'doctype': /<!DOCTYPE[\s\S]+?>/i,
    	'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
    	'tag': {
    		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/i,
    		greedy: true,
    		inside: {
    			'tag': {
    				pattern: /^<\/?[^\s>\/]+/i,
    				inside: {
    					'punctuation': /^<\/?/,
    					'namespace': /^[^\s>\/:]+:/
    				}
    			},
    			'attr-value': {
    				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
    				inside: {
    					'punctuation': [
    						/^=/,
    						{
    							pattern: /^(\s*)["']|["']$/,
    							lookbehind: true
    						}
    					]
    				}
    			},
    			'punctuation': /\/?>/,
    			'attr-name': {
    				pattern: /[^\s>\/]+/,
    				inside: {
    					'namespace': /^[^\s>\/:]+:/
    				}
    			}

    		}
    	},
    	'entity': /&#?[\da-z]{1,8};/i
    };

    Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
    	Prism.languages.markup['entity'];

    // Plugin to make entity title show the real entity, idea by Roman Komarov
    Prism.hooks.add('wrap', function(env) {

    	if (env.type === 'entity') {
    		env.attributes['title'] = env.content.replace(/&amp;/, '&');
    	}
    });

    Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
    	/**
    	 * Adds an inlined language to markup.
    	 *
    	 * An example of an inlined language is CSS with `<style>` tags.
    	 *
    	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
    	 * case insensitive.
    	 * @param {string} lang The language key.
    	 * @example
    	 * addInlined('style', 'css');
    	 */
    	value: function addInlined(tagName, lang) {
    		var includedCdataInside = {};
    		includedCdataInside['language-' + lang] = {
    			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
    			lookbehind: true,
    			inside: Prism.languages[lang]
    		};
    		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

    		var inside = {
    			'included-cdata': {
    				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    				inside: includedCdataInside
    			}
    		};
    		inside['language-' + lang] = {
    			pattern: /[\s\S]+/,
    			inside: Prism.languages[lang]
    		};

    		var def = {};
    		def[tagName] = {
    			pattern: RegExp(/(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(/__/g, tagName), 'i'),
    			lookbehind: true,
    			greedy: true,
    			inside: inside
    		};

    		Prism.languages.insertBefore('markup', 'cdata', def);
    	}
    });

    Prism.languages.xml = Prism.languages.extend('markup', {});
    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;


    /* **********************************************
         Begin prism-css.js
    ********************************************** */

    (function (Prism) {

    	var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;

    	Prism.languages.css = {
    		'comment': /\/\*[\s\S]*?\*\//,
    		'atrule': {
    			pattern: /@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/,
    			inside: {
    				'rule': /@[\w-]+/
    				// See rest below
    			}
    		},
    		'url': {
    			pattern: RegExp('url\\((?:' + string.source + '|[^\n\r()]*)\\)', 'i'),
    			inside: {
    				'function': /^url/i,
    				'punctuation': /^\(|\)$/
    			}
    		},
    		'selector': RegExp('[^{}\\s](?:[^{};"\']|' + string.source + ')*?(?=\\s*\\{)'),
    		'string': {
    			pattern: string,
    			greedy: true
    		},
    		'property': /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
    		'important': /!important\b/i,
    		'function': /[-a-z0-9]+(?=\()/i,
    		'punctuation': /[(){};:,]/
    	};

    	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

    	var markup = Prism.languages.markup;
    	if (markup) {
    		markup.tag.addInlined('style', 'css');

    		Prism.languages.insertBefore('inside', 'attr-value', {
    			'style-attr': {
    				pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
    				inside: {
    					'attr-name': {
    						pattern: /^\s*style/i,
    						inside: markup.tag.inside
    					},
    					'punctuation': /^\s*=\s*['"]|['"]\s*$/,
    					'attr-value': {
    						pattern: /.+/i,
    						inside: Prism.languages.css
    					}
    				},
    				alias: 'language-css'
    			}
    		}, markup.tag);
    	}

    }(Prism));


    /* **********************************************
         Begin prism-clike.js
    ********************************************** */

    Prism.languages.clike = {
    	'comment': [
    		{
    			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    			lookbehind: true
    		},
    		{
    			pattern: /(^|[^\\:])\/\/.*/,
    			lookbehind: true,
    			greedy: true
    		}
    	],
    	'string': {
    		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    		greedy: true
    	},
    	'class-name': {
    		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
    		lookbehind: true,
    		inside: {
    			punctuation: /[.\\]/
    		}
    	},
    	'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    	'boolean': /\b(?:true|false)\b/,
    	'function': /\w+(?=\()/,
    	'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
    	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
    	'punctuation': /[{}[\];(),.:]/
    };


    /* **********************************************
         Begin prism-javascript.js
    ********************************************** */

    Prism.languages.javascript = Prism.languages.extend('clike', {
    	'class-name': [
    		Prism.languages.clike['class-name'],
    		{
    			pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
    			lookbehind: true
    		}
    	],
    	'keyword': [
    		{
    			pattern: /((?:^|})\s*)(?:catch|finally)\b/,
    			lookbehind: true
    		},
    		{
    			pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    			lookbehind: true
    		},
    	],
    	'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
    	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    	'function': /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    	'operator': /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
    });

    Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;

    Prism.languages.insertBefore('javascript', 'keyword', {
    	'regex': {
    		pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,
    		lookbehind: true,
    		greedy: true
    	},
    	// This must be declared before keyword because we use "function" inside the look-forward
    	'function-variable': {
    		pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
    		alias: 'function'
    	},
    	'parameter': [
    		{
    			pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		}
    	],
    	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });

    Prism.languages.insertBefore('javascript', 'string', {
    	'template-string': {
    		pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
    		greedy: true,
    		inside: {
    			'template-punctuation': {
    				pattern: /^`|`$/,
    				alias: 'string'
    			},
    			'interpolation': {
    				pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
    				lookbehind: true,
    				inside: {
    					'interpolation-punctuation': {
    						pattern: /^\${|}$/,
    						alias: 'punctuation'
    					},
    					rest: Prism.languages.javascript
    				}
    			},
    			'string': /[\s\S]+/
    		}
    	}
    });

    if (Prism.languages.markup) {
    	Prism.languages.markup.tag.addInlined('script', 'javascript');
    }

    Prism.languages.js = Prism.languages.javascript;


    /* **********************************************
         Begin prism-file-highlight.js
    ********************************************** */

    (function () {
    	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
    		return;
    	}

    	/**
    	 * @param {Element} [container=document]
    	 */
    	self.Prism.fileHighlight = function(container) {
    		container = container || document;

    		var Extensions = {
    			'js': 'javascript',
    			'py': 'python',
    			'rb': 'ruby',
    			'ps1': 'powershell',
    			'psm1': 'powershell',
    			'sh': 'bash',
    			'bat': 'batch',
    			'h': 'c',
    			'tex': 'latex'
    		};

    		Array.prototype.slice.call(container.querySelectorAll('pre[data-src]')).forEach(function (pre) {
    			// ignore if already loaded
    			if (pre.hasAttribute('data-src-loaded')) {
    				return;
    			}

    			// load current
    			var src = pre.getAttribute('data-src');

    			var language, parent = pre;
    			var lang = /\blang(?:uage)?-([\w-]+)\b/i;
    			while (parent && !lang.test(parent.className)) {
    				parent = parent.parentNode;
    			}

    			if (parent) {
    				language = (pre.className.match(lang) || [, ''])[1];
    			}

    			if (!language) {
    				var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
    				language = Extensions[extension] || extension;
    			}

    			var code = document.createElement('code');
    			code.className = 'language-' + language;

    			pre.textContent = '';

    			code.textContent = 'Loading…';

    			pre.appendChild(code);

    			var xhr = new XMLHttpRequest();

    			xhr.open('GET', src, true);

    			xhr.onreadystatechange = function () {
    				if (xhr.readyState == 4) {

    					if (xhr.status < 400 && xhr.responseText) {
    						code.textContent = xhr.responseText;

    						Prism.highlightElement(code);
    						// mark as loaded
    						pre.setAttribute('data-src-loaded', '');
    					}
    					else if (xhr.status >= 400) {
    						code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
    					}
    					else {
    						code.textContent = '✖ Error: File does not exist or is empty';
    					}
    				}
    			};

    			xhr.send(null);
    		});

    		if (Prism.plugins.toolbar) {
    			Prism.plugins.toolbar.registerButton('download-file', function (env) {
    				var pre = env.element.parentNode;
    				if (!pre || !/pre/i.test(pre.nodeName) || !pre.hasAttribute('data-src') || !pre.hasAttribute('data-download-link')) {
    					return;
    				}
    				var src = pre.getAttribute('data-src');
    				var a = document.createElement('a');
    				a.textContent = pre.getAttribute('data-download-link-label') || 'Download';
    				a.setAttribute('download', '');
    				a.href = src;
    				return a;
    			});
    		}

    	};

    	document.addEventListener('DOMContentLoaded', function () {
    		// execute inside handler, for dropping Event as argument
    		self.Prism.fileHighlight();
    	});

    })();
    });

    var marked = createCommonjsModule(function (module, exports) {
    /**
     * marked - a markdown parser
     * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/markedjs/marked
     */

    ;(function(root) {
    'use strict';

    /**
     * Block-Level Grammar
     */

    var block = {
      newline: /^\n+/,
      code: /^( {4}[^\n]+\n*)+/,
      fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
      html: '^ {0,3}(?:' // optional indentation
        + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
        + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
        + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
        + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
        + ')',
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      nptable: noop,
      table: noop,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
      text: /^[^\n]+/
    };

    block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def)
      .replace('label', block._label)
      .replace('title', block._title)
      .getRegex();

    block.bullet = /(?:[*+-]|\d{1,9}\.)/;
    block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
    block.item = edit(block.item, 'gm')
      .replace(/bull/g, block.bullet)
      .getRegex();

    block.list = edit(block.list)
      .replace(/bull/g, block.bullet)
      .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
      .replace('def', '\\n+(?=' + block.def.source + ')')
      .getRegex();

    block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
      + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
      + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
      + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
      + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
      + '|track|ul';
    block._comment = /<!--(?!-?>)[\s\S]*?-->/;
    block.html = edit(block.html, 'i')
      .replace('comment', block._comment)
      .replace('tag', block._tag)
      .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
      .getRegex();

    block.paragraph = edit(block._paragraph)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} +')
      .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
      .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();

    block.blockquote = edit(block.blockquote)
      .replace('paragraph', block.paragraph)
      .getRegex();

    /**
     * Normal Block Grammar
     */

    block.normal = merge({}, block);

    /**
     * GFM Block Grammar
     */

    block.gfm = merge({}, block.normal, {
      nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
      table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
    });

    /**
     * Pedantic grammar (original John Gruber's loose markdown specification)
     */

    block.pedantic = merge({}, block.normal, {
      html: edit(
        '^ *(?:comment *(?:\\n|\\s*$)'
        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
        .replace('comment', block._comment)
        .replace(/tag/g, '(?!(?:'
          + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
          + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
          + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
      fences: noop, // fences not supported
      paragraph: edit(block.normal._paragraph)
        .replace('hr', block.hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', block.lheading)
        .replace('blockquote', ' {0,3}>')
        .replace('|fences', '')
        .replace('|list', '')
        .replace('|html', '')
        .getRegex()
    });

    /**
     * Block Lexer
     */

    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || marked.defaults;
      this.rules = block.normal;

      if (this.options.pedantic) {
        this.rules = block.pedantic;
      } else if (this.options.gfm) {
        this.rules = block.gfm;
      }
    }

    /**
     * Expose Block Rules
     */

    Lexer.rules = block;

    /**
     * Static Lex Method
     */

    Lexer.lex = function(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    };

    /**
     * Preprocessing
     */

    Lexer.prototype.lex = function(src) {
      src = src
        .replace(/\r\n|\r/g, '\n')
        .replace(/\t/g, '    ')
        .replace(/\u00a0/g, ' ')
        .replace(/\u2424/g, '\n');

      return this.token(src, true);
    };

    /**
     * Lexing
     */

    Lexer.prototype.token = function(src, top) {
      src = src.replace(/^ +$/gm, '');
      var next,
          loose,
          cap,
          bull,
          b,
          item,
          listStart,
          listItems,
          t,
          space,
          i,
          tag,
          l,
          isordered,
          istask,
          ischecked;

      while (src) {
        // newline
        if (cap = this.rules.newline.exec(src)) {
          src = src.substring(cap[0].length);
          if (cap[0].length > 1) {
            this.tokens.push({
              type: 'space'
            });
          }
        }

        // code
        if (cap = this.rules.code.exec(src)) {
          var lastToken = this.tokens[this.tokens.length - 1];
          src = src.substring(cap[0].length);
          // An indented code block cannot interrupt a paragraph.
          if (lastToken && lastToken.type === 'paragraph') {
            lastToken.text += '\n' + cap[0].trimRight();
          } else {
            cap = cap[0].replace(/^ {4}/gm, '');
            this.tokens.push({
              type: 'code',
              codeBlockStyle: 'indented',
              text: !this.options.pedantic
                ? rtrim(cap, '\n')
                : cap
            });
          }
          continue;
        }

        // fences
        if (cap = this.rules.fences.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'code',
            lang: cap[2] ? cap[2].trim() : cap[2],
            text: cap[3] || ''
          });
          continue;
        }

        // heading
        if (cap = this.rules.heading.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'heading',
            depth: cap[1].length,
            text: cap[2]
          });
          continue;
        }

        // table no leading pipe (gfm)
        if (cap = this.rules.nptable.exec(src)) {
          item = {
            type: 'table',
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
          };

          if (item.header.length === item.align.length) {
            src = src.substring(cap[0].length);

            for (i = 0; i < item.align.length; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }

            for (i = 0; i < item.cells.length; i++) {
              item.cells[i] = splitCells(item.cells[i], item.header.length);
            }

            this.tokens.push(item);

            continue;
          }
        }

        // hr
        if (cap = this.rules.hr.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'hr'
          });
          continue;
        }

        // blockquote
        if (cap = this.rules.blockquote.exec(src)) {
          src = src.substring(cap[0].length);

          this.tokens.push({
            type: 'blockquote_start'
          });

          cap = cap[0].replace(/^ *> ?/gm, '');

          // Pass `top` to keep the current
          // "toplevel" state. This is exactly
          // how markdown.pl works.
          this.token(cap, top);

          this.tokens.push({
            type: 'blockquote_end'
          });

          continue;
        }

        // list
        if (cap = this.rules.list.exec(src)) {
          src = src.substring(cap[0].length);
          bull = cap[2];
          isordered = bull.length > 1;

          listStart = {
            type: 'list_start',
            ordered: isordered,
            start: isordered ? +bull : '',
            loose: false
          };

          this.tokens.push(listStart);

          // Get each top-level item.
          cap = cap[0].match(this.rules.item);

          listItems = [];
          next = false;
          l = cap.length;
          i = 0;

          for (; i < l; i++) {
            item = cap[i];

            // Remove the list item's bullet
            // so it is seen as the next token.
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+\.) */, '');

            // Outdent whatever the
            // list item contains. Hacky.
            if (~item.indexOf('\n ')) {
              space -= item.length;
              item = !this.options.pedantic
                ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                : item.replace(/^ {1,4}/gm, '');
            }

            // Determine whether the next list item belongs here.
            // Backpedal if it does not belong in this list.
            if (i !== l - 1) {
              b = block.bullet.exec(cap[i + 1])[0];
              if (bull.length > 1 ? b.length === 1
                : (b.length > 1 || (this.options.smartLists && b !== bull))) {
                src = cap.slice(i + 1).join('\n') + src;
                i = l - 1;
              }
            }

            // Determine whether item is loose or not.
            // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
            // for discount behavior.
            loose = next || /\n\n(?!\s*$)/.test(item);
            if (i !== l - 1) {
              next = item.charAt(item.length - 1) === '\n';
              if (!loose) loose = next;
            }

            if (loose) {
              listStart.loose = true;
            }

            // Check for task list items
            istask = /^\[[ xX]\] /.test(item);
            ischecked = undefined;
            if (istask) {
              ischecked = item[1] !== ' ';
              item = item.replace(/^\[[ xX]\] +/, '');
            }

            t = {
              type: 'list_item_start',
              task: istask,
              checked: ischecked,
              loose: loose
            };

            listItems.push(t);
            this.tokens.push(t);

            // Recurse.
            this.token(item, false);

            this.tokens.push({
              type: 'list_item_end'
            });
          }

          if (listStart.loose) {
            l = listItems.length;
            i = 0;
            for (; i < l; i++) {
              listItems[i].loose = true;
            }
          }

          this.tokens.push({
            type: 'list_end'
          });

          continue;
        }

        // html
        if (cap = this.rules.html.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: this.options.sanitize
              ? 'paragraph'
              : 'html',
            pre: !this.options.sanitizer
              && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
            text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]
          });
          continue;
        }

        // def
        if (top && (cap = this.rules.def.exec(src))) {
          src = src.substring(cap[0].length);
          if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
          tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
          if (!this.tokens.links[tag]) {
            this.tokens.links[tag] = {
              href: cap[2],
              title: cap[3]
            };
          }
          continue;
        }

        // table (gfm)
        if (cap = this.rules.table.exec(src)) {
          item = {
            type: 'table',
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
          };

          if (item.header.length === item.align.length) {
            src = src.substring(cap[0].length);

            for (i = 0; i < item.align.length; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }

            for (i = 0; i < item.cells.length; i++) {
              item.cells[i] = splitCells(
                item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
                item.header.length);
            }

            this.tokens.push(item);

            continue;
          }
        }

        // lheading
        if (cap = this.rules.lheading.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'heading',
            depth: cap[2].charAt(0) === '=' ? 1 : 2,
            text: cap[1]
          });
          continue;
        }

        // top-level paragraph
        if (top && (cap = this.rules.paragraph.exec(src))) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'paragraph',
            text: cap[1].charAt(cap[1].length - 1) === '\n'
              ? cap[1].slice(0, -1)
              : cap[1]
          });
          continue;
        }

        // text
        if (cap = this.rules.text.exec(src)) {
          // Top-level should never reach here.
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'text',
            text: cap[0]
          });
          continue;
        }

        if (src) {
          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
      }

      return this.tokens;
    };

    /**
     * Inline-Level Grammar
     */

    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noop,
      tag: '^comment'
        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
      em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noop,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
    };

    // list of punctuation marks from common mark spec
    // without ` and ] to workaround Rule 17 (inline code blocks/links)
    inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
    inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();

    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink)
      .replace('scheme', inline._scheme)
      .replace('email', inline._email)
      .getRegex();

    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

    inline.tag = edit(inline.tag)
      .replace('comment', block._comment)
      .replace('attribute', inline._attribute)
      .getRegex();

    inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

    inline.link = edit(inline.link)
      .replace('label', inline._label)
      .replace('href', inline._href)
      .replace('title', inline._title)
      .getRegex();

    inline.reflink = edit(inline.reflink)
      .replace('label', inline._label)
      .getRegex();

    /**
     * Normal Inline Grammar
     */

    inline.normal = merge({}, inline);

    /**
     * Pedantic Inline Grammar
     */

    inline.pedantic = merge({}, inline.normal, {
      strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
      link: edit(/^!?\[(label)\]\((.*?)\)/)
        .replace('label', inline._label)
        .getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
        .replace('label', inline._label)
        .getRegex()
    });

    /**
     * GFM Inline Grammar
     */

    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace('])', '~|])').getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^~+(?=\S)([\s\S]*?\S)~+/,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
    });

    inline.gfm.url = edit(inline.gfm.url, 'i')
      .replace('email', inline.gfm._extended_email)
      .getRegex();
    /**
     * GFM + Line Breaks Inline Grammar
     */

    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace('{2,}', '*').getRegex(),
      text: edit(inline.gfm.text)
        .replace('\\b_', '\\b_| {2,}\\n')
        .replace(/\{2,\}/g, '*')
        .getRegex()
    });

    /**
     * Inline Lexer & Compiler
     */

    function InlineLexer(links, options) {
      this.options = options || marked.defaults;
      this.links = links;
      this.rules = inline.normal;
      this.renderer = this.options.renderer || new Renderer();
      this.renderer.options = this.options;

      if (!this.links) {
        throw new Error('Tokens array requires a `links` property.');
      }

      if (this.options.pedantic) {
        this.rules = inline.pedantic;
      } else if (this.options.gfm) {
        if (this.options.breaks) {
          this.rules = inline.breaks;
        } else {
          this.rules = inline.gfm;
        }
      }
    }

    /**
     * Expose Inline Rules
     */

    InlineLexer.rules = inline;

    /**
     * Static Lexing/Compiling Method
     */

    InlineLexer.output = function(src, links, options) {
      var inline = new InlineLexer(links, options);
      return inline.output(src);
    };

    /**
     * Lexing/Compiling
     */

    InlineLexer.prototype.output = function(src) {
      var out = '',
          link,
          text,
          href,
          title,
          cap,
          prevCapZero;

      while (src) {
        // escape
        if (cap = this.rules.escape.exec(src)) {
          src = src.substring(cap[0].length);
          out += escape(cap[1]);
          continue;
        }

        // tag
        if (cap = this.rules.tag.exec(src)) {
          if (!this.inLink && /^<a /i.test(cap[0])) {
            this.inLink = true;
          } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
            this.inLink = false;
          }
          if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.inRawBlock = true;
          } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.inRawBlock = false;
          }

          src = src.substring(cap[0].length);
          out += this.options.sanitize
            ? this.options.sanitizer
              ? this.options.sanitizer(cap[0])
              : escape(cap[0])
            : cap[0];
          continue;
        }

        // link
        if (cap = this.rules.link.exec(src)) {
          var lastParenIndex = findClosingBracket(cap[2], '()');
          if (lastParenIndex > -1) {
            var linkLen = 4 + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = '';
          }
          src = src.substring(cap[0].length);
          this.inLink = true;
          href = cap[2];
          if (this.options.pedantic) {
            link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

            if (link) {
              href = link[1];
              title = link[3];
            } else {
              title = '';
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : '';
          }
          href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
          out += this.outputLink(cap, {
            href: InlineLexer.escapes(href),
            title: InlineLexer.escapes(title)
          });
          this.inLink = false;
          continue;
        }

        // reflink, nolink
        if ((cap = this.rules.reflink.exec(src))
            || (cap = this.rules.nolink.exec(src))) {
          src = src.substring(cap[0].length);
          link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
          link = this.links[link.toLowerCase()];
          if (!link || !link.href) {
            out += cap[0].charAt(0);
            src = cap[0].substring(1) + src;
            continue;
          }
          this.inLink = true;
          out += this.outputLink(cap, link);
          this.inLink = false;
          continue;
        }

        // strong
        if (cap = this.rules.strong.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
          continue;
        }

        // em
        if (cap = this.rules.em.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
          continue;
        }

        // code
        if (cap = this.rules.code.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.codespan(escape(cap[2].trim(), true));
          continue;
        }

        // br
        if (cap = this.rules.br.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.br();
          continue;
        }

        // del (gfm)
        if (cap = this.rules.del.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.del(this.output(cap[1]));
          continue;
        }

        // autolink
        if (cap = this.rules.autolink.exec(src)) {
          src = src.substring(cap[0].length);
          if (cap[2] === '@') {
            text = escape(this.mangle(cap[1]));
            href = 'mailto:' + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          out += this.renderer.link(href, null, text);
          continue;
        }

        // url (gfm)
        if (!this.inLink && (cap = this.rules.url.exec(src))) {
          if (cap[2] === '@') {
            text = escape(cap[0]);
            href = 'mailto:' + text;
          } else {
            // do extended autolink path validation
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === 'www.') {
              href = 'http://' + text;
            } else {
              href = text;
            }
          }
          src = src.substring(cap[0].length);
          out += this.renderer.link(href, null, text);
          continue;
        }

        // text
        if (cap = this.rules.text.exec(src)) {
          src = src.substring(cap[0].length);
          if (this.inRawBlock) {
            out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);
          } else {
            out += this.renderer.text(escape(this.smartypants(cap[0])));
          }
          continue;
        }

        if (src) {
          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
      }

      return out;
    };

    InlineLexer.escapes = function(text) {
      return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
    };

    /**
     * Compile Link
     */

    InlineLexer.prototype.outputLink = function(cap, link) {
      var href = link.href,
          title = link.title ? escape(link.title) : null;

      return cap[0].charAt(0) !== '!'
        ? this.renderer.link(href, title, this.output(cap[1]))
        : this.renderer.image(href, title, escape(cap[1]));
    };

    /**
     * Smartypants Transformations
     */

    InlineLexer.prototype.smartypants = function(text) {
      if (!this.options.smartypants) return text;
      return text
        // em-dashes
        .replace(/---/g, '\u2014')
        // en-dashes
        .replace(/--/g, '\u2013')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026');
    };

    /**
     * Mangle Links
     */

    InlineLexer.prototype.mangle = function(text) {
      if (!this.options.mangle) return text;
      var out = '',
          l = text.length,
          i = 0,
          ch;

      for (; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = 'x' + ch.toString(16);
        }
        out += '&#' + ch + ';';
      }

      return out;
    };

    /**
     * Renderer
     */

    function Renderer(options) {
      this.options = options || marked.defaults;
    }

    Renderer.prototype.code = function(code, infostring, escaped) {
      var lang = (infostring || '').match(/\S*/)[0];
      if (this.options.highlight) {
        var out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }

      if (!lang) {
        return '<pre><code>'
          + (escaped ? code : escape(code, true))
          + '</code></pre>';
      }

      return '<pre><code class="'
        + this.options.langPrefix
        + escape(lang, true)
        + '">'
        + (escaped ? code : escape(code, true))
        + '</code></pre>\n';
    };

    Renderer.prototype.blockquote = function(quote) {
      return '<blockquote>\n' + quote + '</blockquote>\n';
    };

    Renderer.prototype.html = function(html) {
      return html;
    };

    Renderer.prototype.heading = function(text, level, raw, slugger) {
      if (this.options.headerIds) {
        return '<h'
          + level
          + ' id="'
          + this.options.headerPrefix
          + slugger.slug(raw)
          + '">'
          + text
          + '</h'
          + level
          + '>\n';
      }
      // ignore IDs
      return '<h' + level + '>' + text + '</h' + level + '>\n';
    };

    Renderer.prototype.hr = function() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    Renderer.prototype.list = function(body, ordered, start) {
      var type = ordered ? 'ol' : 'ul',
          startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
      return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    };

    Renderer.prototype.listitem = function(text) {
      return '<li>' + text + '</li>\n';
    };

    Renderer.prototype.checkbox = function(checked) {
      return '<input '
        + (checked ? 'checked="" ' : '')
        + 'disabled="" type="checkbox"'
        + (this.options.xhtml ? ' /' : '')
        + '> ';
    };

    Renderer.prototype.paragraph = function(text) {
      return '<p>' + text + '</p>\n';
    };

    Renderer.prototype.table = function(header, body) {
      if (body) body = '<tbody>' + body + '</tbody>';

      return '<table>\n'
        + '<thead>\n'
        + header
        + '</thead>\n'
        + body
        + '</table>\n';
    };

    Renderer.prototype.tablerow = function(content) {
      return '<tr>\n' + content + '</tr>\n';
    };

    Renderer.prototype.tablecell = function(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align
        ? '<' + type + ' align="' + flags.align + '">'
        : '<' + type + '>';
      return tag + content + '</' + type + '>\n';
    };

    // span level renderer
    Renderer.prototype.strong = function(text) {
      return '<strong>' + text + '</strong>';
    };

    Renderer.prototype.em = function(text) {
      return '<em>' + text + '</em>';
    };

    Renderer.prototype.codespan = function(text) {
      return '<code>' + text + '</code>';
    };

    Renderer.prototype.br = function() {
      return this.options.xhtml ? '<br/>' : '<br>';
    };

    Renderer.prototype.del = function(text) {
      return '<del>' + text + '</del>';
    };

    Renderer.prototype.link = function(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }
      var out = '<a href="' + escape(href) + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += '>' + text + '</a>';
      return out;
    };

    Renderer.prototype.image = function(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }

      var out = '<img src="' + href + '" alt="' + text + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    Renderer.prototype.text = function(text) {
      return text;
    };

    /**
     * TextRenderer
     * returns only the textual part of the token
     */

    function TextRenderer() {}

    // no need for block level renderers

    TextRenderer.prototype.strong =
    TextRenderer.prototype.em =
    TextRenderer.prototype.codespan =
    TextRenderer.prototype.del =
    TextRenderer.prototype.text = function(text) {
      return text;
    };

    TextRenderer.prototype.link =
    TextRenderer.prototype.image = function(href, title, text) {
      return '' + text;
    };

    TextRenderer.prototype.br = function() {
      return '';
    };

    /**
     * Parsing & Compiling
     */

    function Parser(options) {
      this.tokens = [];
      this.token = null;
      this.options = options || marked.defaults;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.slugger = new Slugger();
    }

    /**
     * Static Parse Method
     */

    Parser.parse = function(src, options) {
      var parser = new Parser(options);
      return parser.parse(src);
    };

    /**
     * Parse Loop
     */

    Parser.prototype.parse = function(src) {
      this.inline = new InlineLexer(src.links, this.options);
      // use an InlineLexer with a TextRenderer to extract pure text
      this.inlineText = new InlineLexer(
        src.links,
        merge({}, this.options, { renderer: new TextRenderer() })
      );
      this.tokens = src.reverse();

      var out = '';
      while (this.next()) {
        out += this.tok();
      }

      return out;
    };

    /**
     * Next Token
     */

    Parser.prototype.next = function() {
      this.token = this.tokens.pop();
      return this.token;
    };

    /**
     * Preview Next Token
     */

    Parser.prototype.peek = function() {
      return this.tokens[this.tokens.length - 1] || 0;
    };

    /**
     * Parse Text Tokens
     */

    Parser.prototype.parseText = function() {
      var body = this.token.text;

      while (this.peek().type === 'text') {
        body += '\n' + this.next().text;
      }

      return this.inline.output(body);
    };

    /**
     * Parse Current Token
     */

    Parser.prototype.tok = function() {
      switch (this.token.type) {
        case 'space': {
          return '';
        }
        case 'hr': {
          return this.renderer.hr();
        }
        case 'heading': {
          return this.renderer.heading(
            this.inline.output(this.token.text),
            this.token.depth,
            unescape(this.inlineText.output(this.token.text)),
            this.slugger);
        }
        case 'code': {
          return this.renderer.code(this.token.text,
            this.token.lang,
            this.token.escaped);
        }
        case 'table': {
          var header = '',
              body = '',
              i,
              row,
              cell,
              j;

          // header
          cell = '';
          for (i = 0; i < this.token.header.length; i++) {
            cell += this.renderer.tablecell(
              this.inline.output(this.token.header[i]),
              { header: true, align: this.token.align[i] }
            );
          }
          header += this.renderer.tablerow(cell);

          for (i = 0; i < this.token.cells.length; i++) {
            row = this.token.cells[i];

            cell = '';
            for (j = 0; j < row.length; j++) {
              cell += this.renderer.tablecell(
                this.inline.output(row[j]),
                { header: false, align: this.token.align[j] }
              );
            }

            body += this.renderer.tablerow(cell);
          }
          return this.renderer.table(header, body);
        }
        case 'blockquote_start': {
          body = '';

          while (this.next().type !== 'blockquote_end') {
            body += this.tok();
          }

          return this.renderer.blockquote(body);
        }
        case 'list_start': {
          body = '';
          var ordered = this.token.ordered,
              start = this.token.start;

          while (this.next().type !== 'list_end') {
            body += this.tok();
          }

          return this.renderer.list(body, ordered, start);
        }
        case 'list_item_start': {
          body = '';
          var loose = this.token.loose;
          var checked = this.token.checked;
          var task = this.token.task;

          if (this.token.task) {
            body += this.renderer.checkbox(checked);
          }

          while (this.next().type !== 'list_item_end') {
            body += !loose && this.token.type === 'text'
              ? this.parseText()
              : this.tok();
          }
          return this.renderer.listitem(body, task, checked);
        }
        case 'html': {
          // TODO parse inline content if parameter markdown=1
          return this.renderer.html(this.token.text);
        }
        case 'paragraph': {
          return this.renderer.paragraph(this.inline.output(this.token.text));
        }
        case 'text': {
          return this.renderer.paragraph(this.parseText());
        }
        default: {
          var errMsg = 'Token with "' + this.token.type + '" type was not found.';
          if (this.options.silent) {
            console.log(errMsg);
          } else {
            throw new Error(errMsg);
          }
        }
      }
    };

    /**
     * Slugger generates header id
     */

    function Slugger() {
      this.seen = {};
    }

    /**
     * Convert string to unique id
     */

    Slugger.prototype.slug = function(value) {
      var slug = value
        .toLowerCase()
        .trim()
        .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
        .replace(/\s/g, '-');

      if (this.seen.hasOwnProperty(slug)) {
        var originalSlug = slug;
        do {
          this.seen[originalSlug]++;
          slug = originalSlug + '-' + this.seen[originalSlug];
        } while (this.seen.hasOwnProperty(slug));
      }
      this.seen[slug] = 0;

      return slug;
    };

    /**
     * Helpers
     */

    function escape(html, encode) {
      if (encode) {
        if (escape.escapeTest.test(html)) {
          return html.replace(escape.escapeReplace, function(ch) { return escape.replacements[ch]; });
        }
      } else {
        if (escape.escapeTestNoEncode.test(html)) {
          return html.replace(escape.escapeReplaceNoEncode, function(ch) { return escape.replacements[ch]; });
        }
      }

      return html;
    }

    escape.escapeTest = /[&<>"']/;
    escape.escapeReplace = /[&<>"']/g;
    escape.replacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;

    function unescape(html) {
      // explicitly match decimal, hex, and named HTML entities
      return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x'
            ? String.fromCharCode(parseInt(n.substring(2), 16))
            : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }

    function edit(regex, opt) {
      regex = regex.source || regex;
      opt = opt || '';
      return {
        replace: function(name, val) {
          val = val.source || val;
          val = val.replace(/(^|[^\[])\^/g, '$1');
          regex = regex.replace(name, val);
          return this;
        },
        getRegex: function() {
          return new RegExp(regex, opt);
        }
      };
    }

    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        try {
          var prot = decodeURIComponent(unescape(href))
            .replace(/[^\w:]/g, '')
            .toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, '%');
      } catch (e) {
        return null;
      }
      return href;
    }

    function resolveUrl(base, href) {
      if (!baseUrls[' ' + base]) {
        // we can ignore everything in base after the last slash of its path component,
        // but we might need to add _that_
        // https://tools.ietf.org/html/rfc3986#section-3
        if (/^[^:]+:\/*[^/]*$/.test(base)) {
          baseUrls[' ' + base] = base + '/';
        } else {
          baseUrls[' ' + base] = rtrim(base, '/', true);
        }
      }
      base = baseUrls[' ' + base];

      if (href.slice(0, 2) === '//') {
        return base.replace(/:[\s\S]*/, ':') + href;
      } else if (href.charAt(0) === '/') {
        return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
      } else {
        return base + href;
      }
    }
    var baseUrls = {};
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

    function noop() {}
    noop.exec = noop;

    function merge(obj) {
      var i = 1,
          target,
          key;

      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }

      return obj;
    }

    function splitCells(tableRow, count) {
      // ensure that every cell-delimiting pipe has a space
      // before it to distinguish it from an escaped pipe
      var row = tableRow.replace(/\|/g, function(match, offset, str) {
            var escaped = false,
                curr = offset;
            while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
            if (escaped) {
              // odd number of slashes means | is escaped
              // so we leave it alone
              return '|';
            } else {
              // add space before unescaped |
              return ' |';
            }
          }),
          cells = row.split(/ \|/),
          i = 0;

      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) cells.push('');
      }

      for (; i < cells.length; i++) {
        // leading or trailing whitespace is ignored per the gfm spec
        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
      }
      return cells;
    }

    // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
    // /c*$/ is vulnerable to REDOS.
    // invert: Remove suffix of non-c chars instead. Default falsey.
    function rtrim(str, c, invert) {
      if (str.length === 0) {
        return '';
      }

      // Length of suffix matching the invert condition.
      var suffLen = 0;

      // Step left until we fail to match the invert condition.
      while (suffLen < str.length) {
        var currChar = str.charAt(str.length - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }

      return str.substr(0, str.length - suffLen);
    }

    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      var level = 0;
      for (var i = 0; i < str.length; i++) {
        if (str[i] === '\\') {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }

    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
      }
    }

    /**
     * Marked
     */

    function marked(src, opt, callback) {
      // throw error in case of non string input
      if (typeof src === 'undefined' || src === null) {
        throw new Error('marked(): input parameter is undefined or null');
      }
      if (typeof src !== 'string') {
        throw new Error('marked(): input parameter is of type '
          + Object.prototype.toString.call(src) + ', string expected');
      }

      if (callback || typeof opt === 'function') {
        if (!callback) {
          callback = opt;
          opt = null;
        }

        opt = merge({}, marked.defaults, opt || {});
        checkSanitizeDeprecation(opt);

        var highlight = opt.highlight,
            tokens,
            pending,
            i = 0;

        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }

        pending = tokens.length;

        var done = function(err) {
          if (err) {
            opt.highlight = highlight;
            return callback(err);
          }

          var out;

          try {
            out = Parser.parse(tokens, opt);
          } catch (e) {
            err = e;
          }

          opt.highlight = highlight;

          return err
            ? callback(err)
            : callback(null, out);
        };

        if (!highlight || highlight.length < 3) {
          return done();
        }

        delete opt.highlight;

        if (!pending) return done();

        for (; i < tokens.length; i++) {
          (function(token) {
            if (token.type !== 'code') {
              return --pending || done();
            }
            return highlight(token.text, token.lang, function(err, code) {
              if (err) return done(err);
              if (code == null || code === token.text) {
                return --pending || done();
              }
              token.text = code;
              token.escaped = true;
              --pending || done();
            });
          })(tokens[i]);
        }

        return;
      }
      try {
        if (opt) opt = merge({}, marked.defaults, opt);
        checkSanitizeDeprecation(opt);
        return Parser.parse(Lexer.lex(src, opt), opt);
      } catch (e) {
        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
        if ((opt || marked.defaults).silent) {
          return '<p>An error occurred:</p><pre>'
            + escape(e.message + '', true)
            + '</pre>';
        }
        throw e;
      }
    }

    /**
     * Options
     */

    marked.options =
    marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      return marked;
    };

    marked.getDefaults = function() {
      return {
        baseUrl: null,
        breaks: false,
        gfm: true,
        headerIds: true,
        headerPrefix: '',
        highlight: null,
        langPrefix: 'language-',
        mangle: true,
        pedantic: false,
        renderer: new Renderer(),
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        xhtml: false
      };
    };

    marked.defaults = marked.getDefaults();

    /**
     * Expose
     */

    marked.Parser = Parser;
    marked.parser = Parser.parse;

    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;

    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;

    marked.InlineLexer = InlineLexer;
    marked.inlineLexer = InlineLexer.output;

    marked.Slugger = Slugger;

    marked.parse = marked;

    if ('object' !== 'undefined' && 'object' === 'object') {
      module.exports = marked;
    } else if (typeof undefined === 'function' && undefined.amd) {
      undefined(function() { return marked; });
    } else {
      root.marked = marked;
    }
    })(commonjsGlobal || (typeof window !== 'undefined' ? window : commonjsGlobal));
    });

    var speakingurl = createCommonjsModule(function (module) {
    (function (root) {
        'use strict';

        /**
         * charMap
         * @type {Object}
         */
        var charMap = {

            // latin
            'À': 'A',
            'Á': 'A',
            'Â': 'A',
            'Ã': 'A',
            'Ä': 'Ae',
            'Å': 'A',
            'Æ': 'AE',
            'Ç': 'C',
            'È': 'E',
            'É': 'E',
            'Ê': 'E',
            'Ë': 'E',
            'Ì': 'I',
            'Í': 'I',
            'Î': 'I',
            'Ï': 'I',
            'Ð': 'D',
            'Ñ': 'N',
            'Ò': 'O',
            'Ó': 'O',
            'Ô': 'O',
            'Õ': 'O',
            'Ö': 'Oe',
            'Ő': 'O',
            'Ø': 'O',
            'Ù': 'U',
            'Ú': 'U',
            'Û': 'U',
            'Ü': 'Ue',
            'Ű': 'U',
            'Ý': 'Y',
            'Þ': 'TH',
            'ß': 'ss',
            'à': 'a',
            'á': 'a',
            'â': 'a',
            'ã': 'a',
            'ä': 'ae',
            'å': 'a',
            'æ': 'ae',
            'ç': 'c',
            'è': 'e',
            'é': 'e',
            'ê': 'e',
            'ë': 'e',
            'ì': 'i',
            'í': 'i',
            'î': 'i',
            'ï': 'i',
            'ð': 'd',
            'ñ': 'n',
            'ò': 'o',
            'ó': 'o',
            'ô': 'o',
            'õ': 'o',
            'ö': 'oe',
            'ő': 'o',
            'ø': 'o',
            'ù': 'u',
            'ú': 'u',
            'û': 'u',
            'ü': 'ue',
            'ű': 'u',
            'ý': 'y',
            'þ': 'th',
            'ÿ': 'y',
            'ẞ': 'SS',

            // language specific

            // Arabic
            'ا': 'a',
            'أ': 'a',
            'إ': 'i',
            'آ': 'aa',
            'ؤ': 'u',
            'ئ': 'e',
            'ء': 'a',
            'ب': 'b',
            'ت': 't',
            'ث': 'th',
            'ج': 'j',
            'ح': 'h',
            'خ': 'kh',
            'د': 'd',
            'ذ': 'th',
            'ر': 'r',
            'ز': 'z',
            'س': 's',
            'ش': 'sh',
            'ص': 's',
            'ض': 'dh',
            'ط': 't',
            'ظ': 'z',
            'ع': 'a',
            'غ': 'gh',
            'ف': 'f',
            'ق': 'q',
            'ك': 'k',
            'ل': 'l',
            'م': 'm',
            'ن': 'n',
            'ه': 'h',
            'و': 'w',
            'ي': 'y',
            'ى': 'a',
            'ة': 'h',
            'ﻻ': 'la',
            'ﻷ': 'laa',
            'ﻹ': 'lai',
            'ﻵ': 'laa',

            // Persian additional characters than Arabic
            'گ': 'g',
            'چ': 'ch',
            'پ': 'p',
            'ژ': 'zh',
            'ک': 'k',
            'ی': 'y',

            // Arabic diactrics
            'َ': 'a',
            'ً': 'an',
            'ِ': 'e',
            'ٍ': 'en',
            'ُ': 'u',
            'ٌ': 'on',
            'ْ': '',

            // Arabic numbers
            '٠': '0',
            '١': '1',
            '٢': '2',
            '٣': '3',
            '٤': '4',
            '٥': '5',
            '٦': '6',
            '٧': '7',
            '٨': '8',
            '٩': '9',

            // Persian numbers
            '۰': '0',
            '۱': '1',
            '۲': '2',
            '۳': '3',
            '۴': '4',
            '۵': '5',
            '۶': '6',
            '۷': '7',
            '۸': '8',
            '۹': '9',

            // Burmese consonants
            'က': 'k',
            'ခ': 'kh',
            'ဂ': 'g',
            'ဃ': 'ga',
            'င': 'ng',
            'စ': 's',
            'ဆ': 'sa',
            'ဇ': 'z',
            'စျ': 'za',
            'ည': 'ny',
            'ဋ': 't',
            'ဌ': 'ta',
            'ဍ': 'd',
            'ဎ': 'da',
            'ဏ': 'na',
            'တ': 't',
            'ထ': 'ta',
            'ဒ': 'd',
            'ဓ': 'da',
            'န': 'n',
            'ပ': 'p',
            'ဖ': 'pa',
            'ဗ': 'b',
            'ဘ': 'ba',
            'မ': 'm',
            'ယ': 'y',
            'ရ': 'ya',
            'လ': 'l',
            'ဝ': 'w',
            'သ': 'th',
            'ဟ': 'h',
            'ဠ': 'la',
            'အ': 'a',
            // consonant character combos
            'ြ': 'y',
            'ျ': 'ya',
            'ွ': 'w',
            'ြွ': 'yw',
            'ျွ': 'ywa',
            'ှ': 'h',
            // independent vowels
            'ဧ': 'e',
            '၏': '-e',
            'ဣ': 'i',
            'ဤ': '-i',
            'ဉ': 'u',
            'ဦ': '-u',
            'ဩ': 'aw',
            'သြော': 'aw',
            'ဪ': 'aw',
            // numbers
            '၀': '0',
            '၁': '1',
            '၂': '2',
            '၃': '3',
            '၄': '4',
            '၅': '5',
            '၆': '6',
            '၇': '7',
            '၈': '8',
            '၉': '9',
            // virama and tone marks which are silent in transliteration
            '္': '',
            '့': '',
            'း': '',

            // Czech
            'č': 'c',
            'ď': 'd',
            'ě': 'e',
            'ň': 'n',
            'ř': 'r',
            'š': 's',
            'ť': 't',
            'ů': 'u',
            'ž': 'z',
            'Č': 'C',
            'Ď': 'D',
            'Ě': 'E',
            'Ň': 'N',
            'Ř': 'R',
            'Š': 'S',
            'Ť': 'T',
            'Ů': 'U',
            'Ž': 'Z',

            // Dhivehi
            'ހ': 'h',
            'ށ': 'sh',
            'ނ': 'n',
            'ރ': 'r',
            'ބ': 'b',
            'ޅ': 'lh',
            'ކ': 'k',
            'އ': 'a',
            'ވ': 'v',
            'މ': 'm',
            'ފ': 'f',
            'ދ': 'dh',
            'ތ': 'th',
            'ލ': 'l',
            'ގ': 'g',
            'ޏ': 'gn',
            'ސ': 's',
            'ޑ': 'd',
            'ޒ': 'z',
            'ޓ': 't',
            'ޔ': 'y',
            'ޕ': 'p',
            'ޖ': 'j',
            'ޗ': 'ch',
            'ޘ': 'tt',
            'ޙ': 'hh',
            'ޚ': 'kh',
            'ޛ': 'th',
            'ޜ': 'z',
            'ޝ': 'sh',
            'ޞ': 's',
            'ޟ': 'd',
            'ޠ': 't',
            'ޡ': 'z',
            'ޢ': 'a',
            'ޣ': 'gh',
            'ޤ': 'q',
            'ޥ': 'w',
            'ަ': 'a',
            'ާ': 'aa',
            'ި': 'i',
            'ީ': 'ee',
            'ު': 'u',
            'ޫ': 'oo',
            'ެ': 'e',
            'ޭ': 'ey',
            'ޮ': 'o',
            'ޯ': 'oa',
            'ް': '',

            // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
            // National system (2002)
            'ა': 'a',
            'ბ': 'b',
            'გ': 'g',
            'დ': 'd',
            'ე': 'e',
            'ვ': 'v',
            'ზ': 'z',
            'თ': 't',
            'ი': 'i',
            'კ': 'k',
            'ლ': 'l',
            'მ': 'm',
            'ნ': 'n',
            'ო': 'o',
            'პ': 'p',
            'ჟ': 'zh',
            'რ': 'r',
            'ს': 's',
            'ტ': 't',
            'უ': 'u',
            'ფ': 'p',
            'ქ': 'k',
            'ღ': 'gh',
            'ყ': 'q',
            'შ': 'sh',
            'ჩ': 'ch',
            'ც': 'ts',
            'ძ': 'dz',
            'წ': 'ts',
            'ჭ': 'ch',
            'ხ': 'kh',
            'ჯ': 'j',
            'ჰ': 'h',

            // Greek
            'α': 'a',
            'β': 'v',
            'γ': 'g',
            'δ': 'd',
            'ε': 'e',
            'ζ': 'z',
            'η': 'i',
            'θ': 'th',
            'ι': 'i',
            'κ': 'k',
            'λ': 'l',
            'μ': 'm',
            'ν': 'n',
            'ξ': 'ks',
            'ο': 'o',
            'π': 'p',
            'ρ': 'r',
            'σ': 's',
            'τ': 't',
            'υ': 'y',
            'φ': 'f',
            'χ': 'x',
            'ψ': 'ps',
            'ω': 'o',
            'ά': 'a',
            'έ': 'e',
            'ί': 'i',
            'ό': 'o',
            'ύ': 'y',
            'ή': 'i',
            'ώ': 'o',
            'ς': 's',
            'ϊ': 'i',
            'ΰ': 'y',
            'ϋ': 'y',
            'ΐ': 'i',
            'Α': 'A',
            'Β': 'B',
            'Γ': 'G',
            'Δ': 'D',
            'Ε': 'E',
            'Ζ': 'Z',
            'Η': 'I',
            'Θ': 'TH',
            'Ι': 'I',
            'Κ': 'K',
            'Λ': 'L',
            'Μ': 'M',
            'Ν': 'N',
            'Ξ': 'KS',
            'Ο': 'O',
            'Π': 'P',
            'Ρ': 'R',
            'Σ': 'S',
            'Τ': 'T',
            'Υ': 'Y',
            'Φ': 'F',
            'Χ': 'X',
            'Ψ': 'PS',
            'Ω': 'O',
            'Ά': 'A',
            'Έ': 'E',
            'Ί': 'I',
            'Ό': 'O',
            'Ύ': 'Y',
            'Ή': 'I',
            'Ώ': 'O',
            'Ϊ': 'I',
            'Ϋ': 'Y',

            // Latvian
            'ā': 'a',
            // 'č': 'c', // duplicate
            'ē': 'e',
            'ģ': 'g',
            'ī': 'i',
            'ķ': 'k',
            'ļ': 'l',
            'ņ': 'n',
            // 'š': 's', // duplicate
            'ū': 'u',
            // 'ž': 'z', // duplicate
            'Ā': 'A',
            // 'Č': 'C', // duplicate
            'Ē': 'E',
            'Ģ': 'G',
            'Ī': 'I',
            'Ķ': 'k',
            'Ļ': 'L',
            'Ņ': 'N',
            // 'Š': 'S', // duplicate
            'Ū': 'U',
            // 'Ž': 'Z', // duplicate

            // Macedonian
            'Ќ': 'Kj',
            'ќ': 'kj',
            'Љ': 'Lj',
            'љ': 'lj',
            'Њ': 'Nj',
            'њ': 'nj',
            'Тс': 'Ts',
            'тс': 'ts',

            // Polish
            'ą': 'a',
            'ć': 'c',
            'ę': 'e',
            'ł': 'l',
            'ń': 'n',
            // 'ó': 'o', // duplicate
            'ś': 's',
            'ź': 'z',
            'ż': 'z',
            'Ą': 'A',
            'Ć': 'C',
            'Ę': 'E',
            'Ł': 'L',
            'Ń': 'N',
            'Ś': 'S',
            'Ź': 'Z',
            'Ż': 'Z',

            // Ukranian
            'Є': 'Ye',
            'І': 'I',
            'Ї': 'Yi',
            'Ґ': 'G',
            'є': 'ye',
            'і': 'i',
            'ї': 'yi',
            'ґ': 'g',

            // Romanian
            'ă': 'a',
            'Ă': 'A',
            'ș': 's',
            'Ș': 'S',
            // 'ş': 's', // duplicate
            // 'Ş': 'S', // duplicate
            'ț': 't',
            'Ț': 'T',
            'ţ': 't',
            'Ţ': 'T',

            // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
            // ICAO

            'а': 'a',
            'б': 'b',
            'в': 'v',
            'г': 'g',
            'д': 'd',
            'е': 'e',
            'ё': 'yo',
            'ж': 'zh',
            'з': 'z',
            'и': 'i',
            'й': 'i',
            'к': 'k',
            'л': 'l',
            'м': 'm',
            'н': 'n',
            'о': 'o',
            'п': 'p',
            'р': 'r',
            'с': 's',
            'т': 't',
            'у': 'u',
            'ф': 'f',
            'х': 'kh',
            'ц': 'c',
            'ч': 'ch',
            'ш': 'sh',
            'щ': 'sh',
            'ъ': '',
            'ы': 'y',
            'ь': '',
            'э': 'e',
            'ю': 'yu',
            'я': 'ya',
            'А': 'A',
            'Б': 'B',
            'В': 'V',
            'Г': 'G',
            'Д': 'D',
            'Е': 'E',
            'Ё': 'Yo',
            'Ж': 'Zh',
            'З': 'Z',
            'И': 'I',
            'Й': 'I',
            'К': 'K',
            'Л': 'L',
            'М': 'M',
            'Н': 'N',
            'О': 'O',
            'П': 'P',
            'Р': 'R',
            'С': 'S',
            'Т': 'T',
            'У': 'U',
            'Ф': 'F',
            'Х': 'Kh',
            'Ц': 'C',
            'Ч': 'Ch',
            'Ш': 'Sh',
            'Щ': 'Sh',
            'Ъ': '',
            'Ы': 'Y',
            'Ь': '',
            'Э': 'E',
            'Ю': 'Yu',
            'Я': 'Ya',

            // Serbian
            'ђ': 'dj',
            'ј': 'j',
            // 'љ': 'lj',  // duplicate
            // 'њ': 'nj', // duplicate
            'ћ': 'c',
            'џ': 'dz',
            'Ђ': 'Dj',
            'Ј': 'j',
            // 'Љ': 'Lj', // duplicate
            // 'Њ': 'Nj', // duplicate
            'Ћ': 'C',
            'Џ': 'Dz',

            // Slovak
            'ľ': 'l',
            'ĺ': 'l',
            'ŕ': 'r',
            'Ľ': 'L',
            'Ĺ': 'L',
            'Ŕ': 'R',

            // Turkish
            'ş': 's',
            'Ş': 'S',
            'ı': 'i',
            'İ': 'I',
            // 'ç': 'c', // duplicate
            // 'Ç': 'C', // duplicate
            // 'ü': 'u', // duplicate, see langCharMap
            // 'Ü': 'U', // duplicate, see langCharMap
            // 'ö': 'o', // duplicate, see langCharMap
            // 'Ö': 'O', // duplicate, see langCharMap
            'ğ': 'g',
            'Ğ': 'G',

            // Vietnamese
            'ả': 'a',
            'Ả': 'A',
            'ẳ': 'a',
            'Ẳ': 'A',
            'ẩ': 'a',
            'Ẩ': 'A',
            'đ': 'd',
            'Đ': 'D',
            'ẹ': 'e',
            'Ẹ': 'E',
            'ẽ': 'e',
            'Ẽ': 'E',
            'ẻ': 'e',
            'Ẻ': 'E',
            'ế': 'e',
            'Ế': 'E',
            'ề': 'e',
            'Ề': 'E',
            'ệ': 'e',
            'Ệ': 'E',
            'ễ': 'e',
            'Ễ': 'E',
            'ể': 'e',
            'Ể': 'E',
            'ỏ': 'o',
            'ọ': 'o',
            'Ọ': 'o',
            'ố': 'o',
            'Ố': 'O',
            'ồ': 'o',
            'Ồ': 'O',
            'ổ': 'o',
            'Ổ': 'O',
            'ộ': 'o',
            'Ộ': 'O',
            'ỗ': 'o',
            'Ỗ': 'O',
            'ơ': 'o',
            'Ơ': 'O',
            'ớ': 'o',
            'Ớ': 'O',
            'ờ': 'o',
            'Ờ': 'O',
            'ợ': 'o',
            'Ợ': 'O',
            'ỡ': 'o',
            'Ỡ': 'O',
            'Ở': 'o',
            'ở': 'o',
            'ị': 'i',
            'Ị': 'I',
            'ĩ': 'i',
            'Ĩ': 'I',
            'ỉ': 'i',
            'Ỉ': 'i',
            'ủ': 'u',
            'Ủ': 'U',
            'ụ': 'u',
            'Ụ': 'U',
            'ũ': 'u',
            'Ũ': 'U',
            'ư': 'u',
            'Ư': 'U',
            'ứ': 'u',
            'Ứ': 'U',
            'ừ': 'u',
            'Ừ': 'U',
            'ự': 'u',
            'Ự': 'U',
            'ữ': 'u',
            'Ữ': 'U',
            'ử': 'u',
            'Ử': 'ư',
            'ỷ': 'y',
            'Ỷ': 'y',
            'ỳ': 'y',
            'Ỳ': 'Y',
            'ỵ': 'y',
            'Ỵ': 'Y',
            'ỹ': 'y',
            'Ỹ': 'Y',
            'ạ': 'a',
            'Ạ': 'A',
            'ấ': 'a',
            'Ấ': 'A',
            'ầ': 'a',
            'Ầ': 'A',
            'ậ': 'a',
            'Ậ': 'A',
            'ẫ': 'a',
            'Ẫ': 'A',
            // 'ă': 'a', // duplicate
            // 'Ă': 'A', // duplicate
            'ắ': 'a',
            'Ắ': 'A',
            'ằ': 'a',
            'Ằ': 'A',
            'ặ': 'a',
            'Ặ': 'A',
            'ẵ': 'a',
            'Ẵ': 'A',
            "⓪": "0",
            "①": "1",
            "②": "2",
            "③": "3",
            "④": "4",
            "⑤": "5",
            "⑥": "6",
            "⑦": "7",
            "⑧": "8",
            "⑨": "9",
            "⑩": "10",
            "⑪": "11",
            "⑫": "12",
            "⑬": "13",
            "⑭": "14",
            "⑮": "15",
            "⑯": "16",
            "⑰": "17",
            "⑱": "18",
            "⑲": "18",
            "⑳": "18",

            "⓵": "1",
            "⓶": "2",
            "⓷": "3",
            "⓸": "4",
            "⓹": "5",
            "⓺": "6",
            "⓻": "7",
            "⓼": "8",
            "⓽": "9",
            "⓾": "10",

            "⓿": "0",
            "⓫": "11",
            "⓬": "12",
            "⓭": "13",
            "⓮": "14",
            "⓯": "15",
            "⓰": "16",
            "⓱": "17",
            "⓲": "18",
            "⓳": "19",
            "⓴": "20",

            "Ⓐ": "A",
            "Ⓑ": "B",
            "Ⓒ": "C",
            "Ⓓ": "D",
            "Ⓔ": "E",
            "Ⓕ": "F",
            "Ⓖ": "G",
            "Ⓗ": "H",
            "Ⓘ": "I",
            "Ⓙ": "J",
            "Ⓚ": "K",
            "Ⓛ": "L",
            "Ⓜ": "M",
            "Ⓝ": "N",
            "Ⓞ": "O",
            "Ⓟ": "P",
            "Ⓠ": "Q",
            "Ⓡ": "R",
            "Ⓢ": "S",
            "Ⓣ": "T",
            "Ⓤ": "U",
            "Ⓥ": "V",
            "Ⓦ": "W",
            "Ⓧ": "X",
            "Ⓨ": "Y",
            "Ⓩ": "Z",

            "ⓐ": "a",
            "ⓑ": "b",
            "ⓒ": "c",
            "ⓓ": "d",
            "ⓔ": "e",
            "ⓕ": "f",
            "ⓖ": "g",
            "ⓗ": "h",
            "ⓘ": "i",
            "ⓙ": "j",
            "ⓚ": "k",
            "ⓛ": "l",
            "ⓜ": "m",
            "ⓝ": "n",
            "ⓞ": "o",
            "ⓟ": "p",
            "ⓠ": "q",
            "ⓡ": "r",
            "ⓢ": "s",
            "ⓣ": "t",
            "ⓤ": "u",
            "ⓦ": "v",
            "ⓥ": "w",
            "ⓧ": "x",
            "ⓨ": "y",
            "ⓩ": "z",

            // symbols
            '“': '"',
            '”': '"',
            '‘': "'",
            '’': "'",
            '∂': 'd',
            'ƒ': 'f',
            '™': '(TM)',
            '©': '(C)',
            'œ': 'oe',
            'Œ': 'OE',
            '®': '(R)',
            '†': '+',
            '℠': '(SM)',
            '…': '...',
            '˚': 'o',
            'º': 'o',
            'ª': 'a',
            '•': '*',
            '၊': ',',
            '။': '.',

            // currency
            '$': 'USD',
            '€': 'EUR',
            '₢': 'BRN',
            '₣': 'FRF',
            '£': 'GBP',
            '₤': 'ITL',
            '₦': 'NGN',
            '₧': 'ESP',
            '₩': 'KRW',
            '₪': 'ILS',
            '₫': 'VND',
            '₭': 'LAK',
            '₮': 'MNT',
            '₯': 'GRD',
            '₱': 'ARS',
            '₲': 'PYG',
            '₳': 'ARA',
            '₴': 'UAH',
            '₵': 'GHS',
            '¢': 'cent',
            '¥': 'CNY',
            '元': 'CNY',
            '円': 'YEN',
            '﷼': 'IRR',
            '₠': 'EWE',
            '฿': 'THB',
            '₨': 'INR',
            '₹': 'INR',
            '₰': 'PF',
            '₺': 'TRY',
            '؋': 'AFN',
            '₼': 'AZN',
            'лв': 'BGN',
            '៛': 'KHR',
            '₡': 'CRC',
            '₸': 'KZT',
            'ден': 'MKD',
            'zł': 'PLN',
            '₽': 'RUB',
            '₾': 'GEL'

        };

        /**
         * special look ahead character array
         * These characters form with consonants to become 'single'/consonant combo
         * @type [Array]
         */
        var lookAheadCharArray = [
            // burmese
            '်',

            // Dhivehi
            'ް'
        ];

        /**
         * diatricMap for languages where transliteration changes entirely as more diatrics are added
         * @type {Object}
         */
        var diatricMap = {
            // Burmese
            // dependent vowels
            'ာ': 'a',
            'ါ': 'a',
            'ေ': 'e',
            'ဲ': 'e',
            'ိ': 'i',
            'ီ': 'i',
            'ို': 'o',
            'ု': 'u',
            'ူ': 'u',
            'ေါင်': 'aung',
            'ော': 'aw',
            'ော်': 'aw',
            'ေါ': 'aw',
            'ေါ်': 'aw',
            '်': '်', // this is special case but the character will be converted to latin in the code
            'က်': 'et',
            'ိုက်': 'aik',
            'ောက်': 'auk',
            'င်': 'in',
            'ိုင်': 'aing',
            'ောင်': 'aung',
            'စ်': 'it',
            'ည်': 'i',
            'တ်': 'at',
            'ိတ်': 'eik',
            'ုတ်': 'ok',
            'ွတ်': 'ut',
            'ေတ်': 'it',
            'ဒ်': 'd',
            'ိုဒ်': 'ok',
            'ုဒ်': 'ait',
            'န်': 'an',
            'ာန်': 'an',
            'ိန်': 'ein',
            'ုန်': 'on',
            'ွန်': 'un',
            'ပ်': 'at',
            'ိပ်': 'eik',
            'ုပ်': 'ok',
            'ွပ်': 'ut',
            'န်ုပ်': 'nub',
            'မ်': 'an',
            'ိမ်': 'ein',
            'ုမ်': 'on',
            'ွမ်': 'un',
            'ယ်': 'e',
            'ိုလ်': 'ol',
            'ဉ်': 'in',
            'ံ': 'an',
            'ိံ': 'ein',
            'ုံ': 'on',

            // Dhivehi
            'ައް': 'ah',
            'ަށް': 'ah'
        };

        /**
         * langCharMap language specific characters translations
         * @type   {Object}
         */
        var langCharMap = {
            'en': {}, // default language

            'az': { // Azerbaijani
                'ç': 'c',
                'ə': 'e',
                'ğ': 'g',
                'ı': 'i',
                'ö': 'o',
                'ş': 's',
                'ü': 'u',
                'Ç': 'C',
                'Ə': 'E',
                'Ğ': 'G',
                'İ': 'I',
                'Ö': 'O',
                'Ş': 'S',
                'Ü': 'U'
            },

            'cs': { // Czech
                'č': 'c',
                'ď': 'd',
                'ě': 'e',
                'ň': 'n',
                'ř': 'r',
                'š': 's',
                'ť': 't',
                'ů': 'u',
                'ž': 'z',
                'Č': 'C',
                'Ď': 'D',
                'Ě': 'E',
                'Ň': 'N',
                'Ř': 'R',
                'Š': 'S',
                'Ť': 'T',
                'Ů': 'U',
                'Ž': 'Z'
            },

            'fi': { // Finnish
                // 'å': 'a', duplicate see charMap/latin
                // 'Å': 'A', duplicate see charMap/latin
                'ä': 'a', // ok
                'Ä': 'A', // ok
                'ö': 'o', // ok
                'Ö': 'O' // ok
            },

            'hu': { // Hungarian
                'ä': 'a', // ok
                'Ä': 'A', // ok
                // 'á': 'a', duplicate see charMap/latin
                // 'Á': 'A', duplicate see charMap/latin
                'ö': 'o', // ok
                'Ö': 'O', // ok
                // 'ő': 'o', duplicate see charMap/latin
                // 'Ő': 'O', duplicate see charMap/latin
                'ü': 'u',
                'Ü': 'U',
                'ű': 'u',
                'Ű': 'U'
            },

            'lt': { // Lithuanian
                'ą': 'a',
                'č': 'c',
                'ę': 'e',
                'ė': 'e',
                'į': 'i',
                'š': 's',
                'ų': 'u',
                'ū': 'u',
                'ž': 'z',
                'Ą': 'A',
                'Č': 'C',
                'Ę': 'E',
                'Ė': 'E',
                'Į': 'I',
                'Š': 'S',
                'Ų': 'U',
                'Ū': 'U'
            },

            'lv': { // Latvian
                'ā': 'a',
                'č': 'c',
                'ē': 'e',
                'ģ': 'g',
                'ī': 'i',
                'ķ': 'k',
                'ļ': 'l',
                'ņ': 'n',
                'š': 's',
                'ū': 'u',
                'ž': 'z',
                'Ā': 'A',
                'Č': 'C',
                'Ē': 'E',
                'Ģ': 'G',
                'Ī': 'i',
                'Ķ': 'k',
                'Ļ': 'L',
                'Ņ': 'N',
                'Š': 'S',
                'Ū': 'u',
                'Ž': 'Z'
            },

            'pl': { // Polish
                'ą': 'a',
                'ć': 'c',
                'ę': 'e',
                'ł': 'l',
                'ń': 'n',
                'ó': 'o',
                'ś': 's',
                'ź': 'z',
                'ż': 'z',
                'Ą': 'A',
                'Ć': 'C',
                'Ę': 'e',
                'Ł': 'L',
                'Ń': 'N',
                'Ó': 'O',
                'Ś': 'S',
                'Ź': 'Z',
                'Ż': 'Z'
            },

            'sv': { // Swedish
                // 'å': 'a', duplicate see charMap/latin
                // 'Å': 'A', duplicate see charMap/latin
                'ä': 'a', // ok
                'Ä': 'A', // ok
                'ö': 'o', // ok
                'Ö': 'O' // ok
            },

            'sk': { // Slovak
                'ä': 'a',
                'Ä': 'A'
            },

            'sr': { // Serbian
                'љ': 'lj',
                'њ': 'nj',
                'Љ': 'Lj',
                'Њ': 'Nj',
                'đ': 'dj',
                'Đ': 'Dj'
            },

            'tr': { // Turkish
                'Ü': 'U',
                'Ö': 'O',
                'ü': 'u',
                'ö': 'o'
            }
        };

        /**
         * symbolMap language specific symbol translations
         * translations must be transliterated already
         * @type   {Object}
         */
        var symbolMap = {
            'ar': {
                '∆': 'delta',
                '∞': 'la-nihaya',
                '♥': 'hob',
                '&': 'wa',
                '|': 'aw',
                '<': 'aqal-men',
                '>': 'akbar-men',
                '∑': 'majmou',
                '¤': 'omla'
            },

            'az': {},

            'ca': {
                '∆': 'delta',
                '∞': 'infinit',
                '♥': 'amor',
                '&': 'i',
                '|': 'o',
                '<': 'menys que',
                '>': 'mes que',
                '∑': 'suma dels',
                '¤': 'moneda'
            },

            'cs': {
                '∆': 'delta',
                '∞': 'nekonecno',
                '♥': 'laska',
                '&': 'a',
                '|': 'nebo',
                '<': 'mensi nez',
                '>': 'vetsi nez',
                '∑': 'soucet',
                '¤': 'mena'
            },

            'de': {
                '∆': 'delta',
                '∞': 'unendlich',
                '♥': 'Liebe',
                '&': 'und',
                '|': 'oder',
                '<': 'kleiner als',
                '>': 'groesser als',
                '∑': 'Summe von',
                '¤': 'Waehrung'
            },

            'dv': {
                '∆': 'delta',
                '∞': 'kolunulaa',
                '♥': 'loabi',
                '&': 'aai',
                '|': 'noonee',
                '<': 'ah vure kuda',
                '>': 'ah vure bodu',
                '∑': 'jumula',
                '¤': 'faisaa'
            },

            'en': {
                '∆': 'delta',
                '∞': 'infinity',
                '♥': 'love',
                '&': 'and',
                '|': 'or',
                '<': 'less than',
                '>': 'greater than',
                '∑': 'sum',
                '¤': 'currency'
            },

            'es': {
                '∆': 'delta',
                '∞': 'infinito',
                '♥': 'amor',
                '&': 'y',
                '|': 'u',
                '<': 'menos que',
                '>': 'mas que',
                '∑': 'suma de los',
                '¤': 'moneda'
            },

            'fa': {
                '∆': 'delta',
                '∞': 'bi-nahayat',
                '♥': 'eshgh',
                '&': 'va',
                '|': 'ya',
                '<': 'kamtar-az',
                '>': 'bishtar-az',
                '∑': 'majmooe',
                '¤': 'vahed'
            },

            'fi': {
                '∆': 'delta',
                '∞': 'aarettomyys',
                '♥': 'rakkaus',
                '&': 'ja',
                '|': 'tai',
                '<': 'pienempi kuin',
                '>': 'suurempi kuin',
                '∑': 'summa',
                '¤': 'valuutta'
            },

            'fr': {
                '∆': 'delta',
                '∞': 'infiniment',
                '♥': 'Amour',
                '&': 'et',
                '|': 'ou',
                '<': 'moins que',
                '>': 'superieure a',
                '∑': 'somme des',
                '¤': 'monnaie'
            },

            'ge': {
                '∆': 'delta',
                '∞': 'usasruloba',
                '♥': 'siqvaruli',
                '&': 'da',
                '|': 'an',
                '<': 'naklebi',
                '>': 'meti',
                '∑': 'jami',
                '¤': 'valuta'
            },

            'gr': {},

            'hu': {
                '∆': 'delta',
                '∞': 'vegtelen',
                '♥': 'szerelem',
                '&': 'es',
                '|': 'vagy',
                '<': 'kisebb mint',
                '>': 'nagyobb mint',
                '∑': 'szumma',
                '¤': 'penznem'
            },

            'it': {
                '∆': 'delta',
                '∞': 'infinito',
                '♥': 'amore',
                '&': 'e',
                '|': 'o',
                '<': 'minore di',
                '>': 'maggiore di',
                '∑': 'somma',
                '¤': 'moneta'
            },

            'lt': {
                '∆': 'delta',
                '∞': 'begalybe',
                '♥': 'meile',
                '&': 'ir',
                '|': 'ar',
                '<': 'maziau nei',
                '>': 'daugiau nei',
                '∑': 'suma',
                '¤': 'valiuta'
            },

            'lv': {
                '∆': 'delta',
                '∞': 'bezgaliba',
                '♥': 'milestiba',
                '&': 'un',
                '|': 'vai',
                '<': 'mazak neka',
                '>': 'lielaks neka',
                '∑': 'summa',
                '¤': 'valuta'
            },

            'my': {
                '∆': 'kwahkhyaet',
                '∞': 'asaonasme',
                '♥': 'akhyait',
                '&': 'nhin',
                '|': 'tho',
                '<': 'ngethaw',
                '>': 'kyithaw',
                '∑': 'paungld',
                '¤': 'ngwekye'
            },

            'mk': {},

            'nl': {
                '∆': 'delta',
                '∞': 'oneindig',
                '♥': 'liefde',
                '&': 'en',
                '|': 'of',
                '<': 'kleiner dan',
                '>': 'groter dan',
                '∑': 'som',
                '¤': 'valuta'
            },

            'pl': {
                '∆': 'delta',
                '∞': 'nieskonczonosc',
                '♥': 'milosc',
                '&': 'i',
                '|': 'lub',
                '<': 'mniejsze niz',
                '>': 'wieksze niz',
                '∑': 'suma',
                '¤': 'waluta'
            },

            'pt': {
                '∆': 'delta',
                '∞': 'infinito',
                '♥': 'amor',
                '&': 'e',
                '|': 'ou',
                '<': 'menor que',
                '>': 'maior que',
                '∑': 'soma',
                '¤': 'moeda'
            },

            'ro': {
                '∆': 'delta',
                '∞': 'infinit',
                '♥': 'dragoste',
                '&': 'si',
                '|': 'sau',
                '<': 'mai mic ca',
                '>': 'mai mare ca',
                '∑': 'suma',
                '¤': 'valuta'
            },

            'ru': {
                '∆': 'delta',
                '∞': 'beskonechno',
                '♥': 'lubov',
                '&': 'i',
                '|': 'ili',
                '<': 'menshe',
                '>': 'bolshe',
                '∑': 'summa',
                '¤': 'valjuta'
            },

            'sk': {
                '∆': 'delta',
                '∞': 'nekonecno',
                '♥': 'laska',
                '&': 'a',
                '|': 'alebo',
                '<': 'menej ako',
                '>': 'viac ako',
                '∑': 'sucet',
                '¤': 'mena'
            },

            'sr': {},

            'tr': {
                '∆': 'delta',
                '∞': 'sonsuzluk',
                '♥': 'ask',
                '&': 've',
                '|': 'veya',
                '<': 'kucuktur',
                '>': 'buyuktur',
                '∑': 'toplam',
                '¤': 'para birimi'
            },

            'uk': {
                '∆': 'delta',
                '∞': 'bezkinechnist',
                '♥': 'lubov',
                '&': 'i',
                '|': 'abo',
                '<': 'menshe',
                '>': 'bilshe',
                '∑': 'suma',
                '¤': 'valjuta'
            },

            'vn': {
                '∆': 'delta',
                '∞': 'vo cuc',
                '♥': 'yeu',
                '&': 'va',
                '|': 'hoac',
                '<': 'nho hon',
                '>': 'lon hon',
                '∑': 'tong',
                '¤': 'tien te'
            }
        };

        var uricChars = [';', '?', ':', '@', '&', '=', '+', '$', ',', '/'].join('');

        var uricNoSlashChars = [';', '?', ':', '@', '&', '=', '+', '$', ','].join('');

        var markChars = ['.', '!', '~', '*', "'", '(', ')'].join('');

        /**
         * getSlug
         * @param  {string} input input string
         * @param  {object|string} opts config object or separator string/char
         * @api    public
         * @return {string}  sluggified string
         */
        var getSlug = function getSlug(input, opts) {
            var separator = '-';
            var result = '';
            var diatricString = '';
            var convertSymbols = true;
            var customReplacements = {};
            var maintainCase;
            var titleCase;
            var truncate;
            var uricFlag;
            var uricNoSlashFlag;
            var markFlag;
            var symbol;
            var langChar;
            var lucky;
            var i;
            var ch;
            var l;
            var lastCharWasSymbol;
            var lastCharWasDiatric;
            var allowedChars = '';

            if (typeof input !== 'string') {
                return '';
            }

            if (typeof opts === 'string') {
                separator = opts;
            }

            symbol = symbolMap.en;
            langChar = langCharMap.en;

            if (typeof opts === 'object') {
                maintainCase = opts.maintainCase || false;
                customReplacements = (opts.custom && typeof opts.custom === 'object') ? opts.custom : customReplacements;
                truncate = (+opts.truncate > 1 && opts.truncate) || false;
                uricFlag = opts.uric || false;
                uricNoSlashFlag = opts.uricNoSlash || false;
                markFlag = opts.mark || false;
                convertSymbols = (opts.symbols === false || opts.lang === false) ? false : true;
                separator = opts.separator || separator;

                if (uricFlag) {
                    allowedChars += uricChars;
                }

                if (uricNoSlashFlag) {
                    allowedChars += uricNoSlashChars;
                }

                if (markFlag) {
                    allowedChars += markChars;
                }

                symbol = (opts.lang && symbolMap[opts.lang] && convertSymbols) ?
                    symbolMap[opts.lang] : (convertSymbols ? symbolMap.en : {});

                langChar = (opts.lang && langCharMap[opts.lang]) ?
                    langCharMap[opts.lang] :
                    opts.lang === false || opts.lang === true ? {} : langCharMap.en;

                // if titleCase config is an Array, rewrite to object format
                if (opts.titleCase && typeof opts.titleCase.length === 'number' && Array.prototype.toString.call(opts.titleCase)) {
                    opts.titleCase.forEach(function (v) {
                        customReplacements[v + ''] = v + '';
                    });

                    titleCase = true;
                } else {
                    titleCase = !!opts.titleCase;
                }

                // if custom config is an Array, rewrite to object format
                if (opts.custom && typeof opts.custom.length === 'number' && Array.prototype.toString.call(opts.custom)) {
                    opts.custom.forEach(function (v) {
                        customReplacements[v + ''] = v + '';
                    });
                }

                // custom replacements
                Object.keys(customReplacements).forEach(function (v) {
                    var r;

                    if (v.length > 1) {
                        r = new RegExp('\\b' + escapeChars(v) + '\\b', 'gi');
                    } else {
                        r = new RegExp(escapeChars(v), 'gi');
                    }

                    input = input.replace(r, customReplacements[v]);
                });

                // add all custom replacement to allowed charlist
                for (ch in customReplacements) {
                    allowedChars += ch;
                }
            }

            allowedChars += separator;

            // escape all necessary chars
            allowedChars = escapeChars(allowedChars);

            // trim whitespaces
            input = input.replace(/(^\s+|\s+$)/g, '');

            lastCharWasSymbol = false;
            lastCharWasDiatric = false;

            for (i = 0, l = input.length; i < l; i++) {
                ch = input[i];

                if (isReplacedCustomChar(ch, customReplacements)) {
                    // don't convert a already converted char
                    lastCharWasSymbol = false;
                } else if (langChar[ch]) {
                    // process language specific diactrics chars conversion
                    ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? ' ' + langChar[ch] : langChar[ch];

                    lastCharWasSymbol = false;
                } else if (ch in charMap) {
                    // the transliteration changes entirely when some special characters are added
                    if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
                        diatricString += ch;
                        ch = '';
                    } else if (lastCharWasDiatric === true) {
                        ch = diatricMap[diatricString] + charMap[ch];
                        diatricString = '';
                    } else {
                        // process diactrics chars
                        ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? ' ' + charMap[ch] : charMap[ch];
                    }

                    lastCharWasSymbol = false;
                    lastCharWasDiatric = false;
                } else if (ch in diatricMap) {
                    diatricString += ch;
                    ch = '';
                    // end of string, put the whole meaningful word
                    if (i === l - 1) {
                        ch = diatricMap[diatricString];
                    }
                    lastCharWasDiatric = true;
                } else if (
                    // process symbol chars
                    symbol[ch] && !(uricFlag && uricChars
                        .indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars
                        // .indexOf(ch) !== -1) && !(markFlag && markChars
                        .indexOf(ch) !== -1)) {
                    ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
                    ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : '';

                    lastCharWasSymbol = true;
                } else {
                    if (lastCharWasDiatric === true) {
                        ch = diatricMap[diatricString] + ch;
                        diatricString = '';
                        lastCharWasDiatric = false;
                    } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
                        // process latin chars
                        ch = ' ' + ch;
                    }
                    lastCharWasSymbol = false;
                }

                // add allowed chars
                result += ch.replace(new RegExp('[^\\w\\s' + allowedChars + '_-]', 'g'), separator);
            }

            if (titleCase) {
                result = result.replace(/(\w)(\S*)/g, function (_, i, r) {
                    var j = i.toUpperCase() + (r !== null ? r : '');
                    return (Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0) ? j : j.toLowerCase();
                });
            }

            // eliminate duplicate separators
            // add separator
            // trim separators from start and end
            result = result.replace(/\s+/g, separator)
                .replace(new RegExp('\\' + separator + '+', 'g'), separator)
                .replace(new RegExp('(^\\' + separator + '+|\\' + separator + '+$)', 'g'), '');

            if (truncate && result.length > truncate) {
                lucky = result.charAt(truncate) === separator;
                result = result.slice(0, truncate);

                if (!lucky) {
                    result = result.slice(0, result.lastIndexOf(separator));
                }
            }

            if (!maintainCase && !titleCase) {
                result = result.toLowerCase();
            }

            return result;
        };

        /**
         * createSlug curried(opts)(input)
         * @param   {object|string} opts config object or input string
         * @return  {Function} function getSlugWithConfig()
         **/
        var createSlug = function createSlug(opts) {

            /**
             * getSlugWithConfig
             * @param   {string} input string
             * @return  {string} slug string
             */
            return function getSlugWithConfig(input) {
                return getSlug(input, opts);
            };
        };

        /**
         * escape Chars
         * @param   {string} input string
         */
        var escapeChars = function escapeChars(input) {
            return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, '\\$&');
        };

        /**
         * check if the char is an already converted char from custom list
         * @param   {char} ch character to check
         * @param   {object} customReplacements custom translation map
         */
        var isReplacedCustomChar = function (ch, customReplacements) {
            for (var c in customReplacements) {
                if (customReplacements[c] === ch) {
                    return true;
                }
            }
        };

        if ('object' !== 'undefined' && module.exports) {

            // export functions for use in Node
            module.exports = getSlug;
            module.exports.createSlug = createSlug;
        } else if (typeof undefined !== 'undefined' && undefined.amd) {

            // export function for use in AMD
            undefined([], function () {
                return getSlug;
            });
        } else {

            // don't overwrite global if exists
            try {
                if (root.getSlug || root.createSlug) {
                    throw 'speakingurl: globals exists /(getSlug|createSlug)/';
                } else {
                    root.getSlug = getSlug;
                    root.createSlug = createSlug;
                }
            } catch (e) {}
        }
    })(commonjsGlobal);
    });
    var speakingurl_1 = speakingurl.createSlug;

    var speakingurl$1 = speakingurl;

    var urlJoin = createCommonjsModule(function (module) {
    (function (name, context, definition) {
      if ('object' !== 'undefined' && module.exports) module.exports = definition();
      else if (typeof undefined === 'function' && undefined.amd) undefined(definition);
      else context[name] = definition();
    })('urljoin', commonjsGlobal, function () {

      function normalize (strArray) {
        var resultArray = [];
        if (strArray.length === 0) { return ''; }

        if (typeof strArray[0] !== 'string') {
          throw new TypeError('Url must be a string. Received ' + strArray[0]);
        }

        // If the first part is a plain protocol, we combine it with the next part.
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first = strArray.shift();
          strArray[0] = first + strArray[0];
        }

        // There must be two or three slashes in the file protocol, two slashes in anything else.
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
        }

        for (var i = 0; i < strArray.length; i++) {
          var component = strArray[i];

          if (typeof component !== 'string') {
            throw new TypeError('Url must be a string. Received ' + component);
          }

          if (component === '') { continue; }

          if (i > 0) {
            // Removing the starting slashes for each component but the first.
            component = component.replace(/^[\/]+/, '');
          }
          if (i < strArray.length - 1) {
            // Removing the ending slashes for each component but the last.
            component = component.replace(/[\/]+$/, '');
          } else {
            // For the last component we will combine multiple slashes to a single one.
            component = component.replace(/[\/]+$/, '/');
          }

          resultArray.push(component);

        }

        var str = resultArray.join('/');
        // Each input component is now separated by a single slash except the possible first plain protocol part.

        // remove trailing slash before parameters or hash
        str = str.replace(/\/(\?|&|#[^!])/g, '$1');

        // replace ? in parameters with &
        var parts = str.split('?');
        str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');

        return str;
      }

      return function () {
        var input;

        if (typeof arguments[0] === 'object') {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }

        return normalize(input);
      };

    });
    });

    var uritemplate = createCommonjsModule(function (module) {
    /*global unescape, module, define, window, global*/

    /*
     UriTemplate Copyright (c) 2012-2013 Franz Antesberger. All Rights Reserved.
     Available via the MIT license.
    */

    (function (exportCallback) {
        "use strict";

    var UriTemplateError = (function () {

        function UriTemplateError (options) {
            this.options = options;
        }

        UriTemplateError.prototype.toString = function () {
            if (JSON && JSON.stringify) {
                return JSON.stringify(this.options);
            }
            else {
                return this.options;
            }
        };

        return UriTemplateError;
    }());

    var objectHelper = (function () {
        function isArray (value) {
            return Object.prototype.toString.apply(value) === '[object Array]';
        }

        function isString (value) {
            return Object.prototype.toString.apply(value) === '[object String]';
        }
        
        function isNumber (value) {
            return Object.prototype.toString.apply(value) === '[object Number]';
        }
        
        function isBoolean (value) {
            return Object.prototype.toString.apply(value) === '[object Boolean]';
        }
        
        function join (arr, separator) {
            var
                result = '',
                first = true,
                index;
            for (index = 0; index < arr.length; index += 1) {
                if (first) {
                    first = false;
                }
                else {
                    result += separator;
                }
                result += arr[index];
            }
            return result;
        }

        function map (arr, mapper) {
            var
                result = [],
                index = 0;
            for (; index < arr.length; index += 1) {
                result.push(mapper(arr[index]));
            }
            return result;
        }

        function filter (arr, predicate) {
            var
                result = [],
                index = 0;
            for (; index < arr.length; index += 1) {
                if (predicate(arr[index])) {
                    result.push(arr[index]);
                }
            }
            return result;
        }

        function deepFreezeUsingObjectFreeze (object) {
            if (typeof object !== "object" || object === null) {
                return object;
            }
            Object.freeze(object);
            var property, propertyName;
            for (propertyName in object) {
                if (object.hasOwnProperty(propertyName)) {
                    property = object[propertyName];
                    // be aware, arrays are 'object', too
                    if (typeof property === "object") {
                        deepFreeze(property);
                    }
                }
            }
            return object;
        }

        function deepFreeze (object) {
            if (typeof Object.freeze === 'function') {
                return deepFreezeUsingObjectFreeze(object);
            }
            return object;
        }


        return {
            isArray: isArray,
            isString: isString,
            isNumber: isNumber,
            isBoolean: isBoolean,
            join: join,
            map: map,
            filter: filter,
            deepFreeze: deepFreeze
        };
    }());

    var charHelper = (function () {

        function isAlpha (chr) {
            return (chr >= 'a' && chr <= 'z') || ((chr >= 'A' && chr <= 'Z'));
        }

        function isDigit (chr) {
            return chr >= '0' && chr <= '9';
        }

        function isHexDigit (chr) {
            return isDigit(chr) || (chr >= 'a' && chr <= 'f') || (chr >= 'A' && chr <= 'F');
        }

        return {
            isAlpha: isAlpha,
            isDigit: isDigit,
            isHexDigit: isHexDigit
        };
    }());

    var pctEncoder = (function () {
        var utf8 = {
            encode: function (chr) {
                // see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html
                return unescape(encodeURIComponent(chr));
            },
            numBytes: function (firstCharCode) {
                if (firstCharCode <= 0x7F) {
                    return 1;
                }
                else if (0xC2 <= firstCharCode && firstCharCode <= 0xDF) {
                    return 2;
                }
                else if (0xE0 <= firstCharCode && firstCharCode <= 0xEF) {
                    return 3;
                }
                else if (0xF0 <= firstCharCode && firstCharCode <= 0xF4) {
                    return 4;
                }
                // no valid first octet
                return 0;
            },
            isValidFollowingCharCode: function (charCode) {
                return 0x80 <= charCode && charCode <= 0xBF;
            }
        };

        /**
         * encodes a character, if needed or not.
         * @param chr
         * @return pct-encoded character
         */
        function encodeCharacter (chr) {
            var
                result = '',
                octets = utf8.encode(chr),
                octet,
                index;
            for (index = 0; index < octets.length; index += 1) {
                octet = octets.charCodeAt(index);
                result += '%' + (octet < 0x10 ? '0' : '') + octet.toString(16).toUpperCase();
            }
            return result;
        }

        /**
         * Returns, whether the given text at start is in the form 'percent hex-digit hex-digit', like '%3F'
         * @param text
         * @param start
         * @return {boolean|*|*}
         */
        function isPercentDigitDigit (text, start) {
            return text.charAt(start) === '%' && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));
        }

        /**
         * Parses a hex number from start with length 2.
         * @param text a string
         * @param start the start index of the 2-digit hex number
         * @return {Number}
         */
        function parseHex2 (text, start) {
            return parseInt(text.substr(start, 2), 16);
        }

        /**
         * Returns whether or not the given char sequence is a correctly pct-encoded sequence.
         * @param chr
         * @return {boolean}
         */
        function isPctEncoded (chr) {
            if (!isPercentDigitDigit(chr, 0)) {
                return false;
            }
            var firstCharCode = parseHex2(chr, 1);
            var numBytes = utf8.numBytes(firstCharCode);
            if (numBytes === 0) {
                return false;
            }
            for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
                if (!isPercentDigitDigit(chr, 3*byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3*byteNumber + 1))) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Reads as much as needed from the text, e.g. '%20' or '%C3%B6'. It does not decode!
         * @param text
         * @param startIndex
         * @return the character or pct-string of the text at startIndex
         */
        function pctCharAt(text, startIndex) {
            var chr = text.charAt(startIndex);
            if (!isPercentDigitDigit(text, startIndex)) {
                return chr;
            }
            var utf8CharCode = parseHex2(text, startIndex + 1);
            var numBytes = utf8.numBytes(utf8CharCode);
            if (numBytes === 0) {
                return chr;
            }
            for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
                if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {
                    return chr;
                }
            }
            return text.substr(startIndex, 3 * numBytes);
        }

        return {
            encodeCharacter: encodeCharacter,
            isPctEncoded: isPctEncoded,
            pctCharAt: pctCharAt
        };
    }());

    var rfcCharHelper = (function () {

        /**
         * Returns if an character is an varchar character according 2.3 of rfc 6570
         * @param chr
         * @return (Boolean)
         */
        function isVarchar (chr) {
            return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '_' || pctEncoder.isPctEncoded(chr);
        }

        /**
         * Returns if chr is an unreserved character according 1.5 of rfc 6570
         * @param chr
         * @return {Boolean}
         */
        function isUnreserved (chr) {
            return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '-' || chr === '.' || chr === '_' || chr === '~';
        }

        /**
         * Returns if chr is an reserved character according 1.5 of rfc 6570
         * or the percent character mentioned in 3.2.1.
         * @param chr
         * @return {Boolean}
         */
        function isReserved (chr) {
            return chr === ':' || chr === '/' || chr === '?' || chr === '#' || chr === '[' || chr === ']' || chr === '@' || chr === '!' || chr === '$' || chr === '&' || chr === '(' ||
                chr === ')' || chr === '*' || chr === '+' || chr === ',' || chr === ';' || chr === '=' || chr === "'";
        }

        return {
            isVarchar: isVarchar,
            isUnreserved: isUnreserved,
            isReserved: isReserved
        };

    }());

    /**
     * encoding of rfc 6570
     */
    var encodingHelper = (function () {

        function encode (text, passReserved) {
            var
                result = '',
                index,
                chr = '';
            if (typeof text === "number" || typeof text === "boolean") {
                text = text.toString();
            }
            for (index = 0; index < text.length; index += chr.length) {
                chr = text.charAt(index);
                result += rfcCharHelper.isUnreserved(chr) || (passReserved && rfcCharHelper.isReserved(chr)) ? chr : pctEncoder.encodeCharacter(chr);
            }
            return result;
        }

        function encodePassReserved (text) {
            return encode(text, true);
        }

        function encodeLiteralCharacter (literal, index) {
            var chr = pctEncoder.pctCharAt(literal, index);
            if (chr.length > 1) {
                return chr;
            }
            else {
                return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
            }
        }

        function encodeLiteral (literal) {
            var
                result = '',
                index,
                chr = '';
            for (index = 0; index < literal.length; index += chr.length) {
                chr = pctEncoder.pctCharAt(literal, index);
                if (chr.length > 1) {
                    result += chr;
                }
                else {
                    result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
                }
            }
            return result;
        }

        return {
            encode: encode,
            encodePassReserved: encodePassReserved,
            encodeLiteral: encodeLiteral,
            encodeLiteralCharacter: encodeLiteralCharacter
        };

    }());


    // the operators defined by rfc 6570
    var operators = (function () {

        var
            bySymbol = {};

        function create (symbol) {
            bySymbol[symbol] = {
                symbol: symbol,
                separator: (symbol === '?') ? '&' : (symbol === '' || symbol === '+' || symbol === '#') ? ',' : symbol,
                named: symbol === ';' || symbol === '&' || symbol === '?',
                ifEmpty: (symbol === '&' || symbol === '?') ? '=' : '',
                first: (symbol === '+' ) ? '' : symbol,
                encode: (symbol === '+' || symbol === '#') ? encodingHelper.encodePassReserved : encodingHelper.encode,
                toString: function () {
                    return this.symbol;
                }
            };
        }

        create('');
        create('+');
        create('#');
        create('.');
        create('/');
        create(';');
        create('?');
        create('&');
        return {
            valueOf: function (chr) {
                if (bySymbol[chr]) {
                    return bySymbol[chr];
                }
                if ("=,!@|".indexOf(chr) >= 0) {
                    return null;
                }
                return bySymbol[''];
            }
        };
    }());


    /**
     * Detects, whether a given element is defined in the sense of rfc 6570
     * Section 2.3 of the RFC makes clear defintions:
     * * undefined and null are not defined.
     * * the empty string is defined
     * * an array ("list") is defined, if it is not empty (even if all elements are not defined)
     * * an object ("map") is defined, if it contains at least one property with defined value
     * @param object
     * @return {Boolean}
     */
    function isDefined (object) {
        var
            propertyName;
        if (object === null || object === undefined) {
            return false;
        }
        if (objectHelper.isArray(object)) {
            // Section 2.3: A variable defined as a list value is considered undefined if the list contains zero members
            return object.length > 0;
        }
        if (typeof object === "string" || typeof object === "number" || typeof object === "boolean") {
            // falsy values like empty strings, false or 0 are "defined"
            return true;
        }
        // else Object
        for (propertyName in object) {
            if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {
                return true;
            }
        }
        return false;
    }

    var LiteralExpression = (function () {
        function LiteralExpression (literal) {
            this.literal = encodingHelper.encodeLiteral(literal);
        }

        LiteralExpression.prototype.expand = function () {
            return this.literal;
        };

        LiteralExpression.prototype.toString = LiteralExpression.prototype.expand;

        return LiteralExpression;
    }());

    var parse = (function () {

        function parseExpression (expressionText) {
            var
                operator,
                varspecs = [],
                varspec = null,
                varnameStart = null,
                maxLengthStart = null,
                index,
                chr = '';

            function closeVarname () {
                var varname = expressionText.substring(varnameStart, index);
                if (varname.length === 0) {
                    throw new UriTemplateError({expressionText: expressionText, message: "a varname must be specified", position: index});
                }
                varspec = {varname: varname, exploded: false, maxLength: null};
                varnameStart = null;
            }

            function closeMaxLength () {
                if (maxLengthStart === index) {
                    throw new UriTemplateError({expressionText: expressionText, message: "after a ':' you have to specify the length", position: index});
                }
                varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);
                maxLengthStart = null;
            }

            operator = (function (operatorText) {
                var op = operators.valueOf(operatorText);
                if (op === null) {
                    throw new UriTemplateError({expressionText: expressionText, message: "illegal use of reserved operator", position: index, operator: operatorText});
                }
                return op;
            }(expressionText.charAt(0)));
            index = operator.symbol.length;

            varnameStart = index;

            for (; index < expressionText.length; index += chr.length) {
                chr = pctEncoder.pctCharAt(expressionText, index);

                if (varnameStart !== null) {
                    // the spec says: varname =  varchar *( ["."] varchar )
                    // so a dot is allowed except for the first char
                    if (chr === '.') {
                        if (varnameStart === index) {
                            throw new UriTemplateError({expressionText: expressionText, message: "a varname MUST NOT start with a dot", position: index});
                        }
                        continue;
                    }
                    if (rfcCharHelper.isVarchar(chr)) {
                        continue;
                    }
                    closeVarname();
                }
                if (maxLengthStart !== null) {
                    if (index === maxLengthStart && chr === '0') {
                        throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must not start with digit 0", position: index});
                    }
                    if (charHelper.isDigit(chr)) {
                        if (index - maxLengthStart >= 4) {
                            throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must have max 4 digits", position: index});
                        }
                        continue;
                    }
                    closeMaxLength();
                }
                if (chr === ':') {
                    if (varspec.maxLength !== null) {
                        throw new UriTemplateError({expressionText: expressionText, message: "only one :maxLength is allowed per varspec", position: index});
                    }
                    if (varspec.exploded) {
                        throw new UriTemplateError({expressionText: expressionText, message: "an exploeded varspec MUST NOT be varspeced", position: index});
                    }
                    maxLengthStart = index + 1;
                    continue;
                }
                if (chr === '*') {
                    if (varspec === null) {
                        throw new UriTemplateError({expressionText: expressionText, message: "exploded without varspec", position: index});
                    }
                    if (varspec.exploded) {
                        throw new UriTemplateError({expressionText: expressionText, message: "exploded twice", position: index});
                    }
                    if (varspec.maxLength) {
                        throw new UriTemplateError({expressionText: expressionText, message: "an explode (*) MUST NOT follow to a prefix", position: index});
                    }
                    varspec.exploded = true;
                    continue;
                }
                // the only legal character now is the comma
                if (chr === ',') {
                    varspecs.push(varspec);
                    varspec = null;
                    varnameStart = index + 1;
                    continue;
                }
                throw new UriTemplateError({expressionText: expressionText, message: "illegal character", character: chr, position: index});
            } // for chr
            if (varnameStart !== null) {
                closeVarname();
            }
            if (maxLengthStart !== null) {
                closeMaxLength();
            }
            varspecs.push(varspec);
            return new VariableExpression(expressionText, operator, varspecs);
        }

        function parse (uriTemplateText) {
            // assert filled string
            var
                index,
                chr,
                expressions = [],
                braceOpenIndex = null,
                literalStart = 0;
            for (index = 0; index < uriTemplateText.length; index += 1) {
                chr = uriTemplateText.charAt(index);
                if (literalStart !== null) {
                    if (chr === '}') {
                        throw new UriTemplateError({templateText: uriTemplateText, message: "unopened brace closed", position: index});
                    }
                    if (chr === '{') {
                        if (literalStart < index) {
                            expressions.push(new LiteralExpression(uriTemplateText.substring(literalStart, index)));
                        }
                        literalStart = null;
                        braceOpenIndex = index;
                    }
                    continue;
                }

                if (braceOpenIndex !== null) {
                    // here just { is forbidden
                    if (chr === '{') {
                        throw new UriTemplateError({templateText: uriTemplateText, message: "brace already opened", position: index});
                    }
                    if (chr === '}') {
                        if (braceOpenIndex + 1 === index) {
                            throw new UriTemplateError({templateText: uriTemplateText, message: "empty braces", position: braceOpenIndex});
                        }
                        try {
                            expressions.push(parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index)));
                        }
                        catch (error) {
                            if (error.prototype === UriTemplateError.prototype) {
                                throw new UriTemplateError({templateText: uriTemplateText, message: error.options.message, position: braceOpenIndex + error.options.position, details: error.options});
                            }
                            throw error;
                        }
                        braceOpenIndex = null;
                        literalStart = index + 1;
                    }
                    continue;
                }
                throw new Error('reached unreachable code');
            }
            if (braceOpenIndex !== null) {
                throw new UriTemplateError({templateText: uriTemplateText, message: "unclosed brace", position: braceOpenIndex});
            }
            if (literalStart < uriTemplateText.length) {
                expressions.push(new LiteralExpression(uriTemplateText.substr(literalStart)));
            }
            return new UriTemplate(uriTemplateText, expressions);
        }

        return parse;
    }());

    var VariableExpression = (function () {
        // helper function if JSON is not available
        function prettyPrint (value) {
            return (JSON && JSON.stringify) ? JSON.stringify(value) : value;
        }

        function isEmpty (value) {
            if (!isDefined(value)) {
                return true;
            }
            if (objectHelper.isString(value)) {
                return value === '';
            }
            if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {
                return false;
            }
            if (objectHelper.isArray(value)) {
                return value.length === 0;
            }
            for (var propertyName in value) {
                if (value.hasOwnProperty(propertyName)) {
                    return false;
                }
            }
            return true;
        }

        function propertyArray (object) {
            var
                result = [],
                propertyName;
            for (propertyName in object) {
                if (object.hasOwnProperty(propertyName)) {
                    result.push({name: propertyName, value: object[propertyName]});
                }
            }
            return result;
        }

        function VariableExpression (templateText, operator, varspecs) {
            this.templateText = templateText;
            this.operator = operator;
            this.varspecs = varspecs;
        }

        VariableExpression.prototype.toString = function () {
            return this.templateText;
        };

        function expandSimpleValue(varspec, operator, value) {
            var result = '';
            value = value.toString();
            if (operator.named) {
                result += encodingHelper.encodeLiteral(varspec.varname);
                if (value === '') {
                    result += operator.ifEmpty;
                    return result;
                }
                result += '=';
            }
            if (varspec.maxLength !== null) {
                value = value.substr(0, varspec.maxLength);
            }
            result += operator.encode(value);
            return result;
        }

        function valueDefined (nameValue) {
            return isDefined(nameValue.value);
        }

        function expandNotExploded(varspec, operator, value) {
            var
                arr = [],
                result = '';
            if (operator.named) {
                result += encodingHelper.encodeLiteral(varspec.varname);
                if (isEmpty(value)) {
                    result += operator.ifEmpty;
                    return result;
                }
                result += '=';
            }
            if (objectHelper.isArray(value)) {
                arr = value;
                arr = objectHelper.filter(arr, isDefined);
                arr = objectHelper.map(arr, operator.encode);
                result += objectHelper.join(arr, ',');
            }
            else {
                arr = propertyArray(value);
                arr = objectHelper.filter(arr, valueDefined);
                arr = objectHelper.map(arr, function (nameValue) {
                    return operator.encode(nameValue.name) + ',' + operator.encode(nameValue.value);
                });
                result += objectHelper.join(arr, ',');
            }
            return result;
        }

        function expandExplodedNamed (varspec, operator, value) {
            var
                isArray = objectHelper.isArray(value),
                arr = [];
            if (isArray) {
                arr = value;
                arr = objectHelper.filter(arr, isDefined);
                arr = objectHelper.map(arr, function (listElement) {
                    var tmp = encodingHelper.encodeLiteral(varspec.varname);
                    if (isEmpty(listElement)) {
                        tmp += operator.ifEmpty;
                    }
                    else {
                        tmp += '=' + operator.encode(listElement);
                    }
                    return tmp;
                });
            }
            else {
                arr = propertyArray(value);
                arr = objectHelper.filter(arr, valueDefined);
                arr = objectHelper.map(arr, function (nameValue) {
                    var tmp = encodingHelper.encodeLiteral(nameValue.name);
                    if (isEmpty(nameValue.value)) {
                        tmp += operator.ifEmpty;
                    }
                    else {
                        tmp += '=' + operator.encode(nameValue.value);
                    }
                    return tmp;
                });
            }
            return objectHelper.join(arr, operator.separator);
        }

        function expandExplodedUnnamed (operator, value) {
            var
                arr = [],
                result = '';
            if (objectHelper.isArray(value)) {
                arr = value;
                arr = objectHelper.filter(arr, isDefined);
                arr = objectHelper.map(arr, operator.encode);
                result += objectHelper.join(arr, operator.separator);
            }
            else {
                arr = propertyArray(value);
                arr = objectHelper.filter(arr, function (nameValue) {
                    return isDefined(nameValue.value);
                });
                arr = objectHelper.map(arr, function (nameValue) {
                    return operator.encode(nameValue.name) + '=' + operator.encode(nameValue.value);
                });
                result += objectHelper.join(arr, operator.separator);
            }
            return result;
        }


        VariableExpression.prototype.expand = function (variables) {
            var
                expanded = [],
                index,
                varspec,
                value,
                valueIsArr,
                oneExploded = false,
                operator = this.operator;

            // expand each varspec and join with operator's separator
            for (index = 0; index < this.varspecs.length; index += 1) {
                varspec = this.varspecs[index];
                value = variables[varspec.varname];
                // if (!isDefined(value)) {
                // if (variables.hasOwnProperty(varspec.name)) {
                if (value === null || value === undefined) {
                    continue;
                }
                if (varspec.exploded) {
                    oneExploded = true;
                }
                valueIsArr = objectHelper.isArray(value);
                if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                    expanded.push(expandSimpleValue(varspec, operator, value));
                }
                else if (varspec.maxLength && isDefined(value)) {
                    // 2.4.1 of the spec says: "Prefix modifiers are not applicable to variables that have composite values."
                    throw new Error('Prefix modifiers are not applicable to variables that have composite values. You tried to expand ' + this + " with " + prettyPrint(value));
                }
                else if (!varspec.exploded) {
                    if (operator.named || !isEmpty(value)) {
                        expanded.push(expandNotExploded(varspec, operator, value));
                    }
                }
                else if (isDefined(value)) {
                    if (operator.named) {
                        expanded.push(expandExplodedNamed(varspec, operator, value));
                    }
                    else {
                        expanded.push(expandExplodedUnnamed(operator, value));
                    }
                }
            }

            if (expanded.length === 0) {
                return "";
            }
            else {
                return operator.first + objectHelper.join(expanded, operator.separator);
            }
        };

        return VariableExpression;
    }());

    var UriTemplate = (function () {
        function UriTemplate (templateText, expressions) {
            this.templateText = templateText;
            this.expressions = expressions;
            objectHelper.deepFreeze(this);
        }

        UriTemplate.prototype.toString = function () {
            return this.templateText;
        };

        UriTemplate.prototype.expand = function (variables) {
            // this.expressions.map(function (expression) {return expression.expand(variables);}).join('');
            var
                index,
                result = '';
            for (index = 0; index < this.expressions.length; index += 1) {
                result += this.expressions[index].expand(variables);
            }
            return result;
        };

        UriTemplate.parse = parse;
        UriTemplate.UriTemplateError = UriTemplateError;
        return UriTemplate;
    }());

        exportCallback(UriTemplate);

    }(function (UriTemplate) {
            "use strict";
            // export UriTemplate, when module is present, or pass it to window or global
            if ('object' !== "undefined") {
                module.exports = UriTemplate;
            }
            else if (typeof undefined === "function") {
                undefined([],function() {
                    return UriTemplate;
                });
            }
            else if (typeof window !== "undefined") {
                window.UriTemplate = UriTemplate;
            }
            else {
                commonjsGlobal.UriTemplate = UriTemplate;
            }
        }
    ));
    });

    var store2 = createCommonjsModule(function (module) {
    /*! store2 - v2.10.0 - 2019-09-27
    * Copyright (c) 2019 Nathan Bubna; Licensed (MIT OR GPL-3.0) */
    ;(function(window, define) {
        var _ = {
            version: "2.10.0",
            areas: {},
            apis: {},

            // utilities
            inherit: function(api, o) {
                for (var p in api) {
                    if (!o.hasOwnProperty(p)) {
                        Object.defineProperty(o, p, Object.getOwnPropertyDescriptor(api, p));
                    }
                }
                return o;
            },
            stringify: function(d) {
                return d === undefined || typeof d === "function" ? d+'' : JSON.stringify(d);
            },
            parse: function(s) {
                // if it doesn't parse, return as is
                try{ return JSON.parse(s); }catch(e){ return s; }
            },

            // extension hooks
            fn: function(name, fn) {
                _.storeAPI[name] = fn;
                for (var api in _.apis) {
                    _.apis[api][name] = fn;
                }
            },
            get: function(area, key){ return area.getItem(key); },
            set: function(area, key, string){ area.setItem(key, string); },
            remove: function(area, key){ area.removeItem(key); },
            key: function(area, i){ return area.key(i); },
            length: function(area){ return area.length; },
            clear: function(area){ area.clear(); },

            // core functions
            Store: function(id, area, namespace) {
                var store = _.inherit(_.storeAPI, function(key, data, overwrite) {
                    if (arguments.length === 0){ return store.getAll(); }
                    if (typeof data === "function"){ return store.transact(key, data, overwrite); }// fn=data, alt=overwrite
                    if (data !== undefined){ return store.set(key, data, overwrite); }
                    if (typeof key === "string" || typeof key === "number"){ return store.get(key); }
                    if (typeof key === "function"){ return store.each(key); }
                    if (!key){ return store.clear(); }
                    return store.setAll(key, data);// overwrite=data, data=key
                });
                store._id = id;
                try {
                    var testKey = '_-bad-_';
                    area.setItem(testKey, 'wolf');
                    store._area = area;
                    area.removeItem(testKey);
                } catch (e) {}
                if (!store._area) {
                    store._area = _.storage('fake');
                }
                store._ns = namespace || '';
                if (!_.areas[id]) {
                    _.areas[id] = store._area;
                }
                if (!_.apis[store._ns+store._id]) {
                    _.apis[store._ns+store._id] = store;
                }
                return store;
            },
            storeAPI: {
                // admin functions
                area: function(id, area) {
                    var store = this[id];
                    if (!store || !store.area) {
                        store = _.Store(id, area, this._ns);//new area-specific api in this namespace
                        if (!this[id]){ this[id] = store; }
                    }
                    return store;
                },
                namespace: function(namespace, singleArea) {
                    if (!namespace){
                        return this._ns ? this._ns.substring(0,this._ns.length-1) : '';
                    }
                    var ns = namespace, store = this[ns];
                    if (!store || !store.namespace) {
                        store = _.Store(this._id, this._area, this._ns+ns+'.');//new namespaced api
                        if (!this[ns]){ this[ns] = store; }
                        if (!singleArea) {
                            for (var name in _.areas) {
                                store.area(name, _.areas[name]);
                            }
                        }
                    }
                    return store;
                },
                isFake: function(){ return this._area.name === 'fake'; },
                toString: function() {
                    return 'store'+(this._ns?'.'+this.namespace():'')+'['+this._id+']';
                },

                // storage functions
                has: function(key) {
                    if (this._area.has) {
                        return this._area.has(this._in(key));//extension hook
                    }
                    return !!(this._in(key) in this._area);
                },
                size: function(){ return this.keys().length; },
                each: function(fn, fill) {// fill is used by keys(fillList) and getAll(fillList))
                    for (var i=0, m=_.length(this._area); i<m; i++) {
                        var key = this._out(_.key(this._area, i));
                        if (key !== undefined) {
                            if (fn.call(this, key, this.get(key), fill) === false) {
                                break;
                            }
                        }
                        if (m > _.length(this._area)) { m--; i--; }// in case of removeItem
                    }
                    return fill || this;
                },
                keys: function(fillList) {
                    return this.each(function(k, v, list){ list.push(k); }, fillList || []);
                },
                get: function(key, alt) {
                    var s = _.get(this._area, this._in(key));
                    return s !== null ? _.parse(s) : alt || s;// support alt for easy default mgmt
                },
                getAll: function(fillObj) {
                    return this.each(function(k, v, all){ all[k] = v; }, fillObj || {});
                },
                transact: function(key, fn, alt) {
                    var val = this.get(key, alt),
                        ret = fn(val);
                    this.set(key, ret === undefined ? val : ret);
                    return this;
                },
                set: function(key, data, overwrite) {
                    var d = this.get(key);
                    if (d != null && overwrite === false) {
                        return data;
                    }
                    return _.set(this._area, this._in(key), _.stringify(data), overwrite) || d;
                },
                setAll: function(data, overwrite) {
                    var changed, val;
                    for (var key in data) {
                        val = data[key];
                        if (this.set(key, val, overwrite) !== val) {
                            changed = true;
                        }
                    }
                    return changed;
                },
                add: function(key, data) {
                    var d = this.get(key);
                    if (d instanceof Array) {
                        data = d.concat(data);
                    } else if (d !== null) {
                        var type = typeof d;
                        if (type === typeof data && type === 'object') {
                            for (var k in data) {
                                d[k] = data[k];
                            }
                            data = d;
                        } else {
                            data = d + data;
                        }
                    }
                    _.set(this._area, this._in(key), _.stringify(data));
                    return data;
                },
                remove: function(key, alt) {
                    var d = this.get(key, alt);
                    _.remove(this._area, this._in(key));
                    return d;
                },
                clear: function() {
                    if (!this._ns) {
                        _.clear(this._area);
                    } else {
                        this.each(function(k){ _.remove(this._area, this._in(k)); }, 1);
                    }
                    return this;
                },
                clearAll: function() {
                    var area = this._area;
                    for (var id in _.areas) {
                        if (_.areas.hasOwnProperty(id)) {
                            this._area = _.areas[id];
                            this.clear();
                        }
                    }
                    this._area = area;
                    return this;
                },

                // internal use functions
                _in: function(k) {
                    if (typeof k !== "string"){ k = _.stringify(k); }
                    return this._ns ? this._ns + k : k;
                },
                _out: function(k) {
                    return this._ns ?
                        k && k.indexOf(this._ns) === 0 ?
                            k.substring(this._ns.length) :
                            undefined : // so each() knows to skip it
                        k;
                }
            },// end _.storeAPI
            storage: function(name) {
                return _.inherit(_.storageAPI, { items: {}, name: name });
            },
            storageAPI: {
                length: 0,
                has: function(k){ return this.items.hasOwnProperty(k); },
                key: function(i) {
                    var c = 0;
                    for (var k in this.items){
                        if (this.has(k) && i === c++) {
                            return k;
                        }
                    }
                },
                setItem: function(k, v) {
                    if (!this.has(k)) {
                        this.length++;
                    }
                    this.items[k] = v;
                },
                removeItem: function(k) {
                    if (this.has(k)) {
                        delete this.items[k];
                        this.length--;
                    }
                },
                getItem: function(k){ return this.has(k) ? this.items[k] : null; },
                clear: function(){ for (var k in this.items){ this.removeItem(k); } }
            }// end _.storageAPI
        };

        var store =
            // safely set this up (throws error in IE10/32bit mode for local files)
            _.Store("local", (function(){try{ return localStorage; }catch(e){}})());
        store.local = store;// for completeness
        store._ = _;// for extenders and debuggers...
        // safely setup store.session (throws exception in FF for file:/// urls)
        store.area("session", (function(){try{ return sessionStorage; }catch(e){}})());
        store.area("page", _.storage("page"));

        if (typeof define === 'function' && define.amd !== undefined) {
            define('store2', [], function () {
                return store;
            });
        } else if ('object' !== 'undefined' && module.exports) {
            module.exports = store;
        } else {
            // expose the primary store fn to the global object and save conflicts
            if (window.store){ _.conflict = window.store; }
            window.store = store;
        }

    })(commonjsGlobal, commonjsGlobal && commonjsGlobal.define);
    });

    'use strict';

    var bind$1 = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    var isBuffer = function isBuffer (obj) {
      return obj != null && obj.constructor != null &&
        typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    };

    'use strict';




    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Function equal to merge with the difference being that no reference
     * to original objects is kept.
     *
     * @see merge
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function deepMerge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = deepMerge(result[key], val);
        } else if (typeof val === 'object') {
          result[key] = deepMerge({}, val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      deepMerge: deepMerge,
      extend: extend,
      trim: trim
    };
    var utils_1 = utils.isArray;
    var utils_2 = utils.isArrayBuffer;
    var utils_3 = utils.isBuffer;
    var utils_4 = utils.isFormData;
    var utils_5 = utils.isArrayBufferView;
    var utils_6 = utils.isString;
    var utils_7 = utils.isNumber;
    var utils_8 = utils.isObject;
    var utils_9 = utils.isUndefined;
    var utils_10 = utils.isDate;
    var utils_11 = utils.isFile;
    var utils_12 = utils.isBlob;
    var utils_13 = utils.isFunction;
    var utils_14 = utils.isStream;
    var utils_15 = utils.isURLSearchParams;
    var utils_16 = utils.isStandardBrowserEnv;
    var utils_17 = utils.forEach;
    var utils_18 = utils.merge;
    var utils_19 = utils.deepMerge;
    var utils_20 = utils.extend;
    var utils_21 = utils.trim;

    'use strict';



    function encode$1(val) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode$1(key) + '=' + encode$1(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    'use strict';



    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    'use strict';



    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    'use strict';

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    'use strict';



    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    'use strict';

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    'use strict';



    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    'use strict';



    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    'use strict';



    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    'use strict';



    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    'use strict';



    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    'use strict';








    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password || '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          var cookies$1 = cookies;

          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
            cookies$1.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (config.withCredentials) {
          request.withCredentials = true;
        }

        // Add responseType to request if needed
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (requestData === undefined) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    'use strict';




    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      // Only Node.JS has a process variable that is of [[Class]] process
      if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      } else if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    'use strict';

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    'use strict';

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    'use strict';








    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Support baseURL config
      if (config.baseURL && !isAbsoluteURL(config.url)) {
        config.url = combineURLs(config.baseURL, config.url);
      }

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers || {}
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    'use strict';



    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        }
      });

      utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
        if (utils.isObject(config2[prop])) {
          config[prop] = utils.deepMerge(config1[prop], config2[prop]);
        } else if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (utils.isObject(config1[prop])) {
          config[prop] = utils.deepMerge(config1[prop]);
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      utils.forEach([
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
        'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
        'socketPath'
      ], function defaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      return config;
    };

    'use strict';







    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);
      config.method = config.method ? config.method.toLowerCase() : 'get';

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    'use strict';

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    'use strict';



    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    'use strict';

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread$1 = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    'use strict';







    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind$1(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread$1;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var default_1 = axios;
    axios_1.default = default_1;

    var axios$1 = axios_1;

    'use strict';

    var has$1 = Object.prototype.hasOwnProperty;
    var isArray$1 = Array.isArray;

    var hexTable = (function () {
        var array = [];
        for (var i = 0; i < 256; ++i) {
            array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
        }

        return array;
    }());

    var compactQueue = function compactQueue(queue) {
        while (queue.length > 1) {
            var item = queue.pop();
            var obj = item.obj[item.prop];

            if (isArray$1(obj)) {
                var compacted = [];

                for (var j = 0; j < obj.length; ++j) {
                    if (typeof obj[j] !== 'undefined') {
                        compacted.push(obj[j]);
                    }
                }

                item.obj[item.prop] = compacted;
            }
        }
    };

    var arrayToObject = function arrayToObject(source, options) {
        var obj = options && options.plainObjects ? Object.create(null) : {};
        for (var i = 0; i < source.length; ++i) {
            if (typeof source[i] !== 'undefined') {
                obj[i] = source[i];
            }
        }

        return obj;
    };

    var merge$1 = function merge(target, source, options) {
        /* eslint no-param-reassign: 0 */
        if (!source) {
            return target;
        }

        if (typeof source !== 'object') {
            if (isArray$1(target)) {
                target.push(source);
            } else if (target && typeof target === 'object') {
                if ((options && (options.plainObjects || options.allowPrototypes)) || !has$1.call(Object.prototype, source)) {
                    target[source] = true;
                }
            } else {
                return [target, source];
            }

            return target;
        }

        if (!target || typeof target !== 'object') {
            return [target].concat(source);
        }

        var mergeTarget = target;
        if (isArray$1(target) && !isArray$1(source)) {
            mergeTarget = arrayToObject(target, options);
        }

        if (isArray$1(target) && isArray$1(source)) {
            source.forEach(function (item, i) {
                if (has$1.call(target, i)) {
                    var targetItem = target[i];
                    if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                        target[i] = merge(targetItem, item, options);
                    } else {
                        target.push(item);
                    }
                } else {
                    target[i] = item;
                }
            });
            return target;
        }

        return Object.keys(source).reduce(function (acc, key) {
            var value = source[key];

            if (has$1.call(acc, key)) {
                acc[key] = merge(acc[key], value, options);
            } else {
                acc[key] = value;
            }
            return acc;
        }, mergeTarget);
    };

    var assign$1 = function assignSingleSource(target, source) {
        return Object.keys(source).reduce(function (acc, key) {
            acc[key] = source[key];
            return acc;
        }, target);
    };

    var decode$1 = function (str, decoder, charset) {
        var strWithoutPlus = str.replace(/\+/g, ' ');
        if (charset === 'iso-8859-1') {
            // unescape never throws, no try...catch needed:
            return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
        }
        // utf-8
        try {
            return decodeURIComponent(strWithoutPlus);
        } catch (e) {
            return strWithoutPlus;
        }
    };

    var encode$2 = function encode(str, defaultEncoder, charset) {
        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
            return str;
        }

        var string = str;
        if (typeof str === 'symbol') {
            string = Symbol.prototype.toString.call(str);
        } else if (typeof str !== 'string') {
            string = String(str);
        }

        if (charset === 'iso-8859-1') {
            return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
                return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
            });
        }

        var out = '';
        for (var i = 0; i < string.length; ++i) {
            var c = string.charCodeAt(i);

            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
            ) {
                out += string.charAt(i);
                continue;
            }

            if (c < 0x80) {
                out = out + hexTable[c];
                continue;
            }

            if (c < 0x800) {
                out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
            out += hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        return out;
    };

    var compact = function compact(value) {
        var queue = [{ obj: { o: value }, prop: 'o' }];
        var refs = [];

        for (var i = 0; i < queue.length; ++i) {
            var item = queue[i];
            var obj = item.obj[item.prop];

            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; ++j) {
                var key = keys[j];
                var val = obj[key];
                if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                    queue.push({ obj: obj, prop: key });
                    refs.push(val);
                }
            }
        }

        compactQueue(queue);

        return value;
    };

    var isRegExp = function isRegExp(obj) {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };

    var isBuffer$1 = function isBuffer(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }

        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };

    var combine = function combine(a, b) {
        return [].concat(a, b);
    };

    var utils$1 = {
        arrayToObject: arrayToObject,
        assign: assign$1,
        combine: combine,
        compact: compact,
        decode: decode$1,
        encode: encode$2,
        isBuffer: isBuffer$1,
        isRegExp: isRegExp,
        merge: merge$1
    };
    var utils_1$1 = utils$1.arrayToObject;
    var utils_2$1 = utils$1.assign;
    var utils_3$1 = utils$1.combine;
    var utils_4$1 = utils$1.compact;
    var utils_5$1 = utils$1.decode;
    var utils_6$1 = utils$1.encode;
    var utils_7$1 = utils$1.isBuffer;
    var utils_8$1 = utils$1.isRegExp;
    var utils_9$1 = utils$1.merge;

    'use strict';

    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;



    var Format = {
        RFC1738: 'RFC1738',
        RFC3986: 'RFC3986'
    };

    var formats = utils$1.assign(
        {
            'default': Format.RFC3986,
            formatters: {
                RFC1738: function (value) {
                    return replace.call(value, percentTwenties, '+');
                },
                RFC3986: function (value) {
                    return String(value);
                }
            }
        },
        Format
    );

    'use strict';



    var has$2 = Object.prototype.hasOwnProperty;

    var arrayPrefixGenerators = {
        brackets: function brackets(prefix) {
            return prefix + '[]';
        },
        comma: 'comma',
        indices: function indices(prefix, key) {
            return prefix + '[' + key + ']';
        },
        repeat: function repeat(prefix) {
            return prefix;
        }
    };

    var isArray$2 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function (arr, valueOrArray) {
        push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
    };

    var toISO = Date.prototype.toISOString;

    var defaultFormat = formats['default'];
    var defaults$1 = {
        addQueryPrefix: false,
        allowDots: false,
        charset: 'utf-8',
        charsetSentinel: false,
        delimiter: '&',
        encode: true,
        encoder: utils$1.encode,
        encodeValuesOnly: false,
        format: defaultFormat,
        formatter: formats.formatters[defaultFormat],
        // deprecated
        indices: false,
        serializeDate: function serializeDate(date) {
            return toISO.call(date);
        },
        skipNulls: false,
        strictNullHandling: false
    };

    var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
        return typeof v === 'string'
            || typeof v === 'number'
            || typeof v === 'boolean'
            || typeof v === 'symbol'
            || typeof v === 'bigint';
    };

    var stringify$1 = function stringify(
        object,
        prefix,
        generateArrayPrefix,
        strictNullHandling,
        skipNulls,
        encoder,
        filter,
        sort,
        allowDots,
        serializeDate,
        formatter,
        encodeValuesOnly,
        charset
    ) {
        var obj = object;
        if (typeof filter === 'function') {
            obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
            obj = serializeDate(obj);
        } else if (generateArrayPrefix === 'comma' && isArray$2(obj)) {
            obj = obj.join(',');
        }

        if (obj === null) {
            if (strictNullHandling) {
                return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, 'key') : prefix;
            }

            obj = '';
        }

        if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
            if (encoder) {
                var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, 'key');
                return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults$1.encoder, charset, 'value'))];
            }
            return [formatter(prefix) + '=' + formatter(String(obj))];
        }

        var values = [];

        if (typeof obj === 'undefined') {
            return values;
        }

        var objKeys;
        if (isArray$2(filter)) {
            objKeys = filter;
        } else {
            var keys = Object.keys(obj);
            objKeys = sort ? keys.sort(sort) : keys;
        }

        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];

            if (skipNulls && obj[key] === null) {
                continue;
            }

            if (isArray$2(obj)) {
                pushToArray(values, stringify(
                    obj[key],
                    typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                    generateArrayPrefix,
                    strictNullHandling,
                    skipNulls,
                    encoder,
                    filter,
                    sort,
                    allowDots,
                    serializeDate,
                    formatter,
                    encodeValuesOnly,
                    charset
                ));
            } else {
                pushToArray(values, stringify(
                    obj[key],
                    prefix + (allowDots ? '.' + key : '[' + key + ']'),
                    generateArrayPrefix,
                    strictNullHandling,
                    skipNulls,
                    encoder,
                    filter,
                    sort,
                    allowDots,
                    serializeDate,
                    formatter,
                    encodeValuesOnly,
                    charset
                ));
            }
        }

        return values;
    };

    var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
        if (!opts) {
            return defaults$1;
        }

        if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
            throw new TypeError('Encoder has to be a function.');
        }

        var charset = opts.charset || defaults$1.charset;
        if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
            throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
        }

        var format = formats['default'];
        if (typeof opts.format !== 'undefined') {
            if (!has$2.call(formats.formatters, opts.format)) {
                throw new TypeError('Unknown format option provided.');
            }
            format = opts.format;
        }
        var formatter = formats.formatters[format];

        var filter = defaults$1.filter;
        if (typeof opts.filter === 'function' || isArray$2(opts.filter)) {
            filter = opts.filter;
        }

        return {
            addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
            allowDots: typeof opts.allowDots === 'undefined' ? defaults$1.allowDots : !!opts.allowDots,
            charset: charset,
            charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,
            delimiter: typeof opts.delimiter === 'undefined' ? defaults$1.delimiter : opts.delimiter,
            encode: typeof opts.encode === 'boolean' ? opts.encode : defaults$1.encode,
            encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults$1.encoder,
            encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
            filter: filter,
            formatter: formatter,
            serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults$1.serializeDate,
            skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults$1.skipNulls,
            sort: typeof opts.sort === 'function' ? opts.sort : null,
            strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling
        };
    };

    var stringify_1 = function (object, opts) {
        var obj = object;
        var options = normalizeStringifyOptions(opts);

        var objKeys;
        var filter;

        if (typeof options.filter === 'function') {
            filter = options.filter;
            obj = filter('', obj);
        } else if (isArray$2(options.filter)) {
            filter = options.filter;
            objKeys = filter;
        }

        var keys = [];

        if (typeof obj !== 'object' || obj === null) {
            return '';
        }

        var arrayFormat;
        if (opts && opts.arrayFormat in arrayPrefixGenerators) {
            arrayFormat = opts.arrayFormat;
        } else if (opts && 'indices' in opts) {
            arrayFormat = opts.indices ? 'indices' : 'repeat';
        } else {
            arrayFormat = 'indices';
        }

        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

        if (!objKeys) {
            objKeys = Object.keys(obj);
        }

        if (options.sort) {
            objKeys.sort(options.sort);
        }

        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];

            if (options.skipNulls && obj[key] === null) {
                continue;
            }
            pushToArray(keys, stringify$1(
                obj[key],
                key,
                generateArrayPrefix,
                options.strictNullHandling,
                options.skipNulls,
                options.encode ? options.encoder : null,
                options.filter,
                options.sort,
                options.allowDots,
                options.serializeDate,
                options.formatter,
                options.encodeValuesOnly,
                options.charset
            ));
        }

        var joined = keys.join(options.delimiter);
        var prefix = options.addQueryPrefix === true ? '?' : '';

        if (options.charsetSentinel) {
            if (options.charset === 'iso-8859-1') {
                // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
                prefix += 'utf8=%26%2310003%3B&';
            } else {
                // encodeURIComponent('✓')
                prefix += 'utf8=%E2%9C%93&';
            }
        }

        return joined.length > 0 ? prefix + joined : '';
    };

    'use strict';



    var has$3 = Object.prototype.hasOwnProperty;
    var isArray$3 = Array.isArray;

    var defaults$2 = {
        allowDots: false,
        allowPrototypes: false,
        arrayLimit: 20,
        charset: 'utf-8',
        charsetSentinel: false,
        comma: false,
        decoder: utils$1.decode,
        delimiter: '&',
        depth: 5,
        ignoreQueryPrefix: false,
        interpretNumericEntities: false,
        parameterLimit: 1000,
        parseArrays: true,
        plainObjects: false,
        strictNullHandling: false
    };

    var interpretNumericEntities = function (str) {
        return str.replace(/&#(\d+);/g, function ($0, numberStr) {
            return String.fromCharCode(parseInt(numberStr, 10));
        });
    };

    // This is what browsers will submit when the ✓ character occurs in an
    // application/x-www-form-urlencoded body and the encoding of the page containing
    // the form is iso-8859-1, or when the submitted form has an accept-charset
    // attribute of iso-8859-1. Presumably also with other charsets that do not contain
    // the ✓ character, such as us-ascii.
    var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

    // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
    var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

    var parseValues = function parseQueryStringValues(str, options) {
        var obj = {};
        var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
        var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
        var parts = cleanStr.split(options.delimiter, limit);
        var skipIndex = -1; // Keep track of where the utf8 sentinel was found
        var i;

        var charset = options.charset;
        if (options.charsetSentinel) {
            for (i = 0; i < parts.length; ++i) {
                if (parts[i].indexOf('utf8=') === 0) {
                    if (parts[i] === charsetSentinel) {
                        charset = 'utf-8';
                    } else if (parts[i] === isoSentinel) {
                        charset = 'iso-8859-1';
                    }
                    skipIndex = i;
                    i = parts.length; // The eslint settings do not allow break;
                }
            }
        }

        for (i = 0; i < parts.length; ++i) {
            if (i === skipIndex) {
                continue;
            }
            var part = parts[i];

            var bracketEqualsPos = part.indexOf(']=');
            var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

            var key, val;
            if (pos === -1) {
                key = options.decoder(part, defaults$2.decoder, charset, 'key');
                val = options.strictNullHandling ? null : '';
            } else {
                key = options.decoder(part.slice(0, pos), defaults$2.decoder, charset, 'key');
                val = options.decoder(part.slice(pos + 1), defaults$2.decoder, charset, 'value');
            }

            if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
                val = interpretNumericEntities(val);
            }

            if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
                val = val.split(',');
            }

            if (part.indexOf('[]=') > -1) {
                val = isArray$3(val) ? [val] : val;
            }

            if (has$3.call(obj, key)) {
                obj[key] = utils$1.combine(obj[key], val);
            } else {
                obj[key] = val;
            }
        }

        return obj;
    };

    var parseObject = function (chain, val, options) {
        var leaf = val;

        for (var i = chain.length - 1; i >= 0; --i) {
            var obj;
            var root = chain[i];

            if (root === '[]' && options.parseArrays) {
                obj = [].concat(leaf);
            } else {
                obj = options.plainObjects ? Object.create(null) : {};
                var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
                var index = parseInt(cleanRoot, 10);
                if (!options.parseArrays && cleanRoot === '') {
                    obj = { 0: leaf };
                } else if (
                    !isNaN(index)
                    && root !== cleanRoot
                    && String(index) === cleanRoot
                    && index >= 0
                    && (options.parseArrays && index <= options.arrayLimit)
                ) {
                    obj = [];
                    obj[index] = leaf;
                } else {
                    obj[cleanRoot] = leaf;
                }
            }

            leaf = obj;
        }

        return leaf;
    };

    var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
        if (!givenKey) {
            return;
        }

        // Transform dot notation to bracket notation
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

        // The regex chunks

        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;

        // Get the parent

        var segment = options.depth > 0 && brackets.exec(key);
        var parent = segment ? key.slice(0, segment.index) : key;

        // Stash the parent if it exists

        var keys = [];
        if (parent) {
            // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
            if (!options.plainObjects && has$3.call(Object.prototype, parent)) {
                if (!options.allowPrototypes) {
                    return;
                }
            }

            keys.push(parent);
        }

        // Loop through children appending to the array until we hit depth

        var i = 0;
        while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
            i += 1;
            if (!options.plainObjects && has$3.call(Object.prototype, segment[1].slice(1, -1))) {
                if (!options.allowPrototypes) {
                    return;
                }
            }
            keys.push(segment[1]);
        }

        // If there's a remainder, just add whatever is left

        if (segment) {
            keys.push('[' + key.slice(segment.index) + ']');
        }

        return parseObject(keys, val, options);
    };

    var normalizeParseOptions = function normalizeParseOptions(opts) {
        if (!opts) {
            return defaults$2;
        }

        if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
            throw new TypeError('Decoder has to be a function.');
        }

        if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
            throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
        }
        var charset = typeof opts.charset === 'undefined' ? defaults$2.charset : opts.charset;

        return {
            allowDots: typeof opts.allowDots === 'undefined' ? defaults$2.allowDots : !!opts.allowDots,
            allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults$2.allowPrototypes,
            arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults$2.arrayLimit,
            charset: charset,
            charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$2.charsetSentinel,
            comma: typeof opts.comma === 'boolean' ? opts.comma : defaults$2.comma,
            decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults$2.decoder,
            delimiter: typeof opts.delimiter === 'string' || utils$1.isRegExp(opts.delimiter) ? opts.delimiter : defaults$2.delimiter,
            // eslint-disable-next-line no-implicit-coercion, no-extra-parens
            depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults$2.depth,
            ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
            interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults$2.interpretNumericEntities,
            parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults$2.parameterLimit,
            parseArrays: opts.parseArrays !== false,
            plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults$2.plainObjects,
            strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$2.strictNullHandling
        };
    };

    var parse$1 = function (str, opts) {
        var options = normalizeParseOptions(opts);

        if (str === '' || str === null || typeof str === 'undefined') {
            return options.plainObjects ? Object.create(null) : {};
        }

        var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};

        // Iterate over the keys and setup the new object

        var keys = Object.keys(tempObj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var newObj = parseKeys(key, tempObj[key], options);
            obj = utils$1.merge(obj, newObj, options);
        }

        return utils$1.compact(obj);
    };

    'use strict';





    var lib = {
        formats: formats,
        parse: parse$1,
        stringify: stringify_1
    };
    var lib_1 = lib.formats;
    var lib_2 = lib.parse;
    var lib_3 = lib.stringify;

    var client = function(axios, { url, ...credentials }) {
      const config = {
        url,
        method: 'post',
        data: lib.stringify(credentials)
      };

      return () => axios(config).then(res => res.data);
    };

    function getMaxAge(res) {
      return res.expires_in;
    }

    function headerFormatter(res) {
      return 'Bearer ' + res.access_token;
    }

    var interceptor = function (tokenProvider, authenticate) {
      const getToken = tokenProvider.tokenCache(authenticate, { getMaxAge });
      return tokenProvider({ getToken, headerFormatter });
    };

    var src = {
      client: client,
      interceptor: interceptor
    };
    var src_1 = src.client;
    var src_2 = src.interceptor;

    'use strict';

    /**
     * Check if we're required to add a port number.
     *
     * @see https://url.spec.whatwg.org/#default-port
     * @param {Number|String} port Port number we need to check
     * @param {String} protocol Protocol we need to check against.
     * @returns {Boolean} Is it a default port for the given protocol
     * @api private
     */
    var requiresPort = function required(port, protocol) {
      protocol = protocol.split(':')[0];
      port = +port;

      if (!port) return false;

      switch (protocol) {
        case 'http':
        case 'ws':
        return port !== 80;

        case 'https':
        case 'wss':
        return port !== 443;

        case 'ftp':
        return port !== 21;

        case 'gopher':
        return port !== 70;

        case 'file':
        return false;
      }

      return port !== 0;
    };

    'use strict';

    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
      , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
      , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
      , left = new RegExp('^'+ whitespace +'+');

    /**
     * Trim a given string.
     *
     * @param {String} str String to trim.
     * @public
     */
    function trimLeft(str) {
      return (str ? str : '').toString().replace(left, '');
    }

    /**
     * These are the parse rules for the URL parser, it informs the parser
     * about:
     *
     * 0. The char it Needs to parse, if it's a string it should be done using
     *    indexOf, RegExp using exec and NaN means set as current value.
     * 1. The property we should set when parsing this value.
     * 2. Indication if it's backwards or forward parsing, when set as number it's
     *    the value of extra chars that should be split off.
     * 3. Inherit from location if non existing in the parser.
     * 4. `toLowerCase` the resulting value.
     */
    var rules = [
      ['#', 'hash'],                        // Extract from the back.
      ['?', 'query'],                       // Extract from the back.
      function sanitize(address) {          // Sanitize what is left of the address
        return address.replace('\\', '/');
      },
      ['/', 'pathname'],                    // Extract from the back.
      ['@', 'auth', 1],                     // Extract from the front.
      [NaN, 'host', undefined, 1, 1],       // Set left over value.
      [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
      [NaN, 'hostname', undefined, 1, 1]    // Set left over.
    ];

    /**
     * These properties should not be copied or inherited from. This is only needed
     * for all non blob URL's as a blob URL does not include a hash, only the
     * origin.
     *
     * @type {Object}
     * @private
     */
    var ignore = { hash: 1, query: 1 };

    /**
     * The location object differs when your code is loaded through a normal page,
     * Worker or through a worker using a blob. And with the blobble begins the
     * trouble as the location object will contain the URL of the blob, not the
     * location of the page where our code is loaded in. The actual origin is
     * encoded in the `pathname` so we can thankfully generate a good "default"
     * location from it so we can generate proper relative URL's again.
     *
     * @param {Object|String} loc Optional default location object.
     * @returns {Object} lolcation object.
     * @public
     */
    function lolcation(loc) {
      var globalVar;

      if (typeof window !== 'undefined') globalVar = window;
      else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;
      else if (typeof self !== 'undefined') globalVar = self;
      else globalVar = {};

      var location = globalVar.location || {};
      loc = loc || location;

      var finaldestination = {}
        , type = typeof loc
        , key;

      if ('blob:' === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ('string' === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ('object' === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }

        if (finaldestination.slashes === undefined) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }

      return finaldestination;
    }

    /**
     * @typedef ProtocolExtract
     * @type Object
     * @property {String} protocol Protocol matched in the URL, in lowercase.
     * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
     * @property {String} rest Rest of the URL that is not part of the protocol.
     */

    /**
     * Extract protocol information from a URL with/without double slash ("//").
     *
     * @param {String} address URL we want to extract from.
     * @return {ProtocolExtract} Extracted information.
     * @private
     */
    function extractProtocol(address) {
      address = trimLeft(address);
      var match = protocolre.exec(address);

      return {
        protocol: match[1] ? match[1].toLowerCase() : '',
        slashes: !!match[2],
        rest: match[3]
      };
    }

    /**
     * Resolve a relative URL pathname against a base URL pathname.
     *
     * @param {String} relative Pathname of the relative URL.
     * @param {String} base Pathname of the base URL.
     * @return {String} Resolved pathname.
     * @private
     */
    function resolve(relative, base) {
      if (relative === '') return base;

      var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
        , i = path.length
        , last = path[i - 1]
        , unshift = false
        , up = 0;

      while (i--) {
        if (path[i] === '.') {
          path.splice(i, 1);
        } else if (path[i] === '..') {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0) unshift = true;
          path.splice(i, 1);
          up--;
        }
      }

      if (unshift) path.unshift('');
      if (last === '.' || last === '..') path.push('');

      return path.join('/');
    }

    /**
     * The actual URL instance. Instead of returning an object we've opted-in to
     * create an actual constructor as it's much more memory efficient and
     * faster and it pleases my OCD.
     *
     * It is worth noting that we should not use `URL` as class name to prevent
     * clashes with the global URL instance that got introduced in browsers.
     *
     * @constructor
     * @param {String} address URL we want to parse.
     * @param {Object|String} [location] Location defaults for relative paths.
     * @param {Boolean|Function} [parser] Parser for the query string.
     * @private
     */
    function Url(address, location, parser) {
      address = trimLeft(address);

      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }

      var relative, extracted, parse, instruction, index, key
        , instructions = rules.slice()
        , type = typeof location
        , url = this
        , i = 0;

      //
      // The following if statements allows this module two have compatibility with
      // 2 different API:
      //
      // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
      //    where the boolean indicates that the query string should also be parsed.
      //
      // 2. The `URL` interface of the browser which accepts a URL, object as
      //    arguments. The supplied object will be used as default values / fall-back
      //    for relative paths.
      //
      if ('object' !== type && 'string' !== type) {
        parser = location;
        location = null;
      }

      if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;

      location = lolcation(location);

      //
      // Extract protocol information before running the instructions.
      //
      extracted = extractProtocol(address || '');
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || '';
      address = extracted.rest;

      //
      // When the authority component is absent the URL starts with a path
      // component.
      //
      if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

      for (; i < instructions.length; i++) {
        instruction = instructions[i];

        if (typeof instruction === 'function') {
          address = instruction(address);
          continue;
        }

        parse = instruction[0];
        key = instruction[1];

        if (parse !== parse) {
          url[key] = address;
        } else if ('string' === typeof parse) {
          if (~(index = address.indexOf(parse))) {
            if ('number' === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if ((index = parse.exec(address))) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }

        url[key] = url[key] || (
          relative && instruction[3] ? location[key] || '' : ''
        );

        //
        // Hostname, host and protocol should be lowercased so they can be used to
        // create a proper `origin`.
        //
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }

      //
      // Also parse the supplied query string in to an object. If we're supplied
      // with a custom parser as function use that instead of the default build-in
      // parser.
      //
      if (parser) url.query = parser(url.query);

      //
      // If the URL is relative, resolve the pathname against the base URL.
      //
      if (
          relative
        && location.slashes
        && url.pathname.charAt(0) !== '/'
        && (url.pathname !== '' || location.pathname !== '')
      ) {
        url.pathname = resolve(url.pathname, location.pathname);
      }

      //
      // We should not add port numbers if they are already the default port number
      // for a given protocol. As the host also contains the port number we're going
      // override it with the hostname which contains no port number.
      //
      if (!requiresPort(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = '';
      }

      //
      // Parse down the `auth` for the username and password.
      //
      url.username = url.password = '';
      if (url.auth) {
        instruction = url.auth.split(':');
        url.username = instruction[0] || '';
        url.password = instruction[1] || '';
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      //
      // The href is just the compiled result.
      //
      url.href = url.toString();
    }

    /**
     * This is convenience method for changing properties in the URL instance to
     * insure that they all propagate correctly.
     *
     * @param {String} part          Property we need to adjust.
     * @param {Mixed} value          The newly assigned value.
     * @param {Boolean|Function} fn  When setting the query, it will be the function
     *                               used to parse the query.
     *                               When setting the protocol, double slash will be
     *                               removed from the final url if it is true.
     * @returns {URL} URL instance for chaining.
     * @public
     */
    function set(part, value, fn) {
      var url = this;

      switch (part) {
        case 'query':
          if ('string' === typeof value && value.length) {
            value = (fn || querystringify_1.parse)(value);
          }

          url[part] = value;
          break;

        case 'port':
          url[part] = value;

          if (!requiresPort(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = '';
          } else if (value) {
            url.host = url.hostname +':'+ value;
          }

          break;

        case 'hostname':
          url[part] = value;

          if (url.port) value += ':'+ url.port;
          url.host = value;
          break;

        case 'host':
          url[part] = value;

          if (/:\d+$/.test(value)) {
            value = value.split(':');
            url.port = value.pop();
            url.hostname = value.join(':');
          } else {
            url.hostname = value;
            url.port = '';
          }

          break;

        case 'protocol':
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;

        case 'pathname':
        case 'hash':
          if (value) {
            var char = part === 'pathname' ? '/' : '#';
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;

        default:
          url[part] = value;
      }

      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];

        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      url.href = url.toString();

      return url;
    }

    /**
     * Transform the properties back in to a valid and full URL string.
     *
     * @param {Function} stringify Optional query stringify function.
     * @returns {String} Compiled version of the URL.
     * @public
     */
    function toString$1(stringify) {
      if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;

      var query
        , url = this
        , protocol = url.protocol;

      if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

      var result = protocol + (url.slashes ? '//' : '');

      if (url.username) {
        result += url.username;
        if (url.password) result += ':'+ url.password;
        result += '@';
      }

      result += url.host + url.pathname;

      query = 'object' === typeof url.query ? stringify(url.query) : url.query;
      if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

      if (url.hash) result += url.hash;

      return result;
    }

    Url.prototype = { set: set, toString: toString$1 };

    //
    // Expose the URL parser and some additional properties that might be useful for
    // others or testing.
    //
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = querystringify_1;

    var urlParse = Url;

    var index_min = createCommonjsModule(function (module) {
    module.exports=function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n});},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t);var n={statusCodes:[401]};t.default=function e(t,r){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},u=t.interceptors.response.use(function(e){return e},function(s){var i=o.hasOwnProperty("statusCodes")&&o.statusCodes.length?o.statusCodes:n.statusCodes;if(!s.response||s.response.status&&-1===i.indexOf(+s.response.status))return Promise.reject(s);t.interceptors.response.eject(u);var c=r(s),f=t.interceptors.request.use(function(e){return c.then(function(){return e})});return c.then(function(){return t.interceptors.request.eject(f),t(s.response.config)}).catch(function(e){return t.interceptors.request.eject(f),Promise.reject(e)}).finally(function(){return e(t,r,o)})});return t};}]);
    });

    var createAuthRefreshInterceptor = unwrapExports(index_min);

    /* global DOMException */

    var clipboardCopy_1 = clipboardCopy;

    function clipboardCopy (text) {
      // Use the Async Clipboard API when available. Requires a secure browing
      // context (i.e. HTTPS)
      if (navigator.clipboard) {
        return navigator.clipboard.writeText(text).catch(function (err) {
          throw (err !== undefined ? err : new DOMException('The request is not allowed', 'NotAllowedError'))
        })
      }

      // ...Otherwise, use document.execCommand() fallback

      // Put the text to copy into a <span>
      var span = document.createElement('span');
      span.textContent = text;

      // Preserve consecutive spaces and newlines
      span.style.whiteSpace = 'pre';

      // Add the <span> to the page
      document.body.appendChild(span);

      // Make a selection object representing the range of text selected by the user
      var selection = window.getSelection();
      var range = window.document.createRange();
      selection.removeAllRanges();
      range.selectNode(span);
      selection.addRange(range);

      // Copy text to the clipboard
      var success = false;
      try {
        success = window.document.execCommand('copy');
      } catch (err) {
        console.log('error', err);
      }

      // Cleanup
      selection.removeAllRanges();
      window.document.body.removeChild(span);

      return success
        ? Promise.resolve()
        : Promise.reject(new DOMException('The request is not allowed', 'NotAllowedError'))
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const env = writable("");
    const token = writable("");

    env.subscribe(val => {
      if (val != "") {
        store2.set("env", val);
      }
    });

    function unique(value, index, self) {
      return self.indexOf(value) === index;
    }

    function add(data, val) {
      const arr = data.split(";");
      arr.push(val);

      return arr
        .filter(unique)
        .filter(String)
        .join(";");
    }

    function remove(data, val) {
      return data
        .split(";")
        .filter(v => v != val)
        .join(";");
    }

    function createAuth() {
      const { subscribe, update } = writable("");

      return {
        subscribe,
        add: val => update(data => add(data, val)),
        remove: val => update(data => remove(data, val))
      };
    }

    const auth = createAuth();

    prism.languages.json = {
      property: {
        pattern: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
        greedy: true
      },
      string: {
        pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
        greedy: true
      },
      comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      number: /-?\d+\.?\d*(e[+-]?\d+)?/i,
      punctuation: /[{}[\],]/,
      operator: /:/,
      boolean: /\b(?:true|false)\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      }
    };

    const highlight = function(code, lang) {
      const supported = ["xml", "json"];

      if (!supported.includes(lang)) {
        lang = "markup";
      }

      return prism.highlight(code, prism.languages[lang], lang);
    };

    marked.setOptions({
      highlight
    });

    const renderer = new marked.Renderer();

    renderer.pre = renderer.code;
    renderer.code = function(code, infostring, escaped) {
      const out = this.pre(code, infostring, escaped);
      return out.replace("<pre>", `<pre class="language-${infostring}">`);
    };

    const markdown = function(source) {
      return source ? marked(source, { renderer: renderer }) : "";
    };

    const toc = function(source) {
      if (!source) {
        return [];
      }

      const tokens = marked.lexer(source);
      const headings = tokens.filter(elem => elem.type === "heading");
      const depths = headings.map(head => head.depth);
      const minDepth = Math.min(...depths);

      return headings.map(head => ({
        text: head.text,
        level: head.depth - minDepth
      }));
    };

    const colorize = function(str, prefix = "is-") {
      switch (str) {
        case "get":
          return `${prefix}success`;
        case "post":
          return `${prefix}link`;
        case "put":
          return `${prefix}primary`;
        case "patch":
          return `${prefix}info`;
        case "delete":
          return `${prefix}danger`;
        case 200:
        case 201:
        case 202:
        case 204:
          return `${prefix}info`;
        case 401:
        case 403:
        case 404:
        case 422:
          return `${prefix}warning`;
        case 500:
          return `${prefix}danger`;
      }
    };

    const slugify = function(str) {
      return speakingurl$1(str, "-");
    };

    const alias = str => {
      return str && str.match("json") ? "json" : "markup";
    };

    const stringify$2 = obj => {
      if (typeof obj === "string") {
        return obj;
      }

      if (obj) {
        return JSON.stringify(obj, null, "  ");
      }

      return "";
    };

    const expandUrl = (uri, obj) => {
      const tpl = uritemplate.parse(uri);
      return tpl.expand(obj);
    };

    const actionFilter = (act, regex) => {
      return (
        act.path.match(regex) || act.method.match(regex) || act.title.match(regex)
      );
    };

    const filteredItem = (title, key, items) => {
      if (items.length === 0) {
        return false;
      }

      return { title: title, [key]: items };
    };

    function escape$2(text) {
      return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }

    const filterActions = (tagActions, query) => {
      if (query.startsWith("g:")) {
        return tagActions
          .map(tag => {
            const children = tag.children.filter(child => {
              return slugify(child.title) === query.substr(2);
            });

            return filteredItem(tag.title, "children", children.filter(Boolean));
          })
          .filter(Boolean);
      }

      const regex = new RegExp(escape$2(query), "gi");

      return tagActions
        .map(tag => {
          const children = tag.children.map(child => {
            const actions = child.actions.filter(act => actionFilter(act, regex));
            return filteredItem(child.title, "actions", actions);
          });

          return filteredItem(tag.title, "children", children.filter(Boolean));
        })
        .filter(Boolean);
    };

    const basePath = config => {
      if (config.basePath.endsWith("/")) {
        return config.basePath;
      } else {
        return config.basePath + "/";
      }
    };

    const tokenName = env => `token:${env}`;
    const setToken = (env, token) => store2.session.set(tokenName(env), token);
    const getToken = env => store2.session.get(tokenName(env));
    const removeToken = env => store2.session.remove(tokenName(env));

    const refreshTokenName = env => `refresh-token:${env}`;
    const setRefreshToken = (env, token) =>
      store2.session.set(refreshTokenName(env), token);
    const getRefreshToken = env => store2.session.get(refreshTokenName(env));
    const removeRefreshToken = env => store2.session.remove(refreshTokenName(env));

    const isAuth = (environment, name) => {
      return environment.auth && environment.auth.name === name;
    };

    const pushHistory = href => history.pushState(history.state, "", href);

    const requestToken = async (client, options) => {
      const authRequest = src.client(client, options);
      const authCode = await authRequest();

      if (typeof authCode === "string") {
        const authParsed = querystringify_1.parse(authCode);
        return {
          accessToken: authParsed.access_token,
          refreshToken: authParsed.refresh_token
        };
      }

      return {
        accessToken: authCode.access_token,
        refreshToken: authCode.refresh_token
      };
    };

    const exchangeToken = async (code, options) => {
      return requestToken(axios$1.create(), {
        url: options.tokenUrl,
        grant_type: "authorization_code",
        client_id: options.clientId,
        client_secret: options.clientSecret,
        redirect_uri: options.callbackUrl,
        code: code
      });
    };

    const populate = arr => {
      return arr
        .filter(obj => obj.used)
        .reduce((prev, cur) => {
          prev[cur.name] = cur.value;
          return prev;
        }, {});
    };

    const allowBody = action => {
      return ["put", "post", "patch"].includes(action.method);
    };

    const refreshInterceptor = (env, options) => {
      const refreshToken = getRefreshToken(env);

      return async failedRequest => {
        const {
          accessToken: newAccessToken,
          refreshToken: newRefreshToken
        } = await requestToken(axios$1, {
          url: options.tokenUrl,
          grant_type: "refresh_token",
          client_id: options.clientId,
          client_secret: options.clientSecret,
          refresh_token: refreshToken
        });

        if (newAccessToken) {
          token.set(newAccessToken);
          setToken(env, newAccessToken);
        }

        if (newRefreshToken) {
          setRefreshToken(env, newRefreshToken);
        }

        failedRequest.response.config.headers[
          "Authorization"
        ] = `Bearer ${newAccessToken}`;
      };
    };

    const sendRequest = (
      env,
      environment,
      action,
      { headers, parameters, body }
    ) => {
      const client = axios$1.create({
        baseURL: environment.url
      });

      const options = {
        method: action.method,
        headers: populate(headers)
      };

      if (environment.auth) {
        switch (environment.auth.name) {
          case "basic":
            options.auth = environment.auth.options;
            break;
          case "apikey":
            options.headers[environment.auth.options.header] =
              environment.auth.options.key;
            break;
          case "oauth2":
            options.headers["Authorization"] = `Bearer ${getToken(env)}`;
            break;
        }
      }

      const expandedUrl = expandUrl(action.pathTemplate, populate(parameters));
      const destUrl = urlParse(expandedUrl, true);

      options.params = destUrl.query;
      options.url = destUrl.pathname;

      if (allowBody(action)) {
        options.data = body;
      }

      if (isAuth(environment, "oauth2")) {
        createAuthRefreshInterceptor(
          client,
          refreshInterceptor(env, environment.auth.options)
        );
      }

      return client.request(options);
    };

    const copyUrl = (url, parameters) => {
      const expandedUrl = expandUrl(url.pathname, populate(parameters));

      clipboardCopy_1(url.origin + expandedUrl);
    };

    const getEnv = () => store2.get("env");

    /* node_modules/snowboard/templates/winter/components/MenuItem.svelte generated by Svelte v3.15.0 */

    function add_css() {
    	var style = element("style");
    	style.id = "svelte-39af3j-style";
    	style.textContent = ".tag.svelte-39af3j{width:3.5rem}.menu-ellipsis.svelte-39af3j{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;padding:0.25em 0.75em}.menu-action.svelte-39af3j{vertical-align:middle}";
    	append(document.head, style);
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	return child_ctx;
    }

    // (30:0) {#if title}
    function create_if_block_1(ctx) {
    	let li;
    	let a0;
    	let t0;
    	let a0_data_slug_value;
    	let a0_href_value;
    	let t1;
    	let a1;
    	let span;
    	let i;
    	let dispose;

    	return {
    		c() {
    			li = element("li");
    			a0 = element("a");
    			t0 = text(ctx.title);
    			t1 = space();
    			a1 = element("a");
    			span = element("span");
    			i = element("i");
    			attr(a0, "data-slug", a0_data_slug_value = slugify(ctx.title));
    			attr(a0, "href", a0_href_value = "#/g~" + slugify(ctx.title));
    			attr(a0, "class", "is-inline-block");
    			attr(i, "class", "fas");
    			toggle_class(i, "fa-chevron-right", ctx.hidden);
    			toggle_class(i, "fa-chevron-down", !ctx.hidden);
    			attr(span, "class", "icon is-small has-text-grey-light");
    			attr(a1, "href", "javascript:void(0)");
    			attr(a1, "class", "is-inline-block is-pulled-right");

    			dispose = [
    				listen(a0, "click", ctx.handleGroupClick),
    				listen(a1, "click", ctx.click_handler)
    			];
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a0);
    			append(a0, t0);
    			append(li, t1);
    			append(li, a1);
    			append(a1, span);
    			append(span, i);
    		},
    		p(changed, ctx) {
    			if (changed.title) set_data(t0, ctx.title);

    			if (changed.title && a0_data_slug_value !== (a0_data_slug_value = slugify(ctx.title))) {
    				attr(a0, "data-slug", a0_data_slug_value);
    			}

    			if (changed.title && a0_href_value !== (a0_href_value = "#/g~" + slugify(ctx.title))) {
    				attr(a0, "href", a0_href_value);
    			}

    			if (changed.hidden) {
    				toggle_class(i, "fa-chevron-right", ctx.hidden);
    			}

    			if (changed.hidden) {
    				toggle_class(i, "fa-chevron-down", !ctx.hidden);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			run_all(dispose);
    		}
    	};
    }

    // (53:0) {#if actions.length > 0}
    function create_if_block(ctx) {
    	let li;
    	let ul;
    	let each_value = ctx.actions;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	return {
    		c() {
    			li = element("li");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			toggle_class(li, "is-hidden", ctx.hidden);
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			append(li, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p(changed, ctx) {
    			if (changed.actions || changed.currentSlug || changed.handleClick || changed.colorize) {
    				each_value = ctx.actions;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (changed.hidden) {
    				toggle_class(li, "is-hidden", ctx.hidden);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (56:6) {#each actions as action}
    function create_each_block(ctx) {
    	let li;
    	let a;
    	let code;
    	let t0_value = ctx.action.method + "";
    	let t0;
    	let code_class_value;
    	let t1;
    	let span;
    	let t2_value = ctx.action.title + "";
    	let t2;
    	let a_data_slug_value;
    	let a_href_value;
    	let t3;
    	let dispose;

    	return {
    		c() {
    			li = element("li");
    			a = element("a");
    			code = element("code");
    			t0 = text(t0_value);
    			t1 = space();
    			span = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			attr(code, "class", code_class_value = "tag " + colorize(ctx.action.method) + " is-uppercase" + " svelte-39af3j");
    			attr(span, "class", "menu-action svelte-39af3j");
    			attr(a, "data-slug", a_data_slug_value = ctx.action.slug);
    			attr(a, "href", a_href_value = "#/" + ctx.action.slug);
    			attr(a, "class", "menu-ellipsis svelte-39af3j");
    			toggle_class(a, "is-active", ctx.action.slug === ctx.currentSlug);
    			dispose = listen(a, "click", ctx.handleClick);
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, code);
    			append(code, t0);
    			append(a, t1);
    			append(a, span);
    			append(span, t2);
    			append(li, t3);
    		},
    		p(changed, ctx) {
    			if (changed.actions && t0_value !== (t0_value = ctx.action.method + "")) set_data(t0, t0_value);

    			if (changed.actions && code_class_value !== (code_class_value = "tag " + colorize(ctx.action.method) + " is-uppercase" + " svelte-39af3j")) {
    				attr(code, "class", code_class_value);
    			}

    			if (changed.actions && t2_value !== (t2_value = ctx.action.title + "")) set_data(t2, t2_value);

    			if (changed.actions && a_data_slug_value !== (a_data_slug_value = ctx.action.slug)) {
    				attr(a, "data-slug", a_data_slug_value);
    			}

    			if (changed.actions && a_href_value !== (a_href_value = "#/" + ctx.action.slug)) {
    				attr(a, "href", a_href_value);
    			}

    			if (changed.actions || changed.currentSlug) {
    				toggle_class(a, "is-active", ctx.action.slug === ctx.currentSlug);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			dispose();
    		}
    	};
    }

    function create_fragment(ctx) {
    	let t;
    	let if_block1_anchor;
    	let if_block0 = ctx.title && create_if_block_1(ctx);
    	let if_block1 = ctx.actions.length > 0 && create_if_block(ctx);

    	return {
    		c() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    		},
    		p(changed, ctx) {
    			if (ctx.title) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.actions.length > 0) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach(if_block1_anchor);
    		}
    	};
    }

    function instance($$self, $$props, $$invalidate) {
    	let { title } = $$props;
    	let { actions } = $$props;
    	let { currentSlug } = $$props;
    	let { hidden = false } = $$props;
    	let { handleClick } = $$props;
    	let { handleGroupClick } = $$props;
    	const click_handler = () => $$invalidate("hidden", hidden = !hidden);

    	$$self.$set = $$props => {
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("actions" in $$props) $$invalidate("actions", actions = $$props.actions);
    		if ("currentSlug" in $$props) $$invalidate("currentSlug", currentSlug = $$props.currentSlug);
    		if ("hidden" in $$props) $$invalidate("hidden", hidden = $$props.hidden);
    		if ("handleClick" in $$props) $$invalidate("handleClick", handleClick = $$props.handleClick);
    		if ("handleGroupClick" in $$props) $$invalidate("handleGroupClick", handleGroupClick = $$props.handleGroupClick);
    	};

    	return {
    		title,
    		actions,
    		currentSlug,
    		hidden,
    		handleClick,
    		handleGroupClick,
    		click_handler
    	};
    }

    class MenuItem extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-39af3j-style")) add_css();

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			title: 0,
    			actions: 0,
    			currentSlug: 0,
    			hidden: 0,
    			handleClick: 0,
    			handleGroupClick: 0
    		});
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/MenuPanel.svelte generated by Svelte v3.15.0 */

    function add_css$1() {
    	var style = element("style");
    	style.id = "svelte-fvssqr-style";
    	style.textContent = ".hero.svelte-fvssqr,.menu-wrapper.svelte-fvssqr{padding:0 2.75rem 0 2rem}.hero.svelte-fvssqr{position:sticky;top:54px;background-color:#fafafa;margin-bottom:1.5rem}.hero.is-darkmode.svelte-fvssqr{background-color:#000}.hero-body.svelte-fvssqr{padding:1.5rem 0;box-shadow:0 2px 0 0 #f5f5f5}.hero-body.is-darkmode.svelte-fvssqr{box-shadow:0 2px 0 0 #363636}.menu-wrapper.svelte-fvssqr::-webkit-scrollbar{display:none}@media screen and (min-width: 768px){.hero.svelte-fvssqr,.menu-wrapper.svelte-fvssqr{width:-moz-calc(25% - 0.5rem);width:-webkit-calc(25% - 0.5rem);width:-o-calc(25% - 0.5rem);width:calc(25% - 0.5rem)}.hero.svelte-fvssqr{position:fixed;padding:0 1.25rem}.menu-wrapper.svelte-fvssqr{position:fixed;top:140px;padding:1.5rem 1.25rem 1.25rem;height:-moz-calc(100% - 150px - 2.5rem);height:-webkit-calc(100% - 150px - 2.5rem);height:-o-calc(100% - 150px - 2.5rem);height:calc(100% - 150px - 2.5rem);overflow:-moz-scrollbars-none;-ms-overflow-style:none;overflow-x:hidden;overflow-y:auto;transition:opacity 0.3s, left 0.3s}.menu.is-collapsed.svelte-fvssqr{width:3rem}.is-collapsed.svelte-fvssqr .hero.svelte-fvssqr,.is-collapsed.svelte-fvssqr .hero-body.svelte-fvssqr{width:calc(3rem - 2px)}.is-collapsed.svelte-fvssqr .hero.svelte-fvssqr{padding-left:0;padding-right:0}.is-collapsed.svelte-fvssqr .hero-body.svelte-fvssqr{padding-left:0.3175rem;padding-right:0.3175rem;box-shadow:none}.is-collapsed.svelte-fvssqr .input.is-rounded.svelte-fvssqr{padding-left:0;padding-right:0;opacity:0}.is-collapsed.svelte-fvssqr .icon-input-search.svelte-fvssqr{color:#b5b5b5;background-color:#eee;-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;cursor:pointer;pointer-events:auto}.is-collapsed.svelte-fvssqr .icon-input-search.svelte-fvssqr:hover{color:#999;background-color:#e0e0e0}.is-collapsed.svelte-fvssqr .is-darkmode .icon-input-search.svelte-fvssqr{color:#ccc;background-color:#484848}.is-collapsed.svelte-fvssqr .is-darkmode .icon-input-search.svelte-fvssqr:hover{color:#fff;background-color:#484848}.is-collapsed.svelte-fvssqr .menu-wrapper.svelte-fvssqr{left:-30%;opacity:0}}";
    	append(document.head, style);
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.child = list[i];
    	return child_ctx;
    }

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tag = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.header = list[i];
    	return child_ctx;
    }

    // (165:4) {#if query === ''}
    function create_if_block_1$1(ctx) {
    	let ul;
    	let li;
    	let a;
    	let t0;
    	let a_href_value;
    	let t1;
    	let dispose;
    	let if_block = ctx.tagHeaders && create_if_block_2(ctx);

    	return {
    		c() {
    			ul = element("ul");
    			li = element("li");
    			a = element("a");
    			t0 = text("Introduction");
    			t1 = space();
    			if (if_block) if_block.c();
    			attr(a, "href", a_href_value = basePath(ctx.config));
    			attr(ul, "class", "menu-list");
    			dispose = listen(a, "click", prevent_default(ctx.tocClick));
    		},
    		m(target, anchor) {
    			insert(target, ul, anchor);
    			append(ul, li);
    			append(li, a);
    			append(a, t0);
    			append(ul, t1);
    			if (if_block) if_block.m(ul, null);
    		},
    		p(changed, ctx) {
    			if (changed.config && a_href_value !== (a_href_value = basePath(ctx.config))) {
    				attr(a, "href", a_href_value);
    			}

    			if (ctx.tagHeaders) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					if_block.m(ul, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(ul);
    			if (if_block) if_block.d();
    			dispose();
    		}
    	};
    }

    // (172:8) {#if tagHeaders}
    function create_if_block_2(ctx) {
    	let li;
    	let ul;
    	let each_value_2 = ctx.tagHeaders;
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	return {
    		c() {
    			li = element("li");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			append(li, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p(changed, ctx) {
    			if (changed.tagHeaders || changed.headerLink || changed.tocClick) {
    				each_value_2 = ctx.tagHeaders;
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (176:16) {#if header.level === 0}
    function create_if_block_3(ctx) {
    	let li;
    	let a;
    	let t0_value = ctx.header.text + "";
    	let t0;
    	let a_href_value;
    	let t1;
    	let dispose;

    	return {
    		c() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(a, "href", a_href_value = "#" + headerLink(ctx.header.text));
    			dispose = listen(a, "click", ctx.tocClick);
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t0);
    			append(li, t1);
    		},
    		p(changed, ctx) {
    			if (changed.tagHeaders && t0_value !== (t0_value = ctx.header.text + "")) set_data(t0, t0_value);

    			if (changed.tagHeaders && a_href_value !== (a_href_value = "#" + headerLink(ctx.header.text))) {
    				attr(a, "href", a_href_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			dispose();
    		}
    	};
    }

    // (175:14) {#each tagHeaders as header}
    function create_each_block_2(ctx) {
    	let if_block_anchor;
    	let if_block = ctx.header.level === 0 && create_if_block_3(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(changed, ctx) {
    			if (ctx.header.level === 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (191:6) {#if tag.title}
    function create_if_block$1(ctx) {
    	let p;
    	let t_value = ctx.tag.title + "";
    	let t;

    	return {
    		c() {
    			p = element("p");
    			t = text(t_value);
    			attr(p, "class", "menu-label");
    		},
    		m(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t);
    		},
    		p(changed, ctx) {
    			if (changed.filteredActions && t_value !== (t_value = ctx.tag.title + "")) set_data(t, t_value);
    		},
    		d(detaching) {
    			if (detaching) detach(p);
    		}
    	};
    }

    // (196:8) {#each tag.children as child}
    function create_each_block_1(ctx) {
    	let current;

    	const menuitem = new MenuItem({
    			props: {
    				title: ctx.child.title,
    				actions: ctx.child.actions,
    				hidden: ctx.actionsCount > 50,
    				currentSlug: ctx.currentSlug,
    				handleClick: ctx.handleClick,
    				handleGroupClick: ctx.handleGroupClick
    			}
    		});

    	return {
    		c() {
    			create_component(menuitem.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(menuitem, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const menuitem_changes = {};
    			if (changed.filteredActions) menuitem_changes.title = ctx.child.title;
    			if (changed.filteredActions) menuitem_changes.actions = ctx.child.actions;
    			if (changed.actionsCount) menuitem_changes.hidden = ctx.actionsCount > 50;
    			if (changed.currentSlug) menuitem_changes.currentSlug = ctx.currentSlug;
    			if (changed.handleClick) menuitem_changes.handleClick = ctx.handleClick;
    			if (changed.handleGroupClick) menuitem_changes.handleGroupClick = ctx.handleGroupClick;
    			menuitem.$set(menuitem_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(menuitem.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(menuitem.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(menuitem, detaching);
    		}
    	};
    }

    // (190:4) {#each filteredActions as tag}
    function create_each_block$1(ctx) {
    	let t0;
    	let ul;
    	let t1;
    	let current;
    	let if_block = ctx.tag.title && create_if_block$1(ctx);
    	let each_value_1 = ctx.tag.children;
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			if (if_block) if_block.c();
    			t0 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			attr(ul, "class", "menu-list");
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, t0, anchor);
    			insert(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append(ul, t1);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (ctx.tag.title) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.filteredActions || changed.actionsCount || changed.currentSlug || changed.handleClick || changed.handleGroupClick) {
    				each_value_1 = ctx.tag.children;
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, t1);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(t0);
    			if (detaching) detach(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    function create_fragment$1(ctx) {
    	let aside;
    	let section;
    	let div1;
    	let div0;
    	let p0;
    	let input;
    	let t0;
    	let span;
    	let t1;
    	let div2;
    	let p1;
    	let t3;
    	let t4;
    	let current;
    	let dispose;
    	let if_block = ctx.query === "" && create_if_block_1$1(ctx);
    	let each_value = ctx.filteredActions;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			aside = element("aside");
    			section = element("section");
    			div1 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			input = element("input");
    			t0 = space();
    			span = element("span");
    			span.innerHTML = `<i class="fas fa-search"></i>`;
    			t1 = space();
    			div2 = element("div");
    			p1 = element("p");
    			p1.textContent = "API";
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(input, "id", "search-input-text");
    			attr(input, "class", "input is-rounded svelte-fvssqr");
    			attr(input, "placeholder", "Filter by path, method, and title...");
    			attr(span, "class", "icon is-right icon-input-search svelte-fvssqr");
    			attr(p0, "class", "control has-icons-right");
    			attr(div0, "class", "field");
    			attr(div1, "class", "hero-body svelte-fvssqr");
    			toggle_class(div1, "is-darkmode", ctx.isDarkmode);
    			attr(section, "class", "hero is-sticky svelte-fvssqr");
    			toggle_class(section, "is-darkmode", ctx.isDarkmode);
    			attr(p1, "class", "menu-label");
    			attr(div2, "class", "menu-wrapper svelte-fvssqr");
    			attr(aside, "class", "menu svelte-fvssqr");
    			toggle_class(aside, "is-collapsed", ctx.isCollapsed);

    			dispose = [
    				listen(input, "input", ctx.input_input_handler),
    				listen(span, "click", ctx.searchClick)
    			];
    		},
    		m(target, anchor) {
    			insert(target, aside, anchor);
    			append(aside, section);
    			append(section, div1);
    			append(div1, div0);
    			append(div0, p0);
    			append(p0, input);
    			set_input_value(input, ctx.query);
    			append(p0, t0);
    			append(p0, span);
    			append(aside, t1);
    			append(aside, div2);
    			append(div2, p1);
    			append(div2, t3);
    			if (if_block) if_block.m(div2, null);
    			append(div2, t4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			current = true;
    		},
    		p(changed, ctx) {
    			if (changed.query && input.value !== ctx.query) {
    				set_input_value(input, ctx.query);
    			}

    			if (changed.isDarkmode) {
    				toggle_class(div1, "is-darkmode", ctx.isDarkmode);
    			}

    			if (changed.isDarkmode) {
    				toggle_class(section, "is-darkmode", ctx.isDarkmode);
    			}

    			if (ctx.query === "") {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					if_block.m(div2, t4);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.filteredActions || changed.actionsCount || changed.currentSlug || changed.handleClick || changed.handleGroupClick) {
    				each_value = ctx.filteredActions;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (changed.isCollapsed) {
    				toggle_class(aside, "is-collapsed", ctx.isCollapsed);
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(aside);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    			run_all(dispose);
    		}
    	};
    }

    function headerLink(text) {
    	return text.toLowerCase().replace(/\s/g, "-");
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { config = {} } = $$props;
    	let { tagActions = [] } = $$props;
    	let { tagHeaders = [] } = $$props;
    	let { currentSlug } = $$props;
    	let { actionsCount } = $$props;
    	let { isCollapsed } = $$props;
    	let { isDarkmode } = $$props;
    	let { handleClick } = $$props;
    	let { handleGroupClick } = $$props;
    	let { tocClick } = $$props;
    	let { searchClick } = $$props;
    	let { query } = $$props;

    	function input_input_handler() {
    		query = this.value;
    		$$invalidate("query", query);
    	}

    	$$self.$set = $$props => {
    		if ("config" in $$props) $$invalidate("config", config = $$props.config);
    		if ("tagActions" in $$props) $$invalidate("tagActions", tagActions = $$props.tagActions);
    		if ("tagHeaders" in $$props) $$invalidate("tagHeaders", tagHeaders = $$props.tagHeaders);
    		if ("currentSlug" in $$props) $$invalidate("currentSlug", currentSlug = $$props.currentSlug);
    		if ("actionsCount" in $$props) $$invalidate("actionsCount", actionsCount = $$props.actionsCount);
    		if ("isCollapsed" in $$props) $$invalidate("isCollapsed", isCollapsed = $$props.isCollapsed);
    		if ("isDarkmode" in $$props) $$invalidate("isDarkmode", isDarkmode = $$props.isDarkmode);
    		if ("handleClick" in $$props) $$invalidate("handleClick", handleClick = $$props.handleClick);
    		if ("handleGroupClick" in $$props) $$invalidate("handleGroupClick", handleGroupClick = $$props.handleGroupClick);
    		if ("tocClick" in $$props) $$invalidate("tocClick", tocClick = $$props.tocClick);
    		if ("searchClick" in $$props) $$invalidate("searchClick", searchClick = $$props.searchClick);
    		if ("query" in $$props) $$invalidate("query", query = $$props.query);
    	};

    	let filteredActions;

    	$$self.$$.update = (changed = { tagActions: 1, query: 1 }) => {
    		if (changed.tagActions || changed.query) {
    			 $$invalidate("filteredActions", filteredActions = filterActions(tagActions, query));
    		}
    	};

    	return {
    		config,
    		tagActions,
    		tagHeaders,
    		currentSlug,
    		actionsCount,
    		isCollapsed,
    		isDarkmode,
    		handleClick,
    		handleGroupClick,
    		tocClick,
    		searchClick,
    		query,
    		filteredActions,
    		input_input_handler
    	};
    }

    class MenuPanel extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-fvssqr-style")) add_css$1();

    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
    			config: 0,
    			tagActions: 0,
    			tagHeaders: 0,
    			currentSlug: 0,
    			actionsCount: 0,
    			isCollapsed: 0,
    			isDarkmode: 0,
    			handleClick: 0,
    			handleGroupClick: 0,
    			tocClick: 0,
    			searchClick: 0,
    			query: 0
    		});
    	}
    }

    /* node_modules/snowboard/templates/winter/tables/HeaderTable.svelte generated by Svelte v3.15.0 */

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.name = list[i].name;
    	child_ctx.example = list[i].example;
    	return child_ctx;
    }

    // (5:0) {#if headers.length > 0}
    function create_if_block$2(ctx) {
    	let table;
    	let thead;
    	let t1;
    	let tbody;
    	let each_value = ctx.headers;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	return {
    		c() {
    			table = element("table");
    			thead = element("thead");
    			thead.innerHTML = `<tr><th colspan="2">Headers</th></tr>`;
    			t1 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(table, "class", "table is-stripped is-fullwidth");
    		},
    		m(target, anchor) {
    			insert(target, table, anchor);
    			append(table, thead);
    			append(table, t1);
    			append(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p(changed, ctx) {
    			if (changed.headers) {
    				each_value = ctx.headers;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (13:6) {#each headers as { name, example }}
    function create_each_block$2(ctx) {
    	let tr;
    	let td0;
    	let t0_value = ctx.name + "";
    	let t0;
    	let t1;
    	let td1;
    	let code;
    	let t2_value = ctx.example + "";
    	let t2;
    	let t3;

    	return {
    		c() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			code = element("code");
    			t2 = text(t2_value);
    			t3 = space();
    		},
    		m(target, anchor) {
    			insert(target, tr, anchor);
    			append(tr, td0);
    			append(td0, t0);
    			append(tr, t1);
    			append(tr, td1);
    			append(td1, code);
    			append(code, t2);
    			append(tr, t3);
    		},
    		p(changed, ctx) {
    			if (changed.headers && t0_value !== (t0_value = ctx.name + "")) set_data(t0, t0_value);
    			if (changed.headers && t2_value !== (t2_value = ctx.example + "")) set_data(t2, t2_value);
    		},
    		d(detaching) {
    			if (detaching) detach(tr);
    		}
    	};
    }

    function create_fragment$2(ctx) {
    	let if_block_anchor;
    	let if_block = ctx.headers.length > 0 && create_if_block$2(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(changed, ctx) {
    			if (ctx.headers.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { headers = [] } = $$props;

    	$$self.$set = $$props => {
    		if ("headers" in $$props) $$invalidate("headers", headers = $$props.headers);
    	};

    	return { headers };
    }

    class HeaderTable extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { headers: 0 });
    	}
    }

    /* node_modules/snowboard/templates/winter/components/CodeBlock.svelte generated by Svelte v3.15.0 */

    function create_if_block$3(ctx) {
    	let pre;
    	let code;
    	let raw_value = highlight(stringify$2(ctx.body), ctx.mime) + "";
    	let code_class_value;
    	let pre_class_value;

    	return {
    		c() {
    			pre = element("pre");
    			code = element("code");
    			attr(code, "class", code_class_value = "language-" + ctx.mime);
    			attr(pre, "class", pre_class_value = "language-" + ctx.mime);
    		},
    		m(target, anchor) {
    			insert(target, pre, anchor);
    			append(pre, code);
    			code.innerHTML = raw_value;
    		},
    		p(changed, ctx) {
    			if ((changed.body || changed.mime) && raw_value !== (raw_value = highlight(stringify$2(ctx.body), ctx.mime) + "")) code.innerHTML = raw_value;;

    			if (changed.mime && code_class_value !== (code_class_value = "language-" + ctx.mime)) {
    				attr(code, "class", code_class_value);
    			}

    			if (changed.mime && pre_class_value !== (pre_class_value = "language-" + ctx.mime)) {
    				attr(pre, "class", pre_class_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(pre);
    		}
    	};
    }

    function create_fragment$3(ctx) {
    	let if_block_anchor;
    	let if_block = ctx.body && create_if_block$3(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(changed, ctx) {
    			if (ctx.body) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { type } = $$props;
    	let { body } = $$props;

    	$$self.$set = $$props => {
    		if ("type" in $$props) $$invalidate("type", type = $$props.type);
    		if ("body" in $$props) $$invalidate("body", body = $$props.body);
    	};

    	let mime;

    	$$self.$$.update = (changed = { type: 1 }) => {
    		if (changed.type) {
    			 $$invalidate("mime", mime = alias(type));
    		}
    	};

    	return { type, body, mime };
    }

    class CodeBlock extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { type: 0, body: 0 });
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/CodePanel.svelte generated by Svelte v3.15.0 */

    function add_css$2() {
    	var style = element("style");
    	style.id = "svelte-15v28ah-style";
    	style.textContent = ".tab-content.svelte-15v28ah{display:none}.tab-content.is-active.svelte-15v28ah{display:block}";
    	append(document.head, style);
    }

    // (32:0) {#if example || schema}
    function create_if_block$4(ctx) {
    	let div2;
    	let div0;
    	let ul;
    	let li0;
    	let a0;
    	let t1;
    	let li1;
    	let a1;
    	let t3;
    	let div1;
    	let section0;
    	let section0_class_value;
    	let t4;
    	let section1;
    	let section1_class_value;
    	let current;
    	let dispose;

    	const codeblock0 = new CodeBlock({
    			props: { type: ctx.contentType, body: ctx.example }
    		});

    	const codeblock1 = new CodeBlock({
    			props: {
    				type: "application/json",
    				body: ctx.schema
    			}
    		});

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Body";
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Schema";
    			t3 = space();
    			div1 = element("div");
    			section0 = element("section");
    			create_component(codeblock0.$$.fragment);
    			t4 = space();
    			section1 = element("section");
    			create_component(codeblock1.$$.fragment);
    			attr(a0, "data-index", "0");
    			attr(a0, "href", "javascript:void(0)");
    			toggle_class(li0, "is-active", ctx.tabIndex === 0);
    			attr(a1, "data-index", "1");
    			attr(a1, "href", "javascript:void(0)");
    			toggle_class(li1, "is-active", ctx.tabIndex === 1);
    			attr(div0, "class", "tabs is-fullwidth");
    			toggle_class(div0, "is-toggle", ctx.asToggle);
    			attr(section0, "class", section0_class_value = "tab-content " + ctx.activeBody + " svelte-15v28ah");
    			attr(section1, "class", section1_class_value = "tab-content " + ctx.activeSchema + " svelte-15v28ah");
    			attr(div2, "class", "tabs-with-content");
    			dispose = [listen(a0, "click", ctx.tabSelect), listen(a1, "click", ctx.tabSelect)];
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div0, ul);
    			append(ul, li0);
    			append(li0, a0);
    			append(ul, t1);
    			append(ul, li1);
    			append(li1, a1);
    			append(div2, t3);
    			append(div2, div1);
    			append(div1, section0);
    			mount_component(codeblock0, section0, null);
    			append(div1, t4);
    			append(div1, section1);
    			mount_component(codeblock1, section1, null);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (changed.tabIndex) {
    				toggle_class(li0, "is-active", ctx.tabIndex === 0);
    			}

    			if (changed.tabIndex) {
    				toggle_class(li1, "is-active", ctx.tabIndex === 1);
    			}

    			if (changed.asToggle) {
    				toggle_class(div0, "is-toggle", ctx.asToggle);
    			}

    			const codeblock0_changes = {};
    			if (changed.contentType) codeblock0_changes.type = ctx.contentType;
    			if (changed.example) codeblock0_changes.body = ctx.example;
    			codeblock0.$set(codeblock0_changes);

    			if (!current || changed.activeBody && section0_class_value !== (section0_class_value = "tab-content " + ctx.activeBody + " svelte-15v28ah")) {
    				attr(section0, "class", section0_class_value);
    			}

    			const codeblock1_changes = {};
    			if (changed.schema) codeblock1_changes.body = ctx.schema;
    			codeblock1.$set(codeblock1_changes);

    			if (!current || changed.activeSchema && section1_class_value !== (section1_class_value = "tab-content " + ctx.activeSchema + " svelte-15v28ah")) {
    				attr(section1, "class", section1_class_value);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(codeblock0.$$.fragment, local);
    			transition_in(codeblock1.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(codeblock0.$$.fragment, local);
    			transition_out(codeblock1.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_component(codeblock0);
    			destroy_component(codeblock1);
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$4(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (ctx.example || ctx.schema) && create_if_block$4(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (ctx.example || ctx.schema) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { contentType } = $$props;
    	let { example } = $$props;
    	let { schema } = $$props;
    	let { asToggle } = $$props;
    	let activeBody = "is-active";
    	let activeSchema = "";
    	let tabIndex = 0;

    	const tabSelect = event => {
    		const index = event.target.dataset["index"];
    		$$invalidate("tabIndex", tabIndex = parseInt(index, 10));
    	};

    	$$self.$set = $$props => {
    		if ("contentType" in $$props) $$invalidate("contentType", contentType = $$props.contentType);
    		if ("example" in $$props) $$invalidate("example", example = $$props.example);
    		if ("schema" in $$props) $$invalidate("schema", schema = $$props.schema);
    		if ("asToggle" in $$props) $$invalidate("asToggle", asToggle = $$props.asToggle);
    	};

    	$$self.$$.update = (changed = { tabIndex: 1 }) => {
    		if (changed.tabIndex) {
    			 $$invalidate("activeBody", activeBody = tabIndex === 0 ? "is-active" : "");
    		}

    		if (changed.tabIndex) {
    			 $$invalidate("activeSchema", activeSchema = tabIndex === 1 ? "is-active" : "");
    		}
    	};

    	return {
    		contentType,
    		example,
    		schema,
    		asToggle,
    		activeBody,
    		activeSchema,
    		tabIndex,
    		tabSelect
    	};
    }

    class CodePanel extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-15v28ah-style")) add_css$2();

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			contentType: 0,
    			example: 0,
    			schema: 0,
    			asToggle: 0,
    			tabSelect: 0
    		});
    	}

    	get tabSelect() {
    		return this.$$.ctx.tabSelect;
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/RequestPanel.svelte generated by Svelte v3.15.0 */

    function create_if_block_1$2(ctx) {
    	let div;
    	let raw_value = markdown(ctx.description) + "";

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "content");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p(changed, ctx) {
    			if (changed.description && raw_value !== (raw_value = markdown(ctx.description) + "")) div.innerHTML = raw_value;;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (26:0) {#if showRequest}
    function create_if_block$5(ctx) {
    	let hr;

    	return {
    		c() {
    			hr = element("hr");
    		},
    		m(target, anchor) {
    			insert(target, hr, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(hr);
    		}
    	};
    }

    function create_fragment$5(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = ctx.description && create_if_block_1$2(ctx);
    	const headertable = new HeaderTable({ props: { headers: ctx.headers } });

    	const codepanel = new CodePanel({
    			props: {
    				contentType: ctx.contentType,
    				example: ctx.example,
    				schema: ctx.schema,
    				asToggle: true
    			}
    		});

    	let if_block1 = ctx.showRequest && create_if_block$5(ctx);

    	return {
    		c() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			create_component(headertable.$$.fragment);
    			t1 = space();
    			create_component(codepanel.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t0, anchor);
    			mount_component(headertable, target, anchor);
    			insert(target, t1, anchor);
    			mount_component(codepanel, target, anchor);
    			insert(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (ctx.description) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const headertable_changes = {};
    			if (changed.headers) headertable_changes.headers = ctx.headers;
    			headertable.$set(headertable_changes);
    			const codepanel_changes = {};
    			if (changed.contentType) codepanel_changes.contentType = ctx.contentType;
    			if (changed.example) codepanel_changes.example = ctx.example;
    			if (changed.schema) codepanel_changes.schema = ctx.schema;
    			codepanel.$set(codepanel_changes);

    			if (ctx.showRequest) {
    				if (!if_block1) {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				} else {
    					
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(headertable.$$.fragment, local);
    			transition_in(codepanel.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(headertable.$$.fragment, local);
    			transition_out(codepanel.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach(t0);
    			destroy_component(headertable, detaching);
    			if (detaching) detach(t1);
    			destroy_component(codepanel, detaching);
    			if (detaching) detach(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach(if_block1_anchor);
    		}
    	};
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { description } = $$props;
    	let { headers } = $$props;
    	let { contentType } = $$props;
    	let { example } = $$props;
    	let { schema } = $$props;

    	$$self.$set = $$props => {
    		if ("description" in $$props) $$invalidate("description", description = $$props.description);
    		if ("headers" in $$props) $$invalidate("headers", headers = $$props.headers);
    		if ("contentType" in $$props) $$invalidate("contentType", contentType = $$props.contentType);
    		if ("example" in $$props) $$invalidate("example", example = $$props.example);
    		if ("schema" in $$props) $$invalidate("schema", schema = $$props.schema);
    	};

    	let showRequest;

    	$$self.$$.update = (changed = { description: 1, headers: 1, example: 1 }) => {
    		if (changed.description || changed.headers || changed.example) {
    			 $$invalidate("showRequest", showRequest = !!(description || headers.length !== 0 || example));
    		}
    	};

    	return {
    		description,
    		headers,
    		contentType,
    		example,
    		schema,
    		showRequest
    	};
    }

    class RequestPanel extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			description: 0,
    			headers: 0,
    			contentType: 0,
    			example: 0,
    			schema: 0
    		});
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/ResponsePanel.svelte generated by Svelte v3.15.0 */

    function create_if_block_1$3(ctx) {
    	let t;

    	return {
    		c() {
    			t = text(ctx.title);
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p(changed, ctx) {
    			if (changed.title) set_data(t, ctx.title);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (29:4) {#if description}
    function create_if_block$6(ctx) {
    	let div;
    	let raw_value = markdown(ctx.description) + "";

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "content");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p(changed, ctx) {
    			if (changed.description && raw_value !== (raw_value = markdown(ctx.description) + "")) div.innerHTML = raw_value;;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function create_fragment$6(ctx) {
    	let div1;
    	let header;
    	let p;
    	let t0;
    	let t1;
    	let a;
    	let span;
    	let t2_value = (ctx.contentType || "") + "";
    	let t2;
    	let t3;
    	let code;
    	let t4;
    	let code_class_value;
    	let t5;
    	let div0;
    	let t6;
    	let t7;
    	let current;
    	let if_block0 = ctx.title && create_if_block_1$3(ctx);
    	let if_block1 = ctx.description && create_if_block$6(ctx);
    	const headertable = new HeaderTable({ props: { headers: ctx.headers } });

    	const codepanel = new CodePanel({
    			props: {
    				contentType: ctx.contentType,
    				example: ctx.example,
    				schema: ctx.schema
    			}
    		});

    	return {
    		c() {
    			div1 = element("div");
    			header = element("header");
    			p = element("p");
    			t0 = text("Response\n      ");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			a = element("a");
    			span = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			code = element("code");
    			t4 = text(ctx.statusCode);
    			t5 = space();
    			div0 = element("div");
    			if (if_block1) if_block1.c();
    			t6 = space();
    			create_component(headertable.$$.fragment);
    			t7 = space();
    			create_component(codepanel.$$.fragment);
    			attr(p, "class", "card-header-title");
    			attr(span, "class", "tag is-medium is-white");
    			attr(code, "class", code_class_value = "tag is-medium " + colorize(ctx.statusCode));
    			attr(a, "href", "javascript:void(0)");
    			attr(a, "class", "card-header-icon is-family-code");
    			attr(header, "class", "card-header");
    			attr(div0, "class", "card-content");
    			attr(div1, "class", "card");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, header);
    			append(header, p);
    			append(p, t0);
    			if (if_block0) if_block0.m(p, null);
    			append(header, t1);
    			append(header, a);
    			append(a, span);
    			append(span, t2);
    			append(a, t3);
    			append(a, code);
    			append(code, t4);
    			append(div1, t5);
    			append(div1, div0);
    			if (if_block1) if_block1.m(div0, null);
    			append(div0, t6);
    			mount_component(headertable, div0, null);
    			append(div0, t7);
    			mount_component(codepanel, div0, null);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (ctx.title) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(p, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((!current || changed.contentType) && t2_value !== (t2_value = (ctx.contentType || "") + "")) set_data(t2, t2_value);
    			if (!current || changed.statusCode) set_data(t4, ctx.statusCode);

    			if (!current || changed.statusCode && code_class_value !== (code_class_value = "tag is-medium " + colorize(ctx.statusCode))) {
    				attr(code, "class", code_class_value);
    			}

    			if (ctx.description) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					if_block1.m(div0, t6);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const headertable_changes = {};
    			if (changed.headers) headertable_changes.headers = ctx.headers;
    			headertable.$set(headertable_changes);
    			const codepanel_changes = {};
    			if (changed.contentType) codepanel_changes.contentType = ctx.contentType;
    			if (changed.example) codepanel_changes.example = ctx.example;
    			if (changed.schema) codepanel_changes.schema = ctx.schema;
    			codepanel.$set(codepanel_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(headertable.$$.fragment, local);
    			transition_in(codepanel.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(headertable.$$.fragment, local);
    			transition_out(codepanel.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(headertable);
    			destroy_component(codepanel);
    		}
    	};
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { title } = $$props;
    	let { description } = $$props;
    	let { headers } = $$props;
    	let { statusCode } = $$props;
    	let { contentType } = $$props;
    	let { example } = $$props;
    	let { schema } = $$props;

    	$$self.$set = $$props => {
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("description" in $$props) $$invalidate("description", description = $$props.description);
    		if ("headers" in $$props) $$invalidate("headers", headers = $$props.headers);
    		if ("statusCode" in $$props) $$invalidate("statusCode", statusCode = $$props.statusCode);
    		if ("contentType" in $$props) $$invalidate("contentType", contentType = $$props.contentType);
    		if ("example" in $$props) $$invalidate("example", example = $$props.example);
    		if ("schema" in $$props) $$invalidate("schema", schema = $$props.schema);
    	};

    	return {
    		title,
    		description,
    		headers,
    		statusCode,
    		contentType,
    		example,
    		schema
    	};
    }

    class ResponsePanel extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			title: 0,
    			description: 0,
    			headers: 0,
    			statusCode: 0,
    			contentType: 0,
    			example: 0,
    			schema: 0
    		});
    	}
    }

    /* node_modules/snowboard/templates/winter/tables/ParameterTable.svelte generated by Svelte v3.15.0 */

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.name = list[i].name;
    	child_ctx.example = list[i].example;
    	child_ctx.required = list[i].required;
    	child_ctx.description = list[i].description;
    	child_ctx.schema = list[i].schema;
    	return child_ctx;
    }

    // (36:10) {:else}
    function create_else_block(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.textContent = "-";
    			attr(div, "class", "content");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (32:10) {#if description}
    function create_if_block_2$1(ctx) {
    	let div;
    	let raw_value = markdown(ctx.description) + "";

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "content");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p(changed, ctx) {
    			if (changed.parameters && raw_value !== (raw_value = markdown(ctx.description) + "")) div.innerHTML = raw_value;;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (40:10) {#if example}
    function create_if_block_1$4(ctx) {
    	let div;
    	let span;
    	let t1;
    	let code;
    	let t2_value = ctx.example + "";
    	let t2;

    	return {
    		c() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Example:";
    			t1 = space();
    			code = element("code");
    			t2 = text(t2_value);
    			attr(code, "class", "tag");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			append(div, t1);
    			append(div, code);
    			append(code, t2);
    		},
    		p(changed, ctx) {
    			if (changed.parameters && t2_value !== (t2_value = ctx.example + "")) set_data(t2, t2_value);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (47:10) {#if schema.enum}
    function create_if_block$7(ctx) {
    	let div;
    	let span;
    	let t1;
    	let code;
    	let t2_value = ctx.schema.enum + "";
    	let t2;

    	return {
    		c() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Values:";
    			t1 = space();
    			code = element("code");
    			t2 = text(t2_value);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			append(div, t1);
    			append(div, code);
    			append(code, t2);
    		},
    		p(changed, ctx) {
    			if (changed.parameters && t2_value !== (t2_value = ctx.schema.enum + "")) set_data(t2, t2_value);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (15:4) {#each parameters as { name, example, required, description, schema }}
    function create_each_block$3(ctx) {
    	let tr;
    	let td0;
    	let code;
    	let t0_value = ctx.name + "";
    	let t0;
    	let t1;
    	let td1;
    	let div;
    	let span0;
    	let t2_value = ctx.schema.type + "";
    	let t2;
    	let t3;
    	let span1;
    	let t4_value = (ctx.required ? "required" : "optional") + "";
    	let t4;
    	let t5;
    	let td2;
    	let t6;
    	let t7;
    	let t8;

    	function select_block_type(changed, ctx) {
    		if (ctx.description) return create_if_block_2$1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(null, ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = ctx.example && create_if_block_1$4(ctx);
    	let if_block2 = ctx.schema.enum && create_if_block$7(ctx);

    	return {
    		c() {
    			tr = element("tr");
    			td0 = element("td");
    			code = element("code");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			div = element("div");
    			span0 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span1 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			td2 = element("td");
    			if_block0.c();
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			if (if_block2) if_block2.c();
    			t8 = space();
    			attr(span0, "class", "tag");
    			attr(span1, "class", "tag");
    			toggle_class(span1, "is-dark", ctx.required);
    			toggle_class(span1, "is-white", !ctx.required);
    			attr(div, "class", "tags has-addons");
    		},
    		m(target, anchor) {
    			insert(target, tr, anchor);
    			append(tr, td0);
    			append(td0, code);
    			append(code, t0);
    			append(tr, t1);
    			append(tr, td1);
    			append(td1, div);
    			append(div, span0);
    			append(span0, t2);
    			append(div, t3);
    			append(div, span1);
    			append(span1, t4);
    			append(tr, t5);
    			append(tr, td2);
    			if_block0.m(td2, null);
    			append(td2, t6);
    			if (if_block1) if_block1.m(td2, null);
    			append(td2, t7);
    			if (if_block2) if_block2.m(td2, null);
    			append(tr, t8);
    		},
    		p(changed, ctx) {
    			if (changed.parameters && t0_value !== (t0_value = ctx.name + "")) set_data(t0, t0_value);
    			if (changed.parameters && t2_value !== (t2_value = ctx.schema.type + "")) set_data(t2, t2_value);
    			if (changed.parameters && t4_value !== (t4_value = (ctx.required ? "required" : "optional") + "")) set_data(t4, t4_value);

    			if (changed.parameters) {
    				toggle_class(span1, "is-dark", ctx.required);
    			}

    			if (changed.parameters) {
    				toggle_class(span1, "is-white", !ctx.required);
    			}

    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block0) {
    				if_block0.p(changed, ctx);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(td2, t6);
    				}
    			}

    			if (ctx.example) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_1$4(ctx);
    					if_block1.c();
    					if_block1.m(td2, t7);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (ctx.schema.enum) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block$7(ctx);
    					if_block2.c();
    					if_block2.m(td2, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(tr);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};
    }

    function create_fragment$7(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th;
    	let t0;
    	let t1;
    	let tbody;
    	let each_value = ctx.parameters;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	return {
    		c() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th = element("th");
    			t0 = text(ctx.title);
    			t1 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(th, "colspan", "3");
    			attr(table, "class", "table table-bordered is-bordered is-fullwidth");
    		},
    		m(target, anchor) {
    			insert(target, table, anchor);
    			append(table, thead);
    			append(thead, tr);
    			append(tr, th);
    			append(th, t0);
    			append(table, t1);
    			append(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p(changed, ctx) {
    			if (changed.title) set_data(t0, ctx.title);

    			if (changed.parameters || changed.markdown) {
    				each_value = ctx.parameters;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { title } = $$props;
    	let { parameters } = $$props;

    	$$self.$set = $$props => {
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("parameters" in $$props) $$invalidate("parameters", parameters = $$props.parameters);
    	};

    	return { title, parameters };
    }

    class ParameterTable extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { title: 0, parameters: 0 });
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/ParameterPanel.svelte generated by Svelte v3.15.0 */

    function create_if_block_1$5(ctx) {
    	let current;

    	const parametertable = new ParameterTable({
    			props: {
    				parameters: ctx.pathParameters,
    				title: "Path Parameters"
    			}
    		});

    	return {
    		c() {
    			create_component(parametertable.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(parametertable, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const parametertable_changes = {};
    			if (changed.pathParameters) parametertable_changes.parameters = ctx.pathParameters;
    			parametertable.$set(parametertable_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(parametertable.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(parametertable.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(parametertable, detaching);
    		}
    	};
    }

    // (14:0) {#if queryParameters.length > 0}
    function create_if_block$8(ctx) {
    	let current;

    	const parametertable = new ParameterTable({
    			props: {
    				parameters: ctx.queryParameters,
    				title: "Query Parameters"
    			}
    		});

    	return {
    		c() {
    			create_component(parametertable.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(parametertable, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const parametertable_changes = {};
    			if (changed.queryParameters) parametertable_changes.parameters = ctx.queryParameters;
    			parametertable.$set(parametertable_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(parametertable.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(parametertable.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(parametertable, detaching);
    		}
    	};
    }

    function create_fragment$8(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = ctx.pathParameters.length > 0 && create_if_block_1$5(ctx);
    	let if_block1 = ctx.queryParameters.length > 0 && create_if_block$8(ctx);

    	return {
    		c() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (ctx.pathParameters.length > 0) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_1$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (ctx.queryParameters.length > 0) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach(if_block1_anchor);
    		}
    	};
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { parameters = [] } = $$props;

    	$$self.$set = $$props => {
    		if ("parameters" in $$props) $$invalidate("parameters", parameters = $$props.parameters);
    	};

    	let pathParameters;
    	let queryParameters;

    	$$self.$$.update = (changed = { parameters: 1 }) => {
    		if (changed.parameters) {
    			 $$invalidate("pathParameters", pathParameters = parameters.filter(param => param.location === "path"));
    		}

    		if (changed.parameters) {
    			 $$invalidate("queryParameters", queryParameters = parameters.filter(param => param.location === "query"));
    		}
    	};

    	return {
    		parameters,
    		pathParameters,
    		queryParameters
    	};
    }

    class ParameterPanel extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { parameters: 0 });
    	}
    }

    /* node_modules/snowboard/templates/winter/components/LoginButton.svelte generated by Svelte v3.15.0 */

    function create_fragment$9(ctx) {
    	let a;
    	let span0;
    	let t0;
    	let span1;

    	return {
    		c() {
    			a = element("a");
    			span0 = element("span");
    			span0.innerHTML = `<i class="fas fa-sign-in-alt" aria-hidden="true"></i>`;
    			t0 = space();
    			span1 = element("span");
    			span1.textContent = "Login";
    			attr(span0, "class", "icon");
    			attr(a, "href", ctx.authorizeUrl);
    			attr(a, "class", "button is-dark is-rounded");
    			toggle_class(a, "is-fullwidth", ctx.fullWidth);
    		},
    		m(target, anchor) {
    			insert(target, a, anchor);
    			append(a, span0);
    			append(a, t0);
    			append(a, span1);
    		},
    		p(changed, ctx) {
    			if (changed.authorizeUrl) {
    				attr(a, "href", ctx.authorizeUrl);
    			}

    			if (changed.fullWidth) {
    				toggle_class(a, "is-fullwidth", ctx.fullWidth);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(a);
    		}
    	};
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { authOptions } = $$props;
    	let { fullWidth } = $$props;

    	$$self.$set = $$props => {
    		if ("authOptions" in $$props) $$invalidate("authOptions", authOptions = $$props.authOptions);
    		if ("fullWidth" in $$props) $$invalidate("fullWidth", fullWidth = $$props.fullWidth);
    	};

    	let authorizeParams;
    	let authorizeUrl;

    	$$self.$$.update = (changed = { authOptions: 1, authorizeParams: 1 }) => {
    		if (changed.authOptions) {
    			 $$invalidate("authorizeParams", authorizeParams = querystringify_1.stringify(
    				{
    					client_id: authOptions.clientId,
    					redirect_uri: authOptions.callbackUrl,
    					response_type: "code",
    					scope: authOptions.scopes || ""
    				},
    				true
    			));
    		}

    		if (changed.authOptions || changed.authorizeParams) {
    			 $$invalidate("authorizeUrl", authorizeUrl = `${authOptions.authorizeUrl}${authorizeParams}`);
    		}
    	};

    	return { authOptions, fullWidth, authorizeUrl };
    }

    class LoginButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { authOptions: 0, fullWidth: 0 });
    	}
    }

    /* node_modules/snowboard/templates/winter/components/LogoutButton.svelte generated by Svelte v3.15.0 */

    function create_fragment$a(ctx) {
    	let a;
    	let dispose;

    	return {
    		c() {
    			a = element("a");

    			a.innerHTML = `<span class="icon has-text-grey"><i class="fas fa-sign-out-alt" aria-hidden="true"></i></span> 
  <span>Logout</span>`;

    			attr(a, "href", "javascript:void(0)");
    			attr(a, "class", "button is-light");
    			dispose = listen(a, "click", ctx.handleClick);
    		},
    		m(target, anchor) {
    			insert(target, a, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(a);
    			dispose();
    		}
    	};
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $env;
    	component_subscribe($$self, env, $$value => $$invalidate("$env", $env = $$value));

    	function handleClick() {
    		auth.remove($env);
    		removeToken($env);
    		removeRefreshToken($env);
    	}

    	return { handleClick };
    }

    class LogoutButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/SelectorPanel.svelte generated by Svelte v3.15.0 */

    const { Object: Object_1 } = globals;

    function add_css$3() {
    	var style = element("style");
    	style.id = "svelte-cjzzpf-style";
    	style.textContent = ".icon-info.svelte-cjzzpf{cursor:pointer}.content.svelte-cjzzpf{padding:1rem 1.5rem}";
    	append(document.head, style);
    }

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = Object_1.create(ctx);
    	child_ctx.envName = list[i];
    	return child_ctx;
    }

    // (44:0) {#if isAuth(environment, 'oauth2')}
    function create_if_block_1$6(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$2, create_if_block_3$1, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.authenticating) return 0;
    		if (show_if == null || (changed.$auth || changed.$env)) show_if = !!ctx.$auth.includes(ctx.$env);
    		if (show_if) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (59:2) {:else}
    function create_else_block_1(ctx) {
    	let div1;
    	let div0;
    	let p;
    	let current;

    	const loginbutton = new LoginButton({
    			props: {
    				authOptions: ctx.environment.auth.options
    			}
    		});

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			create_component(loginbutton.$$.fragment);
    			attr(p, "class", "control");
    			attr(div0, "class", "field is-grouped");
    			attr(div1, "class", "navbar-item");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, p);
    			mount_component(loginbutton, p, null);
    			current = true;
    		},
    		p(changed, ctx) {
    			const loginbutton_changes = {};
    			if (changed.environment) loginbutton_changes.authOptions = ctx.environment.auth.options;
    			loginbutton.$set(loginbutton_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(loginbutton.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(loginbutton.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			destroy_component(loginbutton);
    		}
    	};
    }

    // (51:33) 
    function create_if_block_3$1(ctx) {
    	let div1;
    	let div0;
    	let p;
    	let current;
    	const logoutbutton = new LogoutButton({});

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			create_component(logoutbutton.$$.fragment);
    			attr(p, "class", "control");
    			attr(div0, "class", "field is-grouped");
    			attr(div1, "class", "navbar-item");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, p);
    			mount_component(logoutbutton, p, null);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(logoutbutton.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(logoutbutton.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			destroy_component(logoutbutton);
    		}
    	};
    }

    // (45:2) {#if authenticating}
    function create_if_block_2$2(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.innerHTML = `<span class="icon is-medium has-text-danger"><i class="fas fa-2x fa-spinner fa-pulse"></i></span>`;
    			attr(div, "class", "navbar-item");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (76:4) {#each Object.keys(environments) as envName}
    function create_each_block$4(ctx) {
    	let a;
    	let t0_value = ctx.envName + "";
    	let t0;
    	let t1;
    	let a_data_name_value;
    	let dispose;

    	return {
    		c() {
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(a, "data-name", a_data_name_value = ctx.envName);
    			attr(a, "href", "javascript:void(0)");
    			attr(a, "class", "navbar-item");
    			dispose = listen(a, "click", ctx.handleClick);
    		},
    		m(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t0);
    			append(a, t1);
    		},
    		p(changed, ctx) {
    			if (changed.environments && t0_value !== (t0_value = ctx.envName + "")) set_data(t0, t0_value);

    			if (changed.environments && a_data_name_value !== (a_data_name_value = ctx.envName)) {
    				attr(a, "data-name", a_data_name_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(a);
    			dispose();
    		}
    	};
    }

    // (102:8) {:else}
    function create_else_block$1(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			span.textContent = "None";
    			attr(span, "class", "is-capitalized");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (100:8) {#if environment.auth}
    function create_if_block$9(ctx) {
    	let span;
    	let t_value = ctx.environment.auth.name + "";
    	let t;

    	return {
    		c() {
    			span = element("span");
    			t = text(t_value);
    			attr(span, "class", "is-capitalized");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t);
    		},
    		p(changed, ctx) {
    			if (changed.environment && t_value !== (t_value = ctx.environment.auth.name + "")) set_data(t, t_value);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    function create_fragment$b(ctx) {
    	let show_if = isAuth(ctx.environment, "oauth2");
    	let t0;
    	let div1;
    	let a0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let div4;
    	let a1;
    	let t4;
    	let div3;
    	let div2;
    	let p0;
    	let t5;
    	let t6_value = ctx.environment.url + "";
    	let t6;
    	let t7;
    	let p1;
    	let t8;
    	let current;
    	let dispose;
    	let if_block0 = show_if && create_if_block_1$6(ctx);
    	let each_value = Object.keys(ctx.environments);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	function select_block_type_1(changed, ctx) {
    		if (ctx.environment.auth) return create_if_block$9;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type_1(null, ctx);
    	let if_block1 = current_block_type(ctx);

    	return {
    		c() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			a0 = element("a");
    			t1 = text(ctx.$env);
    			t2 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			div4 = element("div");
    			a1 = element("a");
    			a1.innerHTML = `<span class="icon icon-info is-medium has-text-grey-light svelte-cjzzpf"><i class="fas fa-lg fa-info-circle"></i></span>`;
    			t4 = space();
    			div3 = element("div");
    			div2 = element("div");
    			p0 = element("p");
    			t5 = text("BaseURL: ");
    			t6 = text(t6_value);
    			t7 = space();
    			p1 = element("p");
    			t8 = text("Auth:\n        ");
    			if_block1.c();
    			attr(a0, "href", "javascript:void(0)");
    			attr(a0, "class", "navbar-link");
    			attr(div0, "class", "navbar-dropdown is-right");
    			attr(div1, "class", "navbar-item has-dropdown is-capitalized");
    			toggle_class(div1, "is-active", ctx.show);
    			attr(a1, "href", "javascript:void(0)");
    			attr(a1, "class", "navbar-link is-arrowless");
    			attr(div2, "class", "content svelte-cjzzpf");
    			attr(div3, "class", "navbar-dropdown is-right");
    			attr(div4, "class", "navbar-item has-dropdown is-hoverable");
    			dispose = listen(a0, "click", ctx.toggleClick);
    		},
    		m(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t0, anchor);
    			insert(target, div1, anchor);
    			append(div1, a0);
    			append(a0, t1);
    			append(div1, t2);
    			append(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			insert(target, t3, anchor);
    			insert(target, div4, anchor);
    			append(div4, a1);
    			append(div4, t4);
    			append(div4, div3);
    			append(div3, div2);
    			append(div2, p0);
    			append(p0, t5);
    			append(p0, t6);
    			append(div2, t7);
    			append(div2, p1);
    			append(p1, t8);
    			if_block1.m(p1, null);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (changed.environment) show_if = isAuth(ctx.environment, "oauth2");

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_1$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!current || changed.$env) set_data(t1, ctx.$env);

    			if (changed.Object || changed.environments || changed.handleClick) {
    				each_value = Object.keys(ctx.environments);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (changed.show) {
    				toggle_class(div1, "is-active", ctx.show);
    			}

    			if ((!current || changed.environment) && t6_value !== (t6_value = ctx.environment.url + "")) set_data(t6, t6_value);

    			if (current_block_type === (current_block_type = select_block_type_1(changed, ctx)) && if_block1) {
    				if_block1.p(changed, ctx);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(p1, null);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach(t0);
    			if (detaching) detach(div1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(t3);
    			if (detaching) detach(div4);
    			if_block1.d();
    			dispose();
    		}
    	};
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $env;
    	let $auth;
    	component_subscribe($$self, env, $$value => $$invalidate("$env", $env = $$value));
    	component_subscribe($$self, auth, $$value => $$invalidate("$auth", $auth = $$value));
    	let { environments } = $$props;
    	let { authenticating } = $$props;
    	let show = false;

    	function handleClick(event) {
    		$$invalidate("show", show = false);
    		const envName = event.target.dataset["name"];
    		env.set(envName);
    		const authToken = getToken($env);

    		if (authToken) {
    			auth.add(envName);
    			token.set(authToken);
    		}
    	}

    	function toggleClick() {
    		$$invalidate("show", show = !show);
    	}

    	$$self.$set = $$props => {
    		if ("environments" in $$props) $$invalidate("environments", environments = $$props.environments);
    		if ("authenticating" in $$props) $$invalidate("authenticating", authenticating = $$props.authenticating);
    	};

    	let environment;

    	$$self.$$.update = (changed = { environments: 1, $env: 1 }) => {
    		if (changed.environments || changed.$env) {
    			 $$invalidate("environment", environment = environments[$env]);
    		}
    	};

    	return {
    		environments,
    		authenticating,
    		show,
    		handleClick,
    		toggleClick,
    		environment,
    		$env,
    		$auth
    	};
    }

    class SelectorPanel extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-cjzzpf-style")) add_css$3();
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { environments: 0, authenticating: 0 });
    	}
    }

    /* node_modules/snowboard/templates/winter/components/ToggleIcon.svelte generated by Svelte v3.15.0 */

    function add_css$4() {
    	var style = element("style");
    	style.id = "svelte-o7a14x-style";
    	style.textContent = ".toggle-icon.svelte-o7a14x{cursor:pointer}";
    	append(document.head, style);
    }

    function create_fragment$c(ctx) {
    	let span;
    	let i;
    	let span_class_value;
    	let dispose;

    	return {
    		c() {
    			span = element("span");
    			i = element("i");
    			attr(i, "class", "fas");
    			toggle_class(i, "fa-chevron-up", !ctx.show);
    			toggle_class(i, "fa-chevron-down", ctx.show);
    			attr(span, "class", span_class_value = "toggle-icon icon " + ctx.additionalClass + " svelte-o7a14x");
    			toggle_class(span, "has-text-grey", !ctx.dark);
    			dispose = listen(span, "click", ctx.toggle);
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    			append(span, i);
    		},
    		p(changed, ctx) {
    			if (changed.show) {
    				toggle_class(i, "fa-chevron-up", !ctx.show);
    			}

    			if (changed.show) {
    				toggle_class(i, "fa-chevron-down", ctx.show);
    			}

    			if (changed.additionalClass && span_class_value !== (span_class_value = "toggle-icon icon " + ctx.additionalClass + " svelte-o7a14x")) {
    				attr(span, "class", span_class_value);
    			}

    			if (changed.additionalClass || changed.dark) {
    				toggle_class(span, "has-text-grey", !ctx.dark);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(span);
    			dispose();
    		}
    	};
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { dark = false } = $$props;
    	let { show = false } = $$props;
    	let { additionalClass = "" } = $$props;
    	let { handleClick } = $$props;

    	function toggle(event) {
    		$$invalidate("show", show = !show);
    		handleClick(event);
    	}

    	$$self.$set = $$props => {
    		if ("dark" in $$props) $$invalidate("dark", dark = $$props.dark);
    		if ("show" in $$props) $$invalidate("show", show = $$props.show);
    		if ("additionalClass" in $$props) $$invalidate("additionalClass", additionalClass = $$props.additionalClass);
    		if ("handleClick" in $$props) $$invalidate("handleClick", handleClick = $$props.handleClick);
    	};

    	return {
    		dark,
    		show,
    		additionalClass,
    		handleClick,
    		toggle
    	};
    }

    class ToggleIcon extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-o7a14x-style")) add_css$4();

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			dark: 0,
    			show: 0,
    			additionalClass: 0,
    			handleClick: 0
    		});
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/CollapsiblePanel.svelte generated by Svelte v3.15.0 */

    function add_css$5() {
    	var style = element("style");
    	style.id = "svelte-1hkyt70-style";
    	style.textContent = ".panel-section.svelte-1hkyt70{padding:1em;border:1px solid #dbdbdb;border-top:none}.panel-button.svelte-1hkyt70{border-radius:4px}.panel-dark.svelte-1hkyt70{border:1px solid #363636}.panel-section.is-darkmode.svelte-1hkyt70{background-color:#222 !important;border-color:#333}";
    	append(document.head, style);
    }

    const get_body_slot_changes = () => ({});
    const get_body_slot_context = () => ({});
    const get_heading_slot_changes = () => ({});
    const get_heading_slot_context = () => ({});

    function create_fragment$d(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current;
    	const heading_slot_template = ctx.$$slots.heading;
    	const heading_slot = create_slot(heading_slot_template, ctx, get_heading_slot_context);

    	const toggleicon = new ToggleIcon({
    			props: {
    				dark: ctx.dark,
    				show: ctx.show,
    				additionalClass: "is-pulled-right",
    				handleClick: ctx.func
    			}
    		});

    	const body_slot_template = ctx.$$slots.body;
    	const body_slot = create_slot(body_slot_template, ctx, get_body_slot_context);

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			if (heading_slot) heading_slot.c();
    			t0 = space();
    			create_component(toggleicon.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			if (body_slot) body_slot.c();
    			attr(div0, "class", "panel-heading svelte-1hkyt70");
    			toggle_class(div0, "has-background-dark", ctx.dark);
    			toggle_class(div0, "has-text-white", ctx.dark);
    			toggle_class(div0, "panel-dark", ctx.dark);
    			toggle_class(div0, "panel-button", !ctx.show);
    			attr(div1, "class", "panel-section has-background-white svelte-1hkyt70");
    			toggle_class(div1, "is-hidden", !ctx.show);
    			toggle_class(div1, "is-darkmode", ctx.isDarkmode);
    			attr(div2, "class", "panel");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);

    			if (heading_slot) {
    				heading_slot.m(div0, null);
    			}

    			append(div0, t0);
    			mount_component(toggleicon, div0, null);
    			append(div2, t1);
    			append(div2, div1);

    			if (body_slot) {
    				body_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p(changed, ctx) {
    			if (heading_slot && heading_slot.p && changed.$$scope) {
    				heading_slot.p(get_slot_changes(heading_slot_template, ctx, changed, get_heading_slot_changes), get_slot_context(heading_slot_template, ctx, get_heading_slot_context));
    			}

    			const toggleicon_changes = {};
    			if (changed.dark) toggleicon_changes.dark = ctx.dark;
    			if (changed.show) toggleicon_changes.show = ctx.show;
    			if (changed.show) toggleicon_changes.handleClick = ctx.func;
    			toggleicon.$set(toggleicon_changes);

    			if (changed.dark) {
    				toggle_class(div0, "has-background-dark", ctx.dark);
    			}

    			if (changed.dark) {
    				toggle_class(div0, "has-text-white", ctx.dark);
    			}

    			if (changed.dark) {
    				toggle_class(div0, "panel-dark", ctx.dark);
    			}

    			if (changed.show) {
    				toggle_class(div0, "panel-button", !ctx.show);
    			}

    			if (body_slot && body_slot.p && changed.$$scope) {
    				body_slot.p(get_slot_changes(body_slot_template, ctx, changed, get_body_slot_changes), get_slot_context(body_slot_template, ctx, get_body_slot_context));
    			}

    			if (changed.show) {
    				toggle_class(div1, "is-hidden", !ctx.show);
    			}

    			if (changed.isDarkmode) {
    				toggle_class(div1, "is-darkmode", ctx.isDarkmode);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(heading_slot, local);
    			transition_in(toggleicon.$$.fragment, local);
    			transition_in(body_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(heading_slot, local);
    			transition_out(toggleicon.$$.fragment, local);
    			transition_out(body_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			if (heading_slot) heading_slot.d(detaching);
    			destroy_component(toggleicon);
    			if (body_slot) body_slot.d(detaching);
    		}
    	};
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { dark = false } = $$props;
    	let { show = false } = $$props;
    	let { isDarkmode } = $$props;
    	let { $$slots = {}, $$scope } = $$props;
    	const func = () => $$invalidate("show", show = !show);

    	$$self.$set = $$props => {
    		if ("dark" in $$props) $$invalidate("dark", dark = $$props.dark);
    		if ("show" in $$props) $$invalidate("show", show = $$props.show);
    		if ("isDarkmode" in $$props) $$invalidate("isDarkmode", isDarkmode = $$props.isDarkmode);
    		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
    	};

    	return {
    		dark,
    		show,
    		isDarkmode,
    		func,
    		$$slots,
    		$$scope
    	};
    }

    class CollapsiblePanel extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-1hkyt70-style")) add_css$5();
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { dark: 0, show: 0, isDarkmode: 0 });
    	}
    }

    /* node_modules/snowboard/templates/winter/components/FieldDisabled.svelte generated by Svelte v3.15.0 */

    function add_css$6() {
    	var style = element("style");
    	style.id = "svelte-a7ak6u-style";
    	style.textContent = ".control-switch.svelte-a7ak6u{padding-top:0.4rem}.has-border.svelte-a7ak6u{border-color:#dbdbdb}";
    	append(document.head, style);
    }

    function create_fragment$e(ctx) {
    	let div;
    	let p0;
    	let input0;
    	let input0_id_value;
    	let t0;
    	let label;
    	let label_for_value;
    	let t1;
    	let p1;
    	let input1;
    	let t2;
    	let p2;
    	let input2;

    	return {
    		c() {
    			div = element("div");
    			p0 = element("p");
    			input0 = element("input");
    			t0 = space();
    			label = element("label");
    			t1 = space();
    			p1 = element("p");
    			input1 = element("input");
    			t2 = space();
    			p2 = element("p");
    			input2 = element("input");
    			attr(input0, "class", "switch is-rounded is-success");
    			attr(input0, "id", input0_id_value = "h-" + ctx.name);
    			attr(input0, "type", "checkbox");
    			input0.checked = true;
    			input0.disabled = true;
    			attr(label, "for", label_for_value = "h-" + ctx.name);
    			attr(p0, "class", "control control-switch svelte-a7ak6u");
    			attr(input1, "class", "input is-rounded has-border svelte-a7ak6u");
    			attr(input1, "type", "text");
    			attr(input1, "placeholder", ctx.placeholder);
    			input1.disabled = true;
    			attr(p1, "class", "control");
    			attr(input2, "class", "input is-rounded has-border is-family-code svelte-a7ak6u");
    			attr(input2, "type", "text");
    			input2.value = ctx.value;
    			input2.disabled = true;
    			attr(p2, "class", "control is-expanded");
    			attr(div, "class", "field has-addons");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, p0);
    			append(p0, input0);
    			append(p0, t0);
    			append(p0, label);
    			append(div, t1);
    			append(div, p1);
    			append(p1, input1);
    			append(div, t2);
    			append(div, p2);
    			append(p2, input2);
    		},
    		p(changed, ctx) {
    			if (changed.name && input0_id_value !== (input0_id_value = "h-" + ctx.name)) {
    				attr(input0, "id", input0_id_value);
    			}

    			if (changed.name && label_for_value !== (label_for_value = "h-" + ctx.name)) {
    				attr(label, "for", label_for_value);
    			}

    			if (changed.placeholder) {
    				attr(input1, "placeholder", ctx.placeholder);
    			}

    			if (changed.value) {
    				input2.value = ctx.value;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { name } = $$props;
    	let { placeholder } = $$props;
    	let { value } = $$props;

    	$$self.$set = $$props => {
    		if ("name" in $$props) $$invalidate("name", name = $$props.name);
    		if ("placeholder" in $$props) $$invalidate("placeholder", placeholder = $$props.placeholder);
    		if ("value" in $$props) $$invalidate("value", value = $$props.value);
    	};

    	return { name, placeholder, value };
    }

    class FieldDisabled extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-a7ak6u-style")) add_css$6();
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { name: 0, placeholder: 0, value: 0 });
    	}
    }

    /* node_modules/snowboard/templates/winter/components/FieldSwitch.svelte generated by Svelte v3.15.0 */

    function add_css$7() {
    	var style = element("style");
    	style.id = "svelte-a7ak6u-style";
    	style.textContent = ".control-switch.svelte-a7ak6u{padding-top:0.4rem}.has-border.svelte-a7ak6u{border-color:#dbdbdb}";
    	append(document.head, style);
    }

    function create_fragment$f(ctx) {
    	let div;
    	let p0;
    	let input0;
    	let input0_id_value;
    	let t0;
    	let label;
    	let label_for_value;
    	let t1;
    	let p1;
    	let input1;
    	let t2;
    	let p2;
    	let input2;
    	let dispose;

    	return {
    		c() {
    			div = element("div");
    			p0 = element("p");
    			input0 = element("input");
    			t0 = space();
    			label = element("label");
    			t1 = space();
    			p1 = element("p");
    			input1 = element("input");
    			t2 = space();
    			p2 = element("p");
    			input2 = element("input");
    			attr(input0, "class", "switch is-rounded is-success");
    			attr(input0, "id", input0_id_value = "p-" + ctx.name);
    			attr(input0, "type", "checkbox");
    			input0.disabled = ctx.required;
    			attr(label, "for", label_for_value = "p-" + ctx.name);
    			attr(p0, "class", "control control-switch svelte-a7ak6u");
    			attr(input1, "class", "input is-rounded has-border svelte-a7ak6u");
    			attr(input1, "type", "text");
    			attr(input1, "placeholder", ctx.name);
    			input1.disabled = true;
    			attr(p1, "class", "control");
    			attr(input2, "class", "input has-border is-family-code svelte-a7ak6u");
    			attr(input2, "type", "text");
    			toggle_class(input2, "is-rounded", ctx.rounded);
    			attr(p2, "class", "control is-expanded");
    			attr(div, "class", "field has-addons");

    			dispose = [
    				listen(input0, "change", ctx.input0_change_handler),
    				listen(input2, "input", ctx.input2_input_handler)
    			];
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, p0);
    			append(p0, input0);
    			input0.checked = ctx.used;
    			append(p0, t0);
    			append(p0, label);
    			append(div, t1);
    			append(div, p1);
    			append(p1, input1);
    			append(div, t2);
    			append(div, p2);
    			append(p2, input2);
    			set_input_value(input2, ctx.value);
    		},
    		p(changed, ctx) {
    			if (changed.name && input0_id_value !== (input0_id_value = "p-" + ctx.name)) {
    				attr(input0, "id", input0_id_value);
    			}

    			if (changed.required) {
    				input0.disabled = ctx.required;
    			}

    			if (changed.used) {
    				input0.checked = ctx.used;
    			}

    			if (changed.name && label_for_value !== (label_for_value = "p-" + ctx.name)) {
    				attr(label, "for", label_for_value);
    			}

    			if (changed.name) {
    				attr(input1, "placeholder", ctx.name);
    			}

    			if (changed.value && input2.value !== ctx.value) {
    				set_input_value(input2, ctx.value);
    			}

    			if (changed.rounded) {
    				toggle_class(input2, "is-rounded", ctx.rounded);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    			run_all(dispose);
    		}
    	};
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { used } = $$props;
    	let { required } = $$props;
    	let { name } = $$props;
    	let { value } = $$props;
    	let { rounded } = $$props;

    	function input0_change_handler() {
    		used = this.checked;
    		$$invalidate("used", used);
    	}

    	function input2_input_handler() {
    		value = this.value;
    		$$invalidate("value", value);
    	}

    	$$self.$set = $$props => {
    		if ("used" in $$props) $$invalidate("used", used = $$props.used);
    		if ("required" in $$props) $$invalidate("required", required = $$props.required);
    		if ("name" in $$props) $$invalidate("name", name = $$props.name);
    		if ("value" in $$props) $$invalidate("value", value = $$props.value);
    		if ("rounded" in $$props) $$invalidate("rounded", rounded = $$props.rounded);
    	};

    	return {
    		used,
    		required,
    		name,
    		value,
    		rounded,
    		input0_change_handler,
    		input2_input_handler
    	};
    }

    class FieldSwitch extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-a7ak6u-style")) add_css$7();

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			used: 0,
    			required: 0,
    			name: 0,
    			value: 0,
    			rounded: 0
    		});
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/PlaygroundPanel.svelte generated by Svelte v3.15.0 */

    const { Object: Object_1$1 } = globals;

    function add_css$8() {
    	var style = element("style");
    	style.id = "svelte-c3oocm-style";
    	style.textContent = ".small-section.svelte-c3oocm{padding-top:0.5rem}.button-left.svelte-c3oocm{justify-content:left}.control-switch.svelte-c3oocm{padding-top:0.4rem}.container-content.svelte-c3oocm{padding:0.5rem 1rem;border-radius:4px;margin-top:0.5rem;background-color:#2b2b2b}.content-header.svelte-c3oocm{color:#fff;border-bottom:dashed 1px #777;padding-top:0.5rem;padding-bottom:1rem}.hero-small.svelte-c3oocm{padding:1.5rem}.has-border.svelte-c3oocm{border-color:#dbdbdb}.hero-rounded.svelte-c3oocm{border-radius:4px}";
    	append(document.head, style);
    }

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = Object_1$1.create(ctx);
    	child_ctx.key = list[i][0];
    	child_ctx.val = list[i][1];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = Object_1$1.create(ctx);
    	child_ctx.param = list[i];
    	child_ctx.each_value_1 = list;
    	child_ctx.param_index = i;
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = Object_1$1.create(ctx);
    	child_ctx.header = list[i];
    	child_ctx.each_value_2 = list;
    	child_ctx.header_index = i;
    	return child_ctx;
    }

    // (126:2) <span slot="heading">
    function create_heading_slot(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			span.textContent = "Playground";
    			attr(span, "slot", "heading");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (135:8) {:else}
    function create_else_block_4(ctx) {
    	let a;
    	let span0;
    	let t0_value = ctx.currentAction.method + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2_value = ctx.currentUrl.origin + "";
    	let t2;
    	let t3;
    	let span2;
    	let t4_value = ctx.currentUrl.pathname + "";
    	let t4;
    	let dispose;

    	return {
    		c() {
    			a = element("a");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text("\n             \n            ");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span2 = element("span");
    			t4 = text(t4_value);
    			attr(span0, "class", "is-uppercase has-text-weight-bold");
    			attr(span2, "class", "has-text-weight-bold");
    			attr(a, "href", "javascript:void(0)");
    			attr(a, "class", "button button-left is-warning is-family-code is-fullwidth svelte-c3oocm");
    			dispose = listen(a, "click", ctx.handleCopy);
    		},
    		m(target, anchor) {
    			insert(target, a, anchor);
    			append(a, span0);
    			append(span0, t0);
    			append(a, t1);
    			append(a, span1);
    			append(span1, t2);
    			append(a, t3);
    			append(a, span2);
    			append(span2, t4);
    		},
    		p(changed, ctx) {
    			if (changed.currentAction && t0_value !== (t0_value = ctx.currentAction.method + "")) set_data(t0, t0_value);
    			if (changed.currentUrl && t2_value !== (t2_value = ctx.currentUrl.origin + "")) set_data(t2, t2_value);
    			if (changed.currentUrl && t4_value !== (t4_value = ctx.currentUrl.pathname + "")) set_data(t4, t4_value);
    		},
    		d(detaching) {
    			if (detaching) detach(a);
    			dispose();
    		}
    	};
    }

    // (130:8) {#if copying}
    function create_if_block_11(ctx) {
    	let button;

    	return {
    		c() {
    			button = element("button");
    			button.innerHTML = `<span>URL has been copied to clipboard.</span>`;
    			attr(button, "class", "button button-left is-warning is-family-code is-fullwidth svelte-c3oocm");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    		}
    	};
    }

    // (154:8) {:else}
    function create_else_block_3(ctx) {
    	let button;
    	let dispose;

    	return {
    		c() {
    			button = element("button");

    			button.innerHTML = `<span class="icon"><i class="fas fa-paper-plane"></i></span> 
            <span>Send</span>`;

    			attr(button, "class", "button is-success is-fullwidth");
    			dispose = listen(button, "click", ctx.handleClick);
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			dispose();
    		}
    	};
    }

    // (150:8) {#if isAuth(environment, 'oauth2') && !$auth.includes($env)}
    function create_if_block_10(ctx) {
    	let current;

    	const loginbutton = new LoginButton({
    			props: {
    				authOptions: ctx.environment.auth.options,
    				fullWidth: true
    			}
    		});

    	return {
    		c() {
    			create_component(loginbutton.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(loginbutton, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const loginbutton_changes = {};
    			if (changed.environment) loginbutton_changes.authOptions = ctx.environment.auth.options;
    			loginbutton.$set(loginbutton_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(loginbutton.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(loginbutton.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(loginbutton, detaching);
    		}
    	};
    }

    // (186:6) {:else}
    function create_else_block_2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = ctx.requestHeaders;
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (changed.requestHeaders) {
    				each_value_2 = ctx.requestHeaders;
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    // (182:6) {#if requestHeaders.length === 0 && !environment.auth}
    function create_if_block_9(ctx) {
    	let p;

    	return {
    		c() {
    			p = element("p");
    			p.innerHTML = `<em>No configurable headers.</em>`;
    		},
    		m(target, anchor) {
    			insert(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(p);
    		}
    	};
    }

    // (187:8) {#each requestHeaders as header}
    function create_each_block_2$1(ctx) {
    	let updating_used;
    	let updating_value;
    	let current;

    	function fieldswitch_used_binding(value) {
    		ctx.fieldswitch_used_binding.call(null, value, ctx);
    	}

    	function fieldswitch_value_binding(value_1) {
    		ctx.fieldswitch_value_binding.call(null, value_1, ctx);
    	}

    	let fieldswitch_props = {
    		name: ctx.header.name,
    		required: ctx.header.required,
    		rounded: true
    	};

    	if (ctx.header.used !== void 0) {
    		fieldswitch_props.used = ctx.header.used;
    	}

    	if (ctx.header.value !== void 0) {
    		fieldswitch_props.value = ctx.header.value;
    	}

    	const fieldswitch = new FieldSwitch({ props: fieldswitch_props });
    	binding_callbacks.push(() => bind(fieldswitch, "used", fieldswitch_used_binding));
    	binding_callbacks.push(() => bind(fieldswitch, "value", fieldswitch_value_binding));

    	return {
    		c() {
    			create_component(fieldswitch.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(fieldswitch, target, anchor);
    			current = true;
    		},
    		p(changed, new_ctx) {
    			ctx = new_ctx;
    			const fieldswitch_changes = {};
    			if (changed.requestHeaders) fieldswitch_changes.name = ctx.header.name;
    			if (changed.requestHeaders) fieldswitch_changes.required = ctx.header.required;

    			if (!updating_used && changed.requestHeaders) {
    				updating_used = true;
    				fieldswitch_changes.used = ctx.header.used;
    				add_flush_callback(() => updating_used = false);
    			}

    			if (!updating_value && changed.requestHeaders) {
    				updating_value = true;
    				fieldswitch_changes.value = ctx.header.value;
    				add_flush_callback(() => updating_value = false);
    			}

    			fieldswitch.$set(fieldswitch_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(fieldswitch.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(fieldswitch.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(fieldswitch, detaching);
    		}
    	};
    }

    // (197:6) {#if isAuth(environment, 'basic')}
    function create_if_block_8(ctx) {
    	let current;

    	const fielddisabled = new FieldDisabled({
    			props: {
    				name: "authorization",
    				placeholder: "Authorization",
    				value: "Basic " + basicAuth(ctx.environment.auth.options.username, ctx.environment.auth.options.password)
    			}
    		});

    	return {
    		c() {
    			create_component(fielddisabled.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(fielddisabled, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const fielddisabled_changes = {};
    			if (changed.environment) fielddisabled_changes.value = "Basic " + basicAuth(ctx.environment.auth.options.username, ctx.environment.auth.options.password);
    			fielddisabled.$set(fielddisabled_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(fielddisabled.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(fielddisabled.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(fielddisabled, detaching);
    		}
    	};
    }

    // (204:6) {#if isAuth(environment, 'apikey')}
    function create_if_block_7(ctx) {
    	let current;

    	const fielddisabled = new FieldDisabled({
    			props: {
    				name: "authorization",
    				placeholder: ctx.environment.auth.options.header,
    				value: ctx.environment.auth.options.key
    			}
    		});

    	return {
    		c() {
    			create_component(fielddisabled.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(fielddisabled, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const fielddisabled_changes = {};
    			if (changed.environment) fielddisabled_changes.placeholder = ctx.environment.auth.options.header;
    			if (changed.environment) fielddisabled_changes.value = ctx.environment.auth.options.key;
    			fielddisabled.$set(fielddisabled_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(fielddisabled.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(fielddisabled.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(fielddisabled, detaching);
    		}
    	};
    }

    // (211:6) {#if isAuth(environment, 'oauth2')}
    function create_if_block_5(ctx) {
    	let show_if = ctx.$auth.includes(ctx.$env);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block_6(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (changed.$auth || changed.$env) show_if = ctx.$auth.includes(ctx.$env);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (212:8) {#if $auth.includes($env)}
    function create_if_block_6(ctx) {
    	let current;

    	const fielddisabled = new FieldDisabled({
    			props: {
    				name: "authorization",
    				placeholder: "Authorization",
    				value: "Bearer " + ctx.$token
    			}
    		});

    	return {
    		c() {
    			create_component(fielddisabled.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(fielddisabled, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const fielddisabled_changes = {};
    			if (changed.$token) fielddisabled_changes.value = "Bearer " + ctx.$token;
    			fielddisabled.$set(fielddisabled_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(fielddisabled.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(fielddisabled.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(fielddisabled, detaching);
    		}
    	};
    }

    // (226:6) {:else}
    function create_else_block_1$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = ctx.requestParameters;
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (changed.requestParameters) {
    				each_value_1 = ctx.requestParameters;
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    // (222:6) {#if requestParameters.length === 0}
    function create_if_block_4(ctx) {
    	let p;

    	return {
    		c() {
    			p = element("p");
    			p.innerHTML = `<em>No configurable parameters.</em>`;
    		},
    		m(target, anchor) {
    			insert(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(p);
    		}
    	};
    }

    // (227:8) {#each requestParameters as param}
    function create_each_block_1$1(ctx) {
    	let updating_used;
    	let updating_value;
    	let current;

    	function fieldswitch_used_binding_1(value) {
    		ctx.fieldswitch_used_binding_1.call(null, value, ctx);
    	}

    	function fieldswitch_value_binding_1(value_1) {
    		ctx.fieldswitch_value_binding_1.call(null, value_1, ctx);
    	}

    	let fieldswitch_props = {
    		name: ctx.param.name,
    		required: ctx.param.required
    	};

    	if (ctx.param.used !== void 0) {
    		fieldswitch_props.used = ctx.param.used;
    	}

    	if (ctx.param.value !== void 0) {
    		fieldswitch_props.value = ctx.param.value;
    	}

    	const fieldswitch = new FieldSwitch({ props: fieldswitch_props });
    	binding_callbacks.push(() => bind(fieldswitch, "used", fieldswitch_used_binding_1));
    	binding_callbacks.push(() => bind(fieldswitch, "value", fieldswitch_value_binding_1));

    	return {
    		c() {
    			create_component(fieldswitch.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(fieldswitch, target, anchor);
    			current = true;
    		},
    		p(changed, new_ctx) {
    			ctx = new_ctx;
    			const fieldswitch_changes = {};
    			if (changed.requestParameters) fieldswitch_changes.name = ctx.param.name;
    			if (changed.requestParameters) fieldswitch_changes.required = ctx.param.required;

    			if (!updating_used && changed.requestParameters) {
    				updating_used = true;
    				fieldswitch_changes.used = ctx.param.used;
    				add_flush_callback(() => updating_used = false);
    			}

    			if (!updating_value && changed.requestParameters) {
    				updating_value = true;
    				fieldswitch_changes.value = ctx.param.value;
    				add_flush_callback(() => updating_value = false);
    			}

    			fieldswitch.$set(fieldswitch_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(fieldswitch.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(fieldswitch.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(fieldswitch, detaching);
    		}
    	};
    }

    // (243:6) {:else}
    function create_else_block$2(ctx) {
    	let p;

    	return {
    		c() {
    			p = element("p");
    			p.innerHTML = `<i>Body is only available for POST, PUT and PATCH.</i>`;
    		},
    		m(target, anchor) {
    			insert(target, p, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(p);
    		}
    	};
    }

    // (238:6) {#if allowBody(currentAction)}
    function create_if_block_3$2(ctx) {
    	let textarea;
    	let dispose;

    	return {
    		c() {
    			textarea = element("textarea");
    			attr(textarea, "class", "textarea is-family-code");
    			attr(textarea, "rows", "8");
    			dispose = listen(textarea, "input", ctx.textarea_input_handler);
    		},
    		m(target, anchor) {
    			insert(target, textarea, anchor);
    			set_input_value(textarea, ctx.requestBody);
    		},
    		p(changed, ctx) {
    			if (changed.requestBody) {
    				set_input_value(textarea, ctx.requestBody);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(textarea);
    			dispose();
    		}
    	};
    }

    // (283:4) {:catch}
    function create_catch_block(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.textContent = " ";
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (256:4) {:then value}
    function create_then_block(ctx) {
    	let show_if = Object.keys(ctx.value).length > 0;
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block_1$7(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (changed.response) show_if = Object.keys(ctx.value).length > 0;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (257:6) {#if Object.keys(value).length > 0}
    function create_if_block_1$7(ctx) {
    	let div1;
    	let section1;
    	let section0;
    	let div0;
    	let h1;
    	let t0_value = ctx.value.status + "";
    	let t0;
    	let t1;
    	let t2_value = ctx.value.statusText + "";
    	let t2;
    	let section1_class_value;
    	let t3;
    	let show_if = Object.keys(ctx.value.headers).length > 0;
    	let current;
    	let if_block = show_if && create_if_block_2$3(ctx);

    	return {
    		c() {
    			div1 = element("div");
    			section1 = element("section");
    			section0 = element("section");
    			div0 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			attr(h1, "class", "title");
    			attr(div0, "class", "container has-text-centered");
    			attr(section0, "class", "hero-body hero-small svelte-c3oocm");
    			attr(section1, "class", section1_class_value = "hero hero-rounded " + colorize(ctx.value.status) + " svelte-c3oocm");
    			attr(div1, "class", "small-section svelte-c3oocm");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, section1);
    			append(section1, section0);
    			append(section0, div0);
    			append(div0, h1);
    			append(h1, t0);
    			append(h1, t1);
    			append(h1, t2);
    			append(div1, t3);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    		},
    		p(changed, ctx) {
    			if ((!current || changed.response) && t0_value !== (t0_value = ctx.value.status + "")) set_data(t0, t0_value);
    			if ((!current || changed.response) && t2_value !== (t2_value = ctx.value.statusText + "")) set_data(t2, t2_value);

    			if (!current || changed.response && section1_class_value !== (section1_class_value = "hero hero-rounded " + colorize(ctx.value.status) + " svelte-c3oocm")) {
    				attr(section1, "class", section1_class_value);
    			}

    			if (changed.response) show_if = Object.keys(ctx.value.headers).length > 0;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_2$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if (if_block) if_block.d();
    		}
    	};
    }

    // (267:10) {#if Object.keys(value.headers).length > 0}
    function create_if_block_2$3(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let current;
    	let each_value = Object.entries(ctx.value.headers);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const codeblock = new CodeBlock({
    			props: {
    				type: contentType(ctx.value.headers),
    				body: ctx.value.data
    			}
    		});

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			create_component(codeblock.$$.fragment);
    			attr(div0, "class", "content-header svelte-c3oocm");
    			attr(div1, "class", "container container-content svelte-c3oocm");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append(div1, t);
    			mount_component(codeblock, div1, null);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (changed.Object || changed.response) {
    				each_value = Object.entries(ctx.value.headers);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const codeblock_changes = {};
    			if (changed.response) codeblock_changes.type = contentType(ctx.value.headers);
    			if (changed.response) codeblock_changes.body = ctx.value.data;
    			codeblock.$set(codeblock_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(codeblock.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(codeblock.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			destroy_each(each_blocks, detaching);
    			destroy_component(codeblock);
    		}
    	};
    }

    // (270:16) {#each Object.entries(value.headers) as [key, val]}
    function create_each_block$5(ctx) {
    	let p;
    	let span;
    	let t0_value = ctx.key + "";
    	let t0;
    	let t1;
    	let t2_value = ctx.val + "";
    	let t2;
    	let t3;

    	return {
    		c() {
    			p = element("p");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text("\n                    : ");
    			t2 = text(t2_value);
    			t3 = space();
    			attr(span, "class", "is-capitalized");
    			attr(p, "class", "is-family-code");
    		},
    		m(target, anchor) {
    			insert(target, p, anchor);
    			append(p, span);
    			append(span, t0);
    			append(p, t1);
    			append(p, t2);
    			append(p, t3);
    		},
    		p(changed, ctx) {
    			if (changed.response && t0_value !== (t0_value = ctx.key + "")) set_data(t0, t0_value);
    			if (changed.response && t2_value !== (t2_value = ctx.val + "")) set_data(t2, t2_value);
    		},
    		d(detaching) {
    			if (detaching) detach(p);
    		}
    	};
    }

    // (250:21)        <div class="section has-text-centered">         <span class="icon is-medium has-text-danger">           <i class="fas fa-2x fa-spinner fa-pulse" />         </span>       </div>     {:then value}
    function create_pending_block(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.innerHTML = `<span class="icon is-medium has-text-danger"><i class="fas fa-2x fa-spinner fa-pulse"></i></span>`;
    			attr(div, "class", "section has-text-centered");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (287:4) {#if error}
    function create_if_block$a(ctx) {
    	let div1;
    	let section1;
    	let section0;
    	let div0;
    	let p;
    	let t;

    	return {
    		c() {
    			div1 = element("div");
    			section1 = element("section");
    			section0 = element("section");
    			div0 = element("div");
    			p = element("p");
    			t = text(ctx.error);
    			attr(p, "class", "subtitle");
    			attr(div0, "class", "container");
    			attr(section0, "class", "hero-body");
    			attr(section1, "class", "hero is-danger");
    			attr(div1, "class", "small-section svelte-c3oocm");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, section1);
    			append(section1, section0);
    			append(section0, div0);
    			append(div0, p);
    			append(p, t);
    		},
    		p(changed, ctx) {
    			if (changed.error) set_data(t, ctx.error);
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    		}
    	};
    }

    // (127:2) <div slot="body">
    function create_body_slot(ctx) {
    	let div0;
    	let div3;
    	let div1;
    	let t0;
    	let div2;
    	let show_if_4;
    	let current_block_type_index;
    	let if_block1;
    	let t1;
    	let div4;
    	let ul;
    	let li0;
    	let a0;
    	let t3;
    	let li1;
    	let a1;
    	let t5;
    	let li2;
    	let a2;
    	let t7;
    	let div5;
    	let current_block_type_index_1;
    	let if_block2;
    	let t8;
    	let show_if_3 = isAuth(ctx.environment, "basic");
    	let t9;
    	let show_if_2 = isAuth(ctx.environment, "apikey");
    	let t10;
    	let show_if_1 = isAuth(ctx.environment, "oauth2");
    	let t11;
    	let div6;
    	let current_block_type_index_2;
    	let if_block6;
    	let t12;
    	let div7;
    	let show_if;
    	let t13;
    	let promise;
    	let t14;
    	let current;
    	let dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.copying) return create_if_block_11;
    		return create_else_block_4;
    	}

    	let current_block_type = select_block_type(null, ctx);
    	let if_block0 = current_block_type(ctx);
    	const if_block_creators = [create_if_block_10, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type_1(changed, ctx) {
    		if (show_if_4 == null || (changed.environment || changed.$auth || changed.$env)) show_if_4 = !!(isAuth(ctx.environment, "oauth2") && !ctx.$auth.includes(ctx.$env));
    		if (show_if_4) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(null, ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const if_block_creators_1 = [create_if_block_9, create_else_block_2];
    	const if_blocks_1 = [];

    	function select_block_type_2(changed, ctx) {
    		if (ctx.requestHeaders.length === 0 && !ctx.environment.auth) return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_2(null, ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    	let if_block3 = show_if_3 && create_if_block_8(ctx);
    	let if_block4 = show_if_2 && create_if_block_7(ctx);
    	let if_block5 = show_if_1 && create_if_block_5(ctx);
    	const if_block_creators_2 = [create_if_block_4, create_else_block_1$1];
    	const if_blocks_2 = [];

    	function select_block_type_3(changed, ctx) {
    		if (ctx.requestParameters.length === 0) return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_3(null, ctx);
    	if_block6 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	function select_block_type_4(changed, ctx) {
    		if (show_if == null || changed.currentAction) show_if = !!allowBody(ctx.currentAction);
    		if (show_if) return create_if_block_3$2;
    		return create_else_block$2;
    	}

    	let current_block_type_1 = select_block_type_4(null, ctx);
    	let if_block7 = current_block_type_1(ctx);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: "value",
    		error: "null",
    		blocks: [,,,]
    	};

    	handle_promise(promise = ctx.response, info);
    	let if_block8 = ctx.error && create_if_block$a(ctx);

    	return {
    		c() {
    			div0 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			if_block0.c();
    			t0 = space();
    			div2 = element("div");
    			if_block1.c();
    			t1 = space();
    			div4 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Headers";
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Parameters";
    			t5 = space();
    			li2 = element("li");
    			a2 = element("a");
    			a2.textContent = "Body";
    			t7 = space();
    			div5 = element("div");
    			if_block2.c();
    			t8 = space();
    			if (if_block3) if_block3.c();
    			t9 = space();
    			if (if_block4) if_block4.c();
    			t10 = space();
    			if (if_block5) if_block5.c();
    			t11 = space();
    			div6 = element("div");
    			if_block6.c();
    			t12 = space();
    			div7 = element("div");
    			if_block7.c();
    			t13 = space();
    			info.block.c();
    			t14 = space();
    			if (if_block8) if_block8.c();
    			attr(div1, "class", "column");
    			attr(div2, "class", "column is-one-fifth");
    			attr(div3, "class", "columns");
    			attr(a0, "href", "javascript:void(0)");
    			toggle_class(li0, "is-active", ctx.requestTab === 0);
    			attr(a1, "href", "javascript:void(0)");
    			toggle_class(li1, "is-active", ctx.requestTab === 1);
    			attr(a2, "href", "javascript:void(0)");
    			toggle_class(li2, "is-active", ctx.requestTab === 2);
    			attr(div4, "class", "tabs is-boxed");
    			attr(div5, "class", "section-headers");
    			toggle_class(div5, "is-hidden", ctx.requestTab != 0);
    			attr(div6, "class", "section-parameters");
    			toggle_class(div6, "is-hidden", ctx.requestTab != 1);
    			attr(div7, "class", "section-body");
    			toggle_class(div7, "is-hidden", ctx.requestTab != 2);
    			attr(div0, "slot", "body");

    			dispose = [
    				listen(a0, "click", ctx.click_handler),
    				listen(a1, "click", ctx.click_handler_1),
    				listen(a2, "click", ctx.click_handler_2)
    			];
    		},
    		m(target, anchor) {
    			insert(target, div0, anchor);
    			append(div0, div3);
    			append(div3, div1);
    			if_block0.m(div1, null);
    			append(div3, t0);
    			append(div3, div2);
    			if_blocks[current_block_type_index].m(div2, null);
    			append(div0, t1);
    			append(div0, div4);
    			append(div4, ul);
    			append(ul, li0);
    			append(li0, a0);
    			append(ul, t3);
    			append(ul, li1);
    			append(li1, a1);
    			append(ul, t5);
    			append(ul, li2);
    			append(li2, a2);
    			append(div0, t7);
    			append(div0, div5);
    			if_blocks_1[current_block_type_index_1].m(div5, null);
    			append(div5, t8);
    			if (if_block3) if_block3.m(div5, null);
    			append(div5, t9);
    			if (if_block4) if_block4.m(div5, null);
    			append(div5, t10);
    			if (if_block5) if_block5.m(div5, null);
    			append(div0, t11);
    			append(div0, div6);
    			if_blocks_2[current_block_type_index_2].m(div6, null);
    			append(div0, t12);
    			append(div0, div7);
    			if_block7.m(div7, null);
    			append(div0, t13);
    			info.block.m(div0, info.anchor = null);
    			info.mount = () => div0;
    			info.anchor = t14;
    			append(div0, t14);
    			if (if_block8) if_block8.m(div0, null);
    			current = true;
    		},
    		p(changed, new_ctx) {
    			ctx = new_ctx;

    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block0) {
    				if_block0.p(changed, ctx);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div1, null);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(changed, ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div2, null);
    			}

    			if (changed.requestTab) {
    				toggle_class(li0, "is-active", ctx.requestTab === 0);
    			}

    			if (changed.requestTab) {
    				toggle_class(li1, "is-active", ctx.requestTab === 1);
    			}

    			if (changed.requestTab) {
    				toggle_class(li2, "is-active", ctx.requestTab === 2);
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_2(changed, ctx);

    			if (current_block_type_index_1 === previous_block_index_1) {
    				if_blocks_1[current_block_type_index_1].p(changed, ctx);
    			} else {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div5, t8);
    			}

    			if (changed.environment) show_if_3 = isAuth(ctx.environment, "basic");

    			if (show_if_3) {
    				if (if_block3) {
    					if_block3.p(changed, ctx);
    					transition_in(if_block3, 1);
    				} else {
    					if_block3 = create_if_block_8(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div5, t9);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (changed.environment) show_if_2 = isAuth(ctx.environment, "apikey");

    			if (show_if_2) {
    				if (if_block4) {
    					if_block4.p(changed, ctx);
    					transition_in(if_block4, 1);
    				} else {
    					if_block4 = create_if_block_7(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div5, t10);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (changed.environment) show_if_1 = isAuth(ctx.environment, "oauth2");

    			if (show_if_1) {
    				if (if_block5) {
    					if_block5.p(changed, ctx);
    					transition_in(if_block5, 1);
    				} else {
    					if_block5 = create_if_block_5(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div5, null);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (changed.requestTab) {
    				toggle_class(div5, "is-hidden", ctx.requestTab != 0);
    			}

    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_3(changed, ctx);

    			if (current_block_type_index_2 === previous_block_index_2) {
    				if_blocks_2[current_block_type_index_2].p(changed, ctx);
    			} else {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block6 = if_blocks_2[current_block_type_index_2];

    				if (!if_block6) {
    					if_block6 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block6.c();
    				}

    				transition_in(if_block6, 1);
    				if_block6.m(div6, null);
    			}

    			if (changed.requestTab) {
    				toggle_class(div6, "is-hidden", ctx.requestTab != 1);
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_4(changed, ctx)) && if_block7) {
    				if_block7.p(changed, ctx);
    			} else {
    				if_block7.d(1);
    				if_block7 = current_block_type_1(ctx);

    				if (if_block7) {
    					if_block7.c();
    					if_block7.m(div7, null);
    				}
    			}

    			if (changed.requestTab) {
    				toggle_class(div7, "is-hidden", ctx.requestTab != 2);
    			}

    			info.ctx = ctx;

    			if (changed.response && promise !== (promise = ctx.response) && handle_promise(promise, info)) {
    				
    			} else {
    				info.block.p(changed, assign(assign({}, ctx), info.resolved)); // nothing
    			}

    			if (ctx.error) {
    				if (if_block8) {
    					if_block8.p(changed, ctx);
    				} else {
    					if_block8 = create_if_block$a(ctx);
    					if_block8.c();
    					if_block8.m(div0, null);
    				}
    			} else if (if_block8) {
    				if_block8.d(1);
    				if_block8 = null;
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(info.block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div0);
    			if_block0.d();
    			if_blocks[current_block_type_index].d();
    			if_blocks_1[current_block_type_index_1].d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if_blocks_2[current_block_type_index_2].d();
    			if_block7.d();
    			info.block.d();
    			info.token = null;
    			info = null;
    			if (if_block8) if_block8.d();
    			run_all(dispose);
    		}
    	};
    }

    // (125:0) <CollapsiblePanel dark={true} {isDarkmode} {show}>
    function create_default_slot(ctx) {
    	let t;
    	let current;

    	return {
    		c() {
    			t = space();
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    function create_fragment$g(ctx) {
    	let current;

    	const collapsiblepanel = new CollapsiblePanel({
    			props: {
    				dark: true,
    				isDarkmode: ctx.isDarkmode,
    				show: ctx.show,
    				$$slots: {
    					default: [create_default_slot],
    					body: [create_body_slot],
    					heading: [create_heading_slot]
    				},
    				$$scope: { ctx }
    			}
    		});

    	return {
    		c() {
    			create_component(collapsiblepanel.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(collapsiblepanel, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const collapsiblepanel_changes = {};
    			if (changed.isDarkmode) collapsiblepanel_changes.isDarkmode = ctx.isDarkmode;
    			if (changed.show) collapsiblepanel_changes.show = ctx.show;

    			if (changed.$$scope || changed.error || changed.response || changed.requestTab || changed.currentAction || changed.requestBody || changed.requestParameters || changed.environment || changed.$auth || changed.$env || changed.$token || changed.requestHeaders || changed.copying || changed.currentUrl) {
    				collapsiblepanel_changes.$$scope = { changed, ctx };
    			}

    			collapsiblepanel.$set(collapsiblepanel_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(collapsiblepanel.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(collapsiblepanel.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(collapsiblepanel, detaching);
    		}
    	};
    }

    function contentType(headers) {
    	return headers && headers["content-type"];
    }

    function basicAuth(username, password) {
    	return btoa(`${username}:${password}`);
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $env;
    	let $auth;
    	let $token;
    	component_subscribe($$self, env, $$value => $$invalidate("$env", $env = $$value));
    	component_subscribe($$self, auth, $$value => $$invalidate("$auth", $auth = $$value));
    	component_subscribe($$self, token, $$value => $$invalidate("$token", $token = $$value));
    	let { show = true } = $$props;
    	let { isDarkmode } = $$props;
    	let { environments } = $$props;
    	let { currentAction } = $$props;
    	let { currentSample } = $$props;
    	let { requestHeaders } = $$props;
    	let { requestParameters } = $$props;
    	let { requestBody } = $$props;
    	let response = {};
    	let requestTab = 0;
    	let error;
    	let copying = false;

    	afterUpdate(() => {
    		$$invalidate("response", response = {});
    	});

    	function handleClick() {
    		$$invalidate("error", error = undefined);

    		$$invalidate("response", response = sendRequest($env, environment, currentAction, {
    			headers: requestHeaders,
    			parameters: requestParameters,
    			body: requestBody
    		}).catch(function (err) {
    			$$invalidate("error", error = err);
    			return Promise.reject(err);
    		}));
    	}

    	function handleTab(index) {
    		$$invalidate("error", error = undefined);
    		$$invalidate("requestTab", requestTab = index);
    	}

    	function handleCopy() {
    		$$invalidate("copying", copying = true);

    		setTimeout(
    			() => {
    				$$invalidate("copying", copying = false);
    			},
    			2000
    		);

    		copyUrl(currentUrl, requestParameters);
    	}

    	const click_handler = () => handleTab(0);
    	const click_handler_1 = () => handleTab(1);
    	const click_handler_2 = () => handleTab(2);

    	function fieldswitch_used_binding(value, { header }) {
    		header.used = value;
    		$$invalidate("requestHeaders", requestHeaders);
    	}

    	function fieldswitch_value_binding(value_1, { header }) {
    		header.value = value_1;
    		$$invalidate("requestHeaders", requestHeaders);
    	}

    	function fieldswitch_used_binding_1(value, { param }) {
    		param.used = value;
    		$$invalidate("requestParameters", requestParameters);
    	}

    	function fieldswitch_value_binding_1(value_1, { param }) {
    		param.value = value_1;
    		$$invalidate("requestParameters", requestParameters);
    	}

    	function textarea_input_handler() {
    		requestBody = this.value;
    		$$invalidate("requestBody", requestBody);
    	}

    	$$self.$set = $$props => {
    		if ("show" in $$props) $$invalidate("show", show = $$props.show);
    		if ("isDarkmode" in $$props) $$invalidate("isDarkmode", isDarkmode = $$props.isDarkmode);
    		if ("environments" in $$props) $$invalidate("environments", environments = $$props.environments);
    		if ("currentAction" in $$props) $$invalidate("currentAction", currentAction = $$props.currentAction);
    		if ("currentSample" in $$props) $$invalidate("currentSample", currentSample = $$props.currentSample);
    		if ("requestHeaders" in $$props) $$invalidate("requestHeaders", requestHeaders = $$props.requestHeaders);
    		if ("requestParameters" in $$props) $$invalidate("requestParameters", requestParameters = $$props.requestParameters);
    		if ("requestBody" in $$props) $$invalidate("requestBody", requestBody = $$props.requestBody);
    	};

    	let environment;
    	let currentUrl;

    	$$self.$$.update = (changed = { environments: 1, $env: 1, environment: 1, currentAction: 1, currentUrl: 1 }) => {
    		if (changed.environments || changed.$env) {
    			 $$invalidate("environment", environment = environments[$env]);
    		}

    		if (changed.environment || changed.currentAction) {
    			 $$invalidate("currentUrl", currentUrl = urlParse(urlJoin(environment.url, currentAction.path)));
    		}

    		if (changed.currentUrl) {
    			 {
    				$$invalidate("error", error = currentUrl && undefined);
    			}
    		}
    	};

    	return {
    		show,
    		isDarkmode,
    		environments,
    		currentAction,
    		currentSample,
    		requestHeaders,
    		requestParameters,
    		requestBody,
    		response,
    		requestTab,
    		error,
    		copying,
    		handleClick,
    		handleTab,
    		handleCopy,
    		environment,
    		$env,
    		currentUrl,
    		$auth,
    		$token,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		fieldswitch_used_binding,
    		fieldswitch_value_binding,
    		fieldswitch_used_binding_1,
    		fieldswitch_value_binding_1,
    		textarea_input_handler
    	};
    }

    class PlaygroundPanel extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-c3oocm-style")) add_css$8();

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			show: 0,
    			isDarkmode: 0,
    			environments: 0,
    			currentAction: 0,
    			currentSample: 0,
    			requestHeaders: 0,
    			requestParameters: 0,
    			requestBody: 0
    		});
    	}
    }

    /* node_modules/snowboard/templates/winter/panels/ScenarioPanel.svelte generated by Svelte v3.15.0 */

    function create_heading_slot$1(ctx) {
    	let span;
    	let t_value = ctx.title(ctx.index) + "";
    	let t;

    	return {
    		c() {
    			span = element("span");
    			t = text(t_value);
    			attr(span, "slot", "heading");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t);
    		},
    		p(changed, ctx) {
    			if (changed.index && t_value !== (t_value = ctx.title(ctx.index) + "")) set_data(t, t_value);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (32:2) <div slot="body">
    function create_body_slot$1(ctx) {
    	let div;
    	let t;
    	let current;

    	const requestpanel = new RequestPanel({
    			props: {
    				description: ctx.request.description,
    				headers: ctx.request.headers,
    				contentType: ctx.request.contentType,
    				example: ctx.request.example,
    				schema: ctx.request.schema
    			}
    		});

    	const responsepanel = new ResponsePanel({
    			props: {
    				title: ctx.response.title,
    				description: ctx.response.description,
    				statusCode: ctx.response.statusCode,
    				headers: ctx.response.headers,
    				contentType: ctx.response.contentType,
    				example: ctx.response.example,
    				schema: ctx.response.schema
    			}
    		});

    	return {
    		c() {
    			div = element("div");
    			create_component(requestpanel.$$.fragment);
    			t = space();
    			create_component(responsepanel.$$.fragment);
    			attr(div, "slot", "body");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(requestpanel, div, null);
    			append(div, t);
    			mount_component(responsepanel, div, null);
    			current = true;
    		},
    		p(changed, ctx) {
    			const requestpanel_changes = {};
    			if (changed.request) requestpanel_changes.description = ctx.request.description;
    			if (changed.request) requestpanel_changes.headers = ctx.request.headers;
    			if (changed.request) requestpanel_changes.contentType = ctx.request.contentType;
    			if (changed.request) requestpanel_changes.example = ctx.request.example;
    			if (changed.request) requestpanel_changes.schema = ctx.request.schema;
    			requestpanel.$set(requestpanel_changes);
    			const responsepanel_changes = {};
    			if (changed.response) responsepanel_changes.title = ctx.response.title;
    			if (changed.response) responsepanel_changes.description = ctx.response.description;
    			if (changed.response) responsepanel_changes.statusCode = ctx.response.statusCode;
    			if (changed.response) responsepanel_changes.headers = ctx.response.headers;
    			if (changed.response) responsepanel_changes.contentType = ctx.response.contentType;
    			if (changed.response) responsepanel_changes.example = ctx.response.example;
    			if (changed.response) responsepanel_changes.schema = ctx.response.schema;
    			responsepanel.$set(responsepanel_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(requestpanel.$$.fragment, local);
    			transition_in(responsepanel.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(requestpanel.$$.fragment, local);
    			transition_out(responsepanel.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(requestpanel);
    			destroy_component(responsepanel);
    		}
    	};
    }

    // (30:0) <CollapsiblePanel {isDarkmode} {show}>
    function create_default_slot$1(ctx) {
    	let t;
    	let current;

    	return {
    		c() {
    			t = space();
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    function create_fragment$h(ctx) {
    	let current;

    	const collapsiblepanel = new CollapsiblePanel({
    			props: {
    				isDarkmode: ctx.isDarkmode,
    				show: ctx.show,
    				$$slots: {
    					default: [create_default_slot$1],
    					body: [create_body_slot$1],
    					heading: [create_heading_slot$1]
    				},
    				$$scope: { ctx }
    			}
    		});

    	return {
    		c() {
    			create_component(collapsiblepanel.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(collapsiblepanel, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const collapsiblepanel_changes = {};
    			if (changed.isDarkmode) collapsiblepanel_changes.isDarkmode = ctx.isDarkmode;
    			if (changed.show) collapsiblepanel_changes.show = ctx.show;

    			if (changed.$$scope || changed.response || changed.request || changed.index) {
    				collapsiblepanel_changes.$$scope = { changed, ctx };
    			}

    			collapsiblepanel.$set(collapsiblepanel_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(collapsiblepanel.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(collapsiblepanel.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(collapsiblepanel, detaching);
    		}
    	};
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { show } = $$props;
    	let { count } = $$props;
    	let { index } = $$props;
    	let { request } = $$props;
    	let { response } = $$props;
    	let { isDarkmode } = $$props;

    	function title(index) {
    		if (request.title) {
    			return `Request ${request.title}`;
    		}

    		if (count === 1) {
    			return "Request";
    		} else {
    			return `Request ${index + 1}`;
    		}
    	}

    	$$self.$set = $$props => {
    		if ("show" in $$props) $$invalidate("show", show = $$props.show);
    		if ("count" in $$props) $$invalidate("count", count = $$props.count);
    		if ("index" in $$props) $$invalidate("index", index = $$props.index);
    		if ("request" in $$props) $$invalidate("request", request = $$props.request);
    		if ("response" in $$props) $$invalidate("response", response = $$props.response);
    		if ("isDarkmode" in $$props) $$invalidate("isDarkmode", isDarkmode = $$props.isDarkmode);
    	};

    	return {
    		show,
    		count,
    		index,
    		request,
    		response,
    		isDarkmode,
    		title
    	};
    }

    class ScenarioPanel extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			show: 0,
    			count: 0,
    			index: 0,
    			request: 0,
    			response: 0,
    			isDarkmode: 0
    		});
    	}
    }

    /* node_modules/snowboard/templates/winter.svelte generated by Svelte v3.15.0 */

    const { Object: Object_1$2, document: document_1 } = globals;

    function add_css$9() {
    	var style = element("style");
    	style.id = "svelte-1jcck2f-style";
    	style.textContent = "html{height:100%}body{min-height:100%}.sidenav.svelte-1jcck2f{padding:1rem 0 1rem 0.75rem}.main.svelte-1jcck2f{padding:3rem;background-color:#fff;box-shadow:0 2px 0 2px #f5f5f5}.main.is-darkmode.svelte-1jcck2f{background-color:#000;box-shadow:0 2px 0 2px #363636}.breadcrumb-right.svelte-1jcck2f{margin-top:0.3em}.box-wrapper.svelte-1jcck2f{border-radius:0}.body-inner.svelte-1jcck2f{min-height:100vh;background-color:#fafafa}.body-inner.is-darkmode.svelte-1jcck2f{background-color:#000}.is-darkmode .input, .is-darkmode .select select, .is-darkmode\n      .textarea{background-color:#484848;border-color:#484848;color:#fff}.is-darkmode .input:hover, .is-darkmode\n      .is-hovered.input, .is-darkmode .is-hovered.textarea, .is-darkmode\n      .select\n      select.is-hovered, .is-darkmode .select select:hover, .is-darkmode\n      .textarea:hover{border-color:#666}.is-darkmode .select select.is-focused, .is-darkmode\n      .select\n      select:active, .is-darkmode .select select:focus, .is-darkmode\n      .textarea:active, .is-darkmode .textarea:focus{border-color:#888}.is-darkmode .input::placeholder, .is-darkmode\n      .select\n      select::placeholder, .is-darkmode .textarea::placeholder{color:#ccc}code[class*=\"language-\"], pre[class*=\"language-\"]{font-family:monospace}.token.number, .token.tag{display:inline;padding:inherit;font-size:inherit;line-height:inherit;text-align:inherit;vertical-align:inherit;border-radius:inherit;font-weight:inherit;white-space:inherit;background:inherit;margin:inherit}.icon-brand.svelte-1jcck2f{margin-right:0.5rem}.menu-collapsible.svelte-1jcck2f{display:none;position:fixed;width:calc(25% - 0.5rem);height:calc(2.5rem + 10px);left:0;bottom:0;font-size:1.33333em;line-height:calc(2.5rem + 5px);text-align:center;color:#b5b5b5;font-weight:300;border-top:1px solid #eee;box-shadow:2px 0 0 #f5f5f5;cursor:pointer}.menu-collapsible.svelte-1jcck2f:hover{background:rgba(0, 0, 0, 0.05);box-shadow:2px 0 0 #eee;border-color:#e8e8e8}.menu-collapsible.is-darkmode.svelte-1jcck2f{border-color:#363636;box-shadow:2px 0 0 #363636}.menu-collapsible.is-darkmode.svelte-1jcck2f:hover{background:rgba(255, 255, 255, 0.2);border-color:#363636;box-shadow:2px 0 0 #363636}.footer.is-darkmode.svelte-1jcck2f{background-color:#000}.footer.svelte-1jcck2f .content.svelte-1jcck2f{transition:margin 0.3s}@media screen and (min-width: 768px){.menu-collapsible.svelte-1jcck2f{display:block}.is-collapsed.svelte-1jcck2f .sidenav.svelte-1jcck2f{width:3.75rem}.is-collapsed.svelte-1jcck2f .main.svelte-1jcck2f{width:calc(100% - 4.5rem)}.is-collapsed.svelte-1jcck2f .menu-collapsible.svelte-1jcck2f{width:calc(3rem - 2px)}.menu-collapsible.svelte-1jcck2f,.sidenav.svelte-1jcck2f,.main.svelte-1jcck2f{transition:width 0.3s}}";
    	append(document_1.head, style);
    }

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = Object_1$2.create(ctx);
    	child_ctx.request = list[i].request;
    	child_ctx.response = list[i].response;
    	child_ctx.index = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = Object_1$2.create(ctx);
    	child_ctx.tag = list[i];
    	child_ctx.index = i;
    	return child_ctx;
    }

    // (438:8) {#if config.playground.enabled}
    function create_if_block_8$1(ctx) {
    	let current;

    	const selectorpanel = new SelectorPanel({
    			props: {
    				environments: ctx.config.playground.environments,
    				authenticating: ctx.authenticating
    			}
    		});

    	return {
    		c() {
    			create_component(selectorpanel.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(selectorpanel, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const selectorpanel_changes = {};
    			if (changed.config) selectorpanel_changes.environments = ctx.config.playground.environments;
    			if (changed.authenticating) selectorpanel_changes.authenticating = ctx.authenticating;
    			selectorpanel.$set(selectorpanel_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(selectorpanel.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(selectorpanel.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(selectorpanel, detaching);
    		}
    	};
    }

    // (443:8) {#if darkMode.enable}
    function create_if_block_7$1(ctx) {
    	let div;
    	let a;
    	let span;
    	let i;
    	let dispose;

    	return {
    		c() {
    			div = element("div");
    			a = element("a");
    			span = element("span");
    			i = element("i");
    			attr(i, "class", "fas fa-lg");
    			toggle_class(i, "fa-moon", ctx.darkMode.active);
    			toggle_class(i, "fa-sun", !ctx.darkMode.active);
    			attr(span, "class", "icon is-medium has-text-grey-light");
    			attr(a, "href", "javascript:void(0)");
    			attr(a, "title", "Dark Mode");
    			attr(a, "class", "navbar-link is-arrowless");
    			attr(div, "class", "navbar-item has-dropdown is-hoverable");
    			dispose = listen(a, "click", ctx.darkToggle);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, a);
    			append(a, span);
    			append(span, i);
    		},
    		p(changed, ctx) {
    			if (changed.darkMode) {
    				toggle_class(i, "fa-moon", ctx.darkMode.active);
    			}

    			if (changed.darkMode) {
    				toggle_class(i, "fa-sun", !ctx.darkMode.active);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			dispose();
    		}
    	};
    }

    // (485:8) {#if collapsed}
    function create_if_block_6$1(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			span.textContent = "»";
    			attr(span, "class", "icon");
    			attr(span, "title", "Expand [");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (488:8) {#if !collapsed}
    function create_if_block_5$1(ctx) {
    	let span0;
    	let t1;
    	let span1;

    	return {
    		c() {
    			span0 = element("span");
    			span0.textContent = "«";
    			t1 = space();
    			span1 = element("span");
    			span1.textContent = "Collapse sidebar";
    			attr(span0, "class", "icon");
    			attr(span1, "class", "fa-xs");
    		},
    		m(target, anchor) {
    			insert(target, span0, anchor);
    			insert(target, t1, anchor);
    			insert(target, span1, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span0);
    			if (detaching) detach(t1);
    			if (detaching) detach(span1);
    		}
    	};
    }

    // (498:6) {#if index === -1}
    function create_if_block_4$1(ctx) {
    	let div;
    	let raw_value = markdown(ctx.description) + "";

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "content");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p(changed, ctx) {
    			if (changed.description && raw_value !== (raw_value = markdown(ctx.description) + "")) div.innerHTML = raw_value;;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (504:6) {#if currentAction}
    function create_if_block$b(ctx) {
    	let div2;
    	let div0;
    	let h1;
    	let t0_value = ctx.currentAction.title + "";
    	let t0;
    	let t1;
    	let div1;
    	let nav;
    	let ul;
    	let t2;
    	let hr;
    	let t3;
    	let div3;
    	let code0;
    	let t4_value = ctx.currentAction.method + "";
    	let t4;
    	let code0_class_value;
    	let t5;
    	let code1;
    	let t6_value = ctx.currentAction.pathTemplate + "";
    	let t6;
    	let t7;
    	let div4;
    	let raw_value = markdown(ctx.currentAction.description) + "";
    	let t8;
    	let t9;
    	let t10;
    	let each1_anchor;
    	let current;
    	let each_value_1 = ctx.currentAction.tags;
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let if_block = ctx.config.playground.enabled && create_if_block_1$8(ctx);

    	const parameterpanel = new ParameterPanel({
    			props: { parameters: ctx.currentAction.parameters }
    		});

    	let each_value = ctx.currentAction.transactions;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			nav = element("nav");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			hr = element("hr");
    			t3 = space();
    			div3 = element("div");
    			code0 = element("code");
    			t4 = text(t4_value);
    			t5 = space();
    			code1 = element("code");
    			t6 = text(t6_value);
    			t7 = space();
    			div4 = element("div");
    			t8 = space();
    			if (if_block) if_block.c();
    			t9 = space();
    			create_component(parameterpanel.$$.fragment);
    			t10 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each1_anchor = empty();
    			attr(h1, "class", "title is-4");
    			attr(div0, "class", "column");
    			attr(nav, "class", "breadcrumb breadcrumb-right is-pulled-right svelte-1jcck2f");
    			attr(nav, "aria-label", "breadcrumbs");
    			attr(div1, "class", "column");
    			attr(div2, "class", "columns");
    			attr(code0, "class", code0_class_value = "tag is-uppercase " + colorize(ctx.currentAction.method) + " svelte-1jcck2f");
    			attr(code1, "class", "tag ");
    			attr(div3, "class", "tags has-addons are-large");
    			attr(div4, "class", "content");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div0, h1);
    			append(h1, t0);
    			append(div2, t1);
    			append(div2, div1);
    			append(div1, nav);
    			append(nav, ul);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul, null);
    			}

    			insert(target, t2, anchor);
    			insert(target, hr, anchor);
    			insert(target, t3, anchor);
    			insert(target, div3, anchor);
    			append(div3, code0);
    			append(code0, t4);
    			append(div3, t5);
    			append(div3, code1);
    			append(code1, t6);
    			insert(target, t7, anchor);
    			insert(target, div4, anchor);
    			div4.innerHTML = raw_value;
    			insert(target, t8, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, t9, anchor);
    			mount_component(parameterpanel, target, anchor);
    			insert(target, t10, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each1_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if ((!current || changed.currentAction) && t0_value !== (t0_value = ctx.currentAction.title + "")) set_data(t0, t0_value);

    			if (changed.currentAction || changed.slugify || changed.handleGroupClick) {
    				each_value_1 = ctx.currentAction.tags;
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(changed, child_ctx);
    					} else {
    						each_blocks_1[i] = create_each_block_1$2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if ((!current || changed.currentAction) && t4_value !== (t4_value = ctx.currentAction.method + "")) set_data(t4, t4_value);

    			if (!current || changed.currentAction && code0_class_value !== (code0_class_value = "tag is-uppercase " + colorize(ctx.currentAction.method) + " svelte-1jcck2f")) {
    				attr(code0, "class", code0_class_value);
    			}

    			if ((!current || changed.currentAction) && t6_value !== (t6_value = ctx.currentAction.pathTemplate + "")) set_data(t6, t6_value);
    			if ((!current || changed.currentAction) && raw_value !== (raw_value = markdown(ctx.currentAction.description) + "")) div4.innerHTML = raw_value;;

    			if (ctx.config.playground.enabled) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t9.parentNode, t9);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const parameterpanel_changes = {};
    			if (changed.currentAction) parameterpanel_changes.parameters = ctx.currentAction.parameters;
    			parameterpanel.$set(parameterpanel_changes);

    			if (changed.darkMode || changed.currentAction) {
    				each_value = ctx.currentAction.transactions;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(parameterpanel.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			transition_out(parameterpanel.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach(t2);
    			if (detaching) detach(hr);
    			if (detaching) detach(t3);
    			if (detaching) detach(div3);
    			if (detaching) detach(t7);
    			if (detaching) detach(div4);
    			if (detaching) detach(t8);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(t9);
    			destroy_component(parameterpanel, detaching);
    			if (detaching) detach(t10);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each1_anchor);
    		}
    	};
    }

    // (518:20) {:else}
    function create_else_block$3(ctx) {
    	let a;
    	let t_value = ctx.tag + "";
    	let t;
    	let a_data_slug_value;
    	let a_href_value;
    	let dispose;

    	return {
    		c() {
    			a = element("a");
    			t = text(t_value);
    			attr(a, "data-slug", a_data_slug_value = slugify(ctx.tag));
    			attr(a, "href", a_href_value = "#/g~" + slugify(ctx.tag));
    			dispose = listen(a, "click", ctx.handleGroupClick);
    		},
    		m(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t);
    		},
    		p(changed, ctx) {
    			if (changed.currentAction && t_value !== (t_value = ctx.tag + "")) set_data(t, t_value);

    			if (changed.currentAction && a_data_slug_value !== (a_data_slug_value = slugify(ctx.tag))) {
    				attr(a, "data-slug", a_data_slug_value);
    			}

    			if (changed.currentAction && a_href_value !== (a_href_value = "#/g~" + slugify(ctx.tag))) {
    				attr(a, "href", a_href_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(a);
    			dispose();
    		}
    	};
    }

    // (516:20) {#if index === 0}
    function create_if_block_3$3(ctx) {
    	let a;
    	let t_value = ctx.tag + "";
    	let t;

    	return {
    		c() {
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", "javascript:void(0)");
    		},
    		m(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t);
    		},
    		p(changed, ctx) {
    			if (changed.currentAction && t_value !== (t_value = ctx.tag + "")) set_data(t, t_value);
    		},
    		d(detaching) {
    			if (detaching) detach(a);
    		}
    	};
    }

    // (514:16) {#each currentAction.tags as tag, index}
    function create_each_block_1$2(ctx) {
    	let li;
    	let t;

    	function select_block_type(changed, ctx) {
    		if (ctx.index === 0) return create_if_block_3$3;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(null, ctx);
    	let if_block = current_block_type(ctx);

    	return {
    		c() {
    			li = element("li");
    			if_block.c();
    			t = space();
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			if_block.m(li, null);
    			append(li, t);
    		},
    		p(changed, ctx) {
    			if_block.p(changed, ctx);
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			if_block.d();
    		}
    	};
    }

    // (546:8) {#if config.playground.enabled}
    function create_if_block_1$8(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = ctx.environment.playground !== false && create_if_block_2$4(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (ctx.environment.playground !== false) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (547:10) {#if environment.playground !== false}
    function create_if_block_2$4(ctx) {
    	let current;

    	const playgroundpanel = new PlaygroundPanel({
    			props: {
    				currentAction: ctx.currentAction,
    				environments: ctx.config.playground.environments,
    				currentSample: sample(ctx.currentAction),
    				requestHeaders: headersMap(ctx.currentAction),
    				requestParameters: parametersMap(ctx.currentAction),
    				requestBody: bodyMap(ctx.currentAction),
    				isDarkmode: ctx.darkMode.active
    			}
    		});

    	return {
    		c() {
    			create_component(playgroundpanel.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(playgroundpanel, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const playgroundpanel_changes = {};
    			if (changed.currentAction) playgroundpanel_changes.currentAction = ctx.currentAction;
    			if (changed.config) playgroundpanel_changes.environments = ctx.config.playground.environments;
    			if (changed.currentAction) playgroundpanel_changes.currentSample = sample(ctx.currentAction);
    			if (changed.currentAction) playgroundpanel_changes.requestHeaders = headersMap(ctx.currentAction);
    			if (changed.currentAction) playgroundpanel_changes.requestParameters = parametersMap(ctx.currentAction);
    			if (changed.currentAction) playgroundpanel_changes.requestBody = bodyMap(ctx.currentAction);
    			if (changed.darkMode) playgroundpanel_changes.isDarkmode = ctx.darkMode.active;
    			playgroundpanel.$set(playgroundpanel_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(playgroundpanel.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(playgroundpanel.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(playgroundpanel, detaching);
    		}
    	};
    }

    // (561:8) {#each currentAction.transactions as { request, response }
    function create_each_block$6(ctx) {
    	let current;

    	const scenariopanel = new ScenarioPanel({
    			props: {
    				show: ctx.index === 0,
    				isDarkmode: ctx.darkMode.active,
    				request: ctx.request,
    				response: ctx.response,
    				index: ctx.index,
    				count: ctx.currentAction.transactions.length
    			}
    		});

    	return {
    		c() {
    			create_component(scenariopanel.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(scenariopanel, target, anchor);
    			current = true;
    		},
    		p(changed, ctx) {
    			const scenariopanel_changes = {};
    			if (changed.darkMode) scenariopanel_changes.isDarkmode = ctx.darkMode.active;
    			if (changed.currentAction) scenariopanel_changes.request = ctx.request;
    			if (changed.currentAction) scenariopanel_changes.response = ctx.response;
    			if (changed.currentAction) scenariopanel_changes.count = ctx.currentAction.transactions.length;
    			scenariopanel.$set(scenariopanel_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(scenariopanel.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(scenariopanel.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(scenariopanel, detaching);
    		}
    	};
    }

    function create_fragment$i(ctx) {
    	let div8;
    	let nav;
    	let div0;
    	let a0;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let t2;
    	let a1;
    	let t5;
    	let div2;
    	let div1;
    	let t6;
    	let t7;
    	let div6;
    	let div4;
    	let t8;
    	let div3;
    	let t9;
    	let t10;
    	let div5;
    	let t11;
    	let t12;
    	let footer;
    	let div7;
    	let p;
    	let strong0;
    	let t13;
    	let t14;
    	let a2;
    	let current;
    	let dispose;
    	let if_block0 = ctx.config.playground.enabled && create_if_block_8$1(ctx);
    	let if_block1 = ctx.darkMode.enable && create_if_block_7$1(ctx);

    	const menupanel = new MenuPanel({
    			props: {
    				tagActions: ctx.tagActions,
    				tagHeaders: toc(ctx.description),
    				currentSlug: ctx.currentAction && ctx.currentAction.slug,
    				actionsCount: ctx.actions.length,
    				isCollapsed: ctx.collapsed,
    				isDarkmode: ctx.darkMode.active,
    				query: ctx.query,
    				config: ctx.config,
    				handleClick: ctx.handleClick,
    				handleGroupClick: ctx.handleGroupClick,
    				tocClick: ctx.tocClick,
    				searchClick: ctx.searchClick
    			}
    		});

    	let if_block2 = ctx.collapsed && create_if_block_6$1(ctx);
    	let if_block3 = !ctx.collapsed && create_if_block_5$1(ctx);
    	let if_block4 = ctx.index === -1 && create_if_block_4$1(ctx);
    	let if_block5 = ctx.currentAction && create_if_block$b(ctx);

    	return {
    		c() {
    			div8 = element("div");
    			nav = element("nav");
    			div0 = element("div");
    			a0 = element("a");
    			span0 = element("span");
    			span0.innerHTML = `<i class="fas fa-lg fa-chalkboard"></i>`;
    			t0 = space();
    			span1 = element("span");
    			t1 = text(ctx.title);
    			t2 = space();
    			a1 = element("a");

    			a1.innerHTML = `<span aria-hidden="true"></span> 
        <span aria-hidden="true"></span> 
        <span aria-hidden="true"></span>`;

    			t5 = space();
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			div6 = element("div");
    			div4 = element("div");
    			create_component(menupanel.$$.fragment);
    			t8 = space();
    			div3 = element("div");
    			if (if_block2) if_block2.c();
    			t9 = space();
    			if (if_block3) if_block3.c();
    			t10 = space();
    			div5 = element("div");
    			if (if_block4) if_block4.c();
    			t11 = space();
    			if (if_block5) if_block5.c();
    			t12 = space();
    			footer = element("footer");
    			div7 = element("div");
    			p = element("p");
    			strong0 = element("strong");
    			t13 = text(ctx.title);
    			t14 = text("\n        powered by\n        ");
    			a2 = element("a");
    			a2.innerHTML = `<strong>Snowboard.</strong>`;
    			attr(span0, "class", "icon icon-brand is-medium has-text-grey-light svelte-1jcck2f");
    			attr(span1, "class", "title is-4");
    			attr(a0, "href", "javascript:void(0)");
    			attr(a0, "class", "navbar-item");
    			attr(a1, "href", "javascript:void(0)");
    			attr(a1, "role", "button");
    			attr(a1, "class", "navbar-burger");
    			attr(a1, "aria-label", "menu");
    			attr(a1, "aria-expanded", "false");
    			attr(a1, "data-target", "mainnav");
    			attr(div0, "class", "navbar-brand");
    			attr(div1, "class", "navbar-end");
    			attr(div2, "class", "navbar-menu");
    			attr(nav, "class", "navbar is-fixed-top has-shadow");
    			attr(nav, "role", "navigation");
    			attr(nav, "aria-label", "main navigation");
    			attr(div3, "class", "menu-collapsible svelte-1jcck2f");
    			toggle_class(div3, "is-darkmode", ctx.darkMode.active);
    			attr(div4, "class", "column is-one-quarter sidenav svelte-1jcck2f");
    			attr(div4, "id", "mainnav");
    			toggle_class(div4, "is-hidden-mobile", ctx.showMenu);
    			attr(div5, "class", "column is-three-quarters main svelte-1jcck2f");
    			toggle_class(div5, "is-darkmode", ctx.darkMode.active);
    			attr(div6, "class", "columns svelte-1jcck2f");
    			toggle_class(div6, "is-collapsed", ctx.collapsed);
    			attr(a2, "href", "https://github.com/bukalapak/snowboard");
    			attr(a2, "target", "_blank");
    			attr(div7, "class", "content column is-paddingless has-text-centered svelte-1jcck2f");
    			toggle_class(div7, "is-offset-one-quarter", !ctx.collapsed);
    			attr(footer, "class", "footer svelte-1jcck2f");
    			toggle_class(footer, "is-darkmode", ctx.darkMode.active);
    			attr(div8, "class", "body-inner svelte-1jcck2f");
    			toggle_class(div8, "is-darkmode", ctx.darkMode.active);

    			dispose = [
    				listen(a1, "click", ctx.burgerClick),
    				listen(div3, "click", ctx.collapseToggle)
    			];
    		},
    		m(target, anchor) {
    			insert(target, div8, anchor);
    			append(div8, nav);
    			append(nav, div0);
    			append(div0, a0);
    			append(a0, span0);
    			append(a0, t0);
    			append(a0, span1);
    			append(span1, t1);
    			append(div0, t2);
    			append(div0, a1);
    			append(nav, t5);
    			append(nav, div2);
    			append(div2, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append(div1, t6);
    			if (if_block1) if_block1.m(div1, null);
    			append(div8, t7);
    			append(div8, div6);
    			append(div6, div4);
    			mount_component(menupanel, div4, null);
    			append(div4, t8);
    			append(div4, div3);
    			if (if_block2) if_block2.m(div3, null);
    			append(div3, t9);
    			if (if_block3) if_block3.m(div3, null);
    			append(div6, t10);
    			append(div6, div5);
    			if (if_block4) if_block4.m(div5, null);
    			append(div5, t11);
    			if (if_block5) if_block5.m(div5, null);
    			append(div8, t12);
    			append(div8, footer);
    			append(footer, div7);
    			append(div7, p);
    			append(p, strong0);
    			append(strong0, t13);
    			append(p, t14);
    			append(p, a2);
    			current = true;
    		},
    		p(changed, ctx) {
    			if (!current || changed.title) set_data(t1, ctx.title);

    			if (ctx.config.playground.enabled) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_8$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t6);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (ctx.darkMode.enable) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_7$1(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const menupanel_changes = {};
    			if (changed.tagActions) menupanel_changes.tagActions = ctx.tagActions;
    			if (changed.description) menupanel_changes.tagHeaders = toc(ctx.description);
    			if (changed.currentAction) menupanel_changes.currentSlug = ctx.currentAction && ctx.currentAction.slug;
    			if (changed.actions) menupanel_changes.actionsCount = ctx.actions.length;
    			if (changed.collapsed) menupanel_changes.isCollapsed = ctx.collapsed;
    			if (changed.darkMode) menupanel_changes.isDarkmode = ctx.darkMode.active;
    			if (changed.query) menupanel_changes.query = ctx.query;
    			if (changed.config) menupanel_changes.config = ctx.config;
    			menupanel.$set(menupanel_changes);

    			if (ctx.collapsed) {
    				if (!if_block2) {
    					if_block2 = create_if_block_6$1(ctx);
    					if_block2.c();
    					if_block2.m(div3, t9);
    				} else {
    					
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (!ctx.collapsed) {
    				if (!if_block3) {
    					if_block3 = create_if_block_5$1(ctx);
    					if_block3.c();
    					if_block3.m(div3, null);
    				} else {
    					
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (changed.darkMode) {
    				toggle_class(div3, "is-darkmode", ctx.darkMode.active);
    			}

    			if (changed.showMenu) {
    				toggle_class(div4, "is-hidden-mobile", ctx.showMenu);
    			}

    			if (ctx.index === -1) {
    				if (if_block4) {
    					if_block4.p(changed, ctx);
    				} else {
    					if_block4 = create_if_block_4$1(ctx);
    					if_block4.c();
    					if_block4.m(div5, t11);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (ctx.currentAction) {
    				if (if_block5) {
    					if_block5.p(changed, ctx);
    					transition_in(if_block5, 1);
    				} else {
    					if_block5 = create_if_block$b(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div5, null);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (changed.darkMode) {
    				toggle_class(div5, "is-darkmode", ctx.darkMode.active);
    			}

    			if (changed.collapsed) {
    				toggle_class(div6, "is-collapsed", ctx.collapsed);
    			}

    			if (!current || changed.title) set_data(t13, ctx.title);

    			if (changed.collapsed) {
    				toggle_class(div7, "is-offset-one-quarter", !ctx.collapsed);
    			}

    			if (changed.darkMode) {
    				toggle_class(footer, "is-darkmode", ctx.darkMode.active);
    			}

    			if (changed.darkMode) {
    				toggle_class(div8, "is-darkmode", ctx.darkMode.active);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(menupanel.$$.fragment, local);
    			transition_in(if_block5);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block0);
    			transition_out(menupanel.$$.fragment, local);
    			transition_out(if_block5);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div8);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(menupanel);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			run_all(dispose);
    		}
    	};
    }

    function sample(action) {
    	return action.transactions[0].request;
    }

    function headersMap(action) {
    	return sample(action).headers.filter(header => header.name != "Authorization").map(header => {
    		return {
    			used: true,
    			required: false,
    			name: header.name,
    			value: header.example || ""
    		};
    	});
    }

    function parametersMap(action) {
    	return action.parameters.map(param => {
    		return {
    			used: param.required,
    			required: param.required,
    			name: param.name,
    			value: param.example || ""
    		};
    	});
    }

    function bodyMap(action) {
    	const example = sample(action).example;
    	return stringify$2(example);
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $env;
    	component_subscribe($$self, env, $$value => $$invalidate("$env", $env = $$value));
    	let { title } = $$props;
    	let { description } = $$props;
    	let { actions } = $$props;
    	let { tagActions } = $$props;
    	let { config } = $$props;
    	let index = -1;

    	function handleClick(event) {
    		let target = event.target;

    		if (target.nodeName == "SPAN") {
    			target = target.parentElement;
    		}

    		const slug = target.dataset["slug"];
    		$$invalidate("index", index = actions.findIndex(el => el.slug === slug));
    		document.body.scrollTop = document.documentElement.scrollTop = 0;
    	}

    	function handleGroupClick(event) {
    		const groupSlug = event.target.dataset["slug"];
    		const firstAction = firstGroupAction(groupSlug);

    		if (firstAction) {
    			const slug = firstAction.slug;
    			$$invalidate("index", index = actions.findIndex(el => el.slug === slug));
    			$$invalidate("query", query = `g:${groupSlug}`);
    			document.body.scrollTop = document.documentElement.scrollTop = 0;
    		}
    	}

    	function firstGroupAction(groupSlug) {
    		let matches = [];

    		tagActions.forEach(tag => {
    			matches = matches.concat(tag.children.filter(child => slugify(child.title) === groupSlug));
    		});

    		if (matches.length > 0) {
    			return matches[0].actions[0];
    		}
    	}

    	function tocClick(event) {
    		$$invalidate("index", index = -1);
    		let href = event.target.getAttribute("href");
    		pushHistory(href);
    	}

    	if (config.playground.enabled) {
    		const savedEnv = getEnv();

    		if (savedEnv && Object.keys(config.playground.environments).includes(savedEnv)) {
    			env.set(savedEnv);
    		} else {
    			env.set(config.playground.env);
    		}

    		const authToken = getToken($env);

    		if (authToken) {
    			auth.add($env);
    			token.set(authToken);
    		}
    	}

    	let showMenu = true;
    	let collapsed = false;
    	let authenticating = false;
    	let query = "";

    	function burgerClick() {
    		$$invalidate("showMenu", showMenu = !showMenu);
    	}

    	function collapseToggle() {
    		$$invalidate("collapsed", collapsed = !collapsed);
    	}

    	function searchClick() {
    		collapseToggle();
    		const searchInput = document.getElementById("search-input-text");

    		if (searchInput) {
    			searchInput.focus();
    		}
    	}

    	const darkMode = {
    		enable: true,
    		store: window.localStorage,
    		toggle: "darkmode-toggle",
    		mode: ["light", "dark"],
    		active: false
    	};

    	function darkToggle() {
    		$$invalidate("darkMode", darkMode.active = !darkMode.active, darkMode);
    		document.getElementById(`bulma-theme-${darkMode.mode[Number(!darkMode.active)]}`).media = "none";
    		document.getElementById(`bulma-theme-${darkMode.mode[Number(darkMode.active)]}`).media = "";
    		darkMode.store.setItem(darkMode.toggle, darkMode.mode[Number(darkMode.active)]);
    	}

    	if (darkMode.store.getItem(darkMode.toggle) === darkMode.mode[1]) {
    		darkToggle();
    	}

    	onMount(async () => {
    		if (isAuth(environment, "oauth2")) {
    			const authParam = querystringify_1.parse(location.search);

    			if (authParam.code) {
    				$$invalidate("authenticating", authenticating = true);
    				pushHistory(basePath(config));
    				const { accessToken, refreshToken } = await exchangeToken(authParam.code, environment.auth.options);

    				if (accessToken) {
    					setToken($env, accessToken);
    					auth.add($env);
    					token.set(accessToken);

    					if (refreshToken) {
    						setRefreshToken($env, refreshToken);
    					}
    				}

    				$$invalidate("authenticating", authenticating = false);
    			}
    		}

    		const hash = location.hash;

    		if (hash.match("#/")) {
    			let slug = hash.replace("#/", "");

    			if (slug.startsWith("g~")) {
    				const groupSlug = slug.substr(2);
    				const firstAction = firstGroupAction(groupSlug);

    				if (firstAction) {
    					slug = firstAction.slug;
    					$$invalidate("query", query = `g:${groupSlug}`);
    				}
    			}

    			$$invalidate("index", index = actions.findIndex(el => el.slug === slug));
    		}
    	});

    	document.onkeyup = function (e) {
    		if ((e.which || e.keyCode) == 219) {
    			collapseToggle();
    		}
    	};

    	$$self.$set = $$props => {
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("description" in $$props) $$invalidate("description", description = $$props.description);
    		if ("actions" in $$props) $$invalidate("actions", actions = $$props.actions);
    		if ("tagActions" in $$props) $$invalidate("tagActions", tagActions = $$props.tagActions);
    		if ("config" in $$props) $$invalidate("config", config = $$props.config);
    	};

    	let currentAction;
    	let environment;

    	$$self.$$.update = (changed = { actions: 1, index: 1, currentAction: 1, title: 1, config: 1, $env: 1 }) => {
    		if (changed.actions || changed.index) {
    			 $$invalidate("currentAction", currentAction = actions[index]);
    		}

    		if (changed.currentAction || changed.title) {
    			 {
    				document.title = currentAction && `${currentAction.title} - ${title}` || title;
    			}
    		}

    		if (changed.config || changed.$env) {
    			 $$invalidate("environment", environment = config.playground.enabled && config.playground.environments[$env]);
    		}
    	};

    	return {
    		title,
    		description,
    		actions,
    		tagActions,
    		config,
    		index,
    		handleClick,
    		handleGroupClick,
    		tocClick,
    		showMenu,
    		collapsed,
    		authenticating,
    		query,
    		burgerClick,
    		collapseToggle,
    		searchClick,
    		darkMode,
    		darkToggle,
    		currentAction,
    		environment
    	};
    }

    class Winter extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document_1.getElementById("svelte-1jcck2f-style")) add_css$9();

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			title: 0,
    			description: 0,
    			actions: 0,
    			tagActions: 0,
    			config: 0
    		});
    	}
    }

    const app = new Winter({
      target: document.body,
      props: {"title":"Attendance Service","description":"The Attendance Service is responsible for storing the attendance events of students. This service has a dependency on the Course Service.","version":"","servers":[],"tags":[{"title":"Attendance","description":"","children":[{"title":"Attendance","description":"","children":[]}]}],"actions":[{"title":"List all attendance","path":"/attendance","pathTemplate":"/attendance{?uid}{?sectionId}{?courseId}{?start}{?end}","slug":"get~attendance","method":"get","description":"\n","parameters":[{"location":"query","name":"uid","description":"Filters attendance to include only attendance from the provided student.","required":false,"schema":{"type":"number"}},{"location":"query","name":"sectionId","description":"0101 (number, optional) - Filters by section, in the format [DEPARTMENT_ID][COURSE_NUM]-[SECTION_NUM].","required":true,"example":"CMSC216","schema":{"type":""}},{"location":"query","name":"courseId","description":"Filters by course.","required":false,"schema":{"type":"number"}},{"location":"query","name":"start","description":"Filters attendance to include only attendance that occured on or after the start datetime.","required":false,"schema":{"type":"number"}},{"location":"query","name":"end","description":"Filters attendance to include only attendance that occured on or before the end datetime.","required":false,"schema":{"type":"number"}}],"transactions":[{"request":{"title":"","description":"","headers":[],"example":"","schema":""},"response":{"statusCode":200,"title":"","description":"","contentType":"application/json","headers":[{"name":"Content-Type","example":"application/json","required":false,"schema":{"type":"string"}}],"example":"[\n    {\n        \"id\": 1,\n        \"uid\": 000001,\n        \"course_id\": \"cmsc132\",\n        \"section_id\": \"cmsc132-0101\",\n        \"timestamp\": \"2019-11-13T:19:18:22\",\n        \"meeting_type\": \"LEC\"\n    }\n]\n","schema":""}}],"tags":["Attendance","Attendance"]},{"title":"Create Student Attendance","path":"/attendance","pathTemplate":"/attendance","slug":"post~attendance","method":"post","description":"\n+ uid (string) - The uid of the student posting attendance.\n\n+ courseId (string) - The id of the course which the attendance will be logged for.\n\n+ sectionId (string) - The section id for the provided courseId.","parameters":[],"transactions":[{"request":{"title":"","description":"","headers":[],"example":"","schema":""},"response":{"statusCode":201,"title":"","description":"","contentType":"application/json","headers":[{"name":"Content-Type","example":"application/json","required":false,"schema":{"type":"string"}}],"example":"{\n    \"uid\": 000001,\n    \"sectionId\": \"CMSC132-0101\",\n    \"type\": \"LEC\",\n}\n","schema":""}}],"tags":["Attendance","Attendance"]}],"tagActions":[{"title":"Attendance","children":[{"title":"Attendance","actions":[{"title":"List all attendance","method":"get","path":"/attendance","slug":"get~attendance"},{"title":"Create Student Attendance","method":"post","path":"/attendance","slug":"post~attendance"}]}]}],"config":{"playground":{"enabled":false},"optimized":false,"stylesheets":[],"basePath":"/"}}
    });

    return app;

}());
</script>
  </body>
</html>
